// Generated by CoffeeScript 1.3.3
var Component, Force, Kinetic, Pool, Vec2, addForce,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Force = require('./force');

Vec2 = require('./math').Vec2;

addForce = Vec2();

Kinetic = (function(_super) {

  __extends(Kinetic, _super);

  Kinetic.prototype.type = 'kinetic';

  Kinetic.gravity = null;

  Kinetic.friction = 15;

  Kinetic.drag = 0.999;

  Kinetic.prototype.presets = {
    mass: 0,
    drag: Kinetic.drag,
    friction: Kinetic.friction,
    fixed: false,
    maxVel: 75,
    maxAcc: 2000,
    acc: Vec2(),
    vel: Vec2()
  };

  function Kinetic() {
    this.vel = Vec2();
    this.acc = Vec2();
    this.sleepVelSq = 0.2;
  }

  Kinetic.prototype.reset = function(presets) {
    this.mass = presets.mass, this.drag = presets.drag, this.friction = presets.friction, this.fixed = presets.fixed, this.maxVel = presets.maxVel, this.maxAcc = presets.maxAcc;
    Vec2.copy(this.vel, presets.vel);
    Vec2.copy(this.acc, presets.acc);
    this.pos = this.transform.pos;
    this.sleeping = false;
    return this;
  };

  Kinetic.prototype.applyForce = function(acc, ignoreMass, constant) {
    if (!ignoreMass && this.mass) {
      Vec2.scal(acc, 1 / this.mass, addForce);
    } else {
      Vec2.copy(addForce, acc);
    }
    if (constant && !this.force) {
      Force.alloc(this);
    }
    Vec2.add((constant ? this.force.force : this.acc), addForce);
    return this;
  };

  return Kinetic;

})(Component);

Kinetic.simulate = function(dt) {
  var acc, cache, copyVel, epsilon, kinetic, vel, _i, _len, _ref;
  copyVel = Vec2.cache[0];
  cache = Vec2.cache[1];
  epsilon = Math.epsilon;
  _ref = this.roster;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    kinetic = _ref[_i];
    if (!(kinetic.enabled && !kinetic.fixed)) {
      continue;
    }
    vel = kinetic.vel;
    acc = kinetic.acc;
    if (kinetic.root.gravity && kinetic.mass > epsilon) {
      Vec2.add(acc, Vec2.scal(this.root.gravity, 1 / kinetic.mass, cache));
    }
    if (kinetic.friction) {
      Vec2.add(acc, Vec2.scal(Vec2.norm(vel, cache), -kinetic.friction));
    }
    if (kinetic.maxAcc) {
      Vec2.limit(acc, kinetic.maxAcc);
    }
    Vec2.copy(copyVel, vel);
    Vec2.add(vel, Vec2.scal(acc, dt, cache));
    if (kinetic.maxVel) {
      Vec2.limit(vel, kinetic.maxVel);
    }
    Vec2.scal(Vec2.add(copyVel, vel), dt / 2);
    Vec2.add(kinetic.pos, copyVel);
    Vec2.add(vel, Vec2.scal(acc, dt));
    if (kinetic.drag < 1) {
      Vec2.scal(vel, kinetic.drag);
    }
    if (kinetic.sleepVelSq) {
      if (Vec2.lenSq(vel) <= kinetic.sleepVelSq) {
        if (!kinetic.sleeping) {
          Vec2.set(vel);
          kinetic.sleeping = true;
          kinetic.parent.pubUp('onKineticSleep', kinetic);
        }
      } else {
        if (kinetic.sleeping) {
          kinetic.sleeping = false;
          kinetic.parent.pubUp('onKineticWake', kinetic);
        }
      }
    }
    Vec2.set(acc);
  }
  return this;
};

new Pool(Kinetic);

module.exports = Kinetic;
