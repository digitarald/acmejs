// Generated by CoffeeScript 1.3.3
var Kinetic,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Kinetic = (function(_super) {

  __extends(Kinetic, _super);

  Kinetic.maxVel = 500;

  Kinetic.maxAcc = 10000;

  Kinetic.sleep = 1;

  Kinetic.sleepSq = Kinetic.sleep * Kinetic.sleep;

  Kinetic.prototype.name = 'kinetic';

  function Kinetic() {
    Kinetic.__super__.constructor.call(this);
    this.vel = Vec2();
    this.acc = Vec2();
  }

  Kinetic.prototype.alloc = function(parent, mass) {
    this.mass = mass != null ? mass : 0;
    Kinetic.__super__.alloc.call(this, parent);
    Vec2.set(this.vel);
    Vec2.set(this.acc);
    this.pos = parent.transform.pos;
    this.sleeping = true;
    this.fixed = false;
    this.massInv = mass ? 1 / mass : 0;
    this.maxVel = Kinetic.maxVel;
    this.maxAcc = Kinetic.maxAcc;
    this.drag = this.scene.drag;
    this.friction = this.scene.friction;
    return this;
  };

  return Kinetic;

})(Component);

Kinetic.simulate = function(dt, scene) {
  var acc, cache, copyAcc, copyVel, dtSq, kinetic, vel, _i, _len, _ref;
  dtSq = dt * dt * 0.5;
  copyVel = Vec2.cache[0];
  copyAcc = Vec2.cache[1];
  cache = Vec2.cache[2];
  _ref = this.roster;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    kinetic = _ref[_i];
    if (!(kinetic.enabled && !kinetic.fixed)) {
      continue;
    }
    vel = kinetic.vel;
    acc = kinetic.acc;
    if (scene.gravity && kinetic.mass > 0.01) {
      Vec2.add(acc, Vec2.scal(scene.gravity, kinetic.massInv, cache));
    }
    if (!kinetic.sleeping) {
      if (kinetic.friction) {
        Vec2.add(acc, Vec2.scal(Vec2.norm(vel, cache), -kinetic.friction));
      }
    }
    Vec2.add(kinetic.pos, Vec2.add(Vec2.scal(vel, dt, copyVel), Vec2.scal(acc, dtSq, copyAcc)));
    Vec2.add(vel, Vec2.scal(acc, dt));
    if (kinetic.drag < 1) {
      Vec2.scal(vel, kinetic.drag);
    }
    kinetic.sleeping = Vec2.lenSq(vel) < Kinetic.sleep;
    Vec2.set(acc);
  }
  return this;
};

new Pool(Kinetic);
