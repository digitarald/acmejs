// Generated by CoffeeScript 1.3.3
var Vec2, e, i, pow, powIn, powInOut, powOut, random, sqrt, transition, _i, _len, _ref;

Vec2 = function(fromOrX, y) {
  if (typeof y !== 'undefined') {
    return [fromOrX, y];
  }
  if (typeof fromOrX !== 'undefined') {
    return [fromOrX[0], fromOrX[1]];
  }
  return [0, 0];
};

Vec2.cache = [Vec2(), Vec2(), Vec2(), Vec2(), Vec2()];

Vec2.radCache = [Vec2(), Vec2()];

e = 0.00001;

sqrt = Math.sqrt;

Vec2.set = function(result, x, y) {
  result[0] = x || 0;
  result[1] = y || 0;
  return result;
};

Vec2.copy = function(result, b) {
  result[0] = b[0];
  result[1] = b[1];
  return result;
};

Vec2.eq = function(a, b) {
  var d1, d2;
  d1 = Math.abs(a[0] - b[0]);
  d2 = Math.abs(a[1] - b[1]);
  return d1 < e && d2 < e;
};

Vec2.add = function(a, b, result) {
  result = result || a;
  result[0] = a[0] + b[0];
  result[1] = a[1] + b[1];
  return result;
};

Vec2.sub = function(a, b, result) {
  result = result || a;
  result[0] = a[0] - b[0];
  result[1] = a[1] - b[1];
  return result;
};

Vec2.mul = function(a, b, result) {
  result = result || a;
  result[0] = a[0] * b[0];
  result[1] = a[1] * b[1];
  return result;
};

Vec2.scal = function(a, scalar, result) {
  result = result || a;
  result[0] = a[0] * scalar;
  result[1] = a[1] * scalar;
  return result;
};

Vec2.inv = function(a, result) {
  result = result || a;
  result[0] = -a[0];
  result[1] = -a[1];
  return result;
};

Vec2.norm = function(a, result) {
  var len, x, y;
  result = result || a;
  x = a[0];
  y = a[1];
  len = 1 / sqrt(x * x + y * y);
  result[0] = x * len;
  result[1] = y * len;
  return result;
};

Vec2.lenSq = function(a) {
  return a[0] * a[0] + a[1] * a[1];
};

Vec2.len = function(a) {
  return sqrt(a[0] * a[0] + a[1] * a[1]);
};

Vec2.dot = function(a, b) {
  return a[0] * b[0] + a[1] * b[1];
};

Vec2.cross = function(a, b) {
  return a[0] * b[1] - a[1] * b[0];
};

Vec2.dist = function(a, b) {
  var x, y;
  x = b[0] - a[0];
  y = b[1] - a[1];
  return sqrt(x * x + y * y);
};

Vec2.distSq = function(a, b) {
  var x, y;
  x = b[0] - a[0];
  y = b[1] - a[1];
  return x * x + y * y;
};

Vec2.rad = function(a, b) {
  if (!b) {
    return Math.atan2(a[0], a[1]);
  }
  return Math.acos(Vec2.dot(Vec2.norm(a, Vec2.radCache[0]), Vec2.norm(b, Vec2.radCache[1])));
};

Vec2.rot = function(a, rad, result) {
  var cosA, sinA, x, y;
  result = result || a;
  sinA = Math.sin(rad);
  cosA = Math.cos(rad);
  x = a[0];
  y = a[1];
  result[0] = x * cosA - y * sinA;
  result[1] = x * sinA + y * cosA;
  return result;
};

Vec2.limit = function(a, max, result) {
  var len, ratio, x, y;
  result = result || a;
  x = a[0];
  y = a[1];
  len = sqrt(x * x + y * y);
  if (length > max) {
    ratio = max / length;
    result[0] = x * ratio;
    result[1] = y * ratio;
  } else if (result !== a) {
    result[0] = x;
    result[1] = y;
  }
  return result;
};

Math.TAU = Math.PI * 2;

Math.PIRAD = 0.0174532925;

Math.clamp = function(a, low, high) {
  if (a < low) {
    return low;
  }
  if (a > high) {
    return high;
  } else {
    return a;
  }
};

random = Math.random;

Math.randomFloat = function(low, high) {
  return low + random() * (high - low + 1);
};

Math.randomBool = function(chance) {
  return random() <= chance;
};

pow = Math.pow;

powIn = function(strength) {
  if (strength == null) {
    strength = 2;
  }
  return function(t) {
    return pow(t, strength);
  };
};

powOut = function(strength) {
  var fn;
  fn = powIn(strength);
  return function(t) {
    return 1 - fn(1 - t);
  };
};

powInOut = function(strength) {
  var fn;
  fn = powIn(strength);
  return function(t) {
    return (t < 0.5 ? fn(t * 2) : 2 - fn(2 * (1 - t))) / 2;
  };
};

_ref = ['quad', 'cubic', 'quart', 'quint'];
for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
  transition = _ref[i];
  Math[transition + 'In'] = powIn(i + 2);
  Math[transition + 'Out'] = powOut(i + 2);
  Math[transition + 'InOut'] = powInOut(i + 2);
}

Math.linear = function() {
  return t;
};
