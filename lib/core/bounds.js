// Generated by CoffeeScript 1.6.1
var Bounds, BoundsDebug, Color, Component, Pool, Vec2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Color = require('./color');

Vec2 = require('./math').Vec2;

Bounds = (function(_super) {

  __extends(Bounds, _super);

  Bounds.prototype.tag = 'bounds';

  Bounds.prototype.attributes = {
    shape: 'rect',
    radius: 0,
    size: Vec2()
  };

  function Bounds() {
    this.size = Vec2();
  }

  Bounds.prototype.instantiate = function(attributes) {
    Vec2.copy(this.size, attributes.size);
    this.shape = attributes.shape;
    this.radius = attributes.radius;
    return this;
  };

  Bounds.prototype.getTop = function() {
    if (this.shape === 'circle') {
      return this.transform.pos[1] - this.radius;
    }
    return this.transform.pos[1];
  };

  Bounds.prototype.getBottom = function() {
    if (this.shape === 'circle') {
      return this.transform.pos[1] + this.radius;
    }
    return this.transform.pos[1] + this.size[1];
  };

  Bounds.prototype.intersectLine = function(p1, p2) {
    return null;
  };

  Bounds.prototype.intersect = function(bound) {
    return null;
  };

  Bounds.prototype.contains = function(point) {
    var pos;
    pos = this.transform.pos;
    switch (this.shape) {
      case 'circle':
        return Bounds.circPoint(pos, this.radius, point);
      case 'rect':
        return Bounds.rectPoint(pos, this.size, point);
    }
    return false;
  };

  Bounds.prototype.withinRect = function(pos, size) {
    var mypos;
    mypos = this.transform.pos;
    switch (this.shape) {
      case 'circle':
        return Bounds.rectCirc(pos, size, mypos, this.radius);
      case 'rect':
        return Bounds.rectRect(pos, size, mypos, this.size);
    }
    return false;
  };

  return Bounds;

})(Component);

Bounds.circPoint = function(center, radius, point) {
  return Vec2.distSq(point, center) <= radius * radius;
};

Bounds.rectPoint = function(pos, size, point) {
  return pos[0] - size[0] < point[0] && pos[1] < point[1] && pos[0] + size[0] > point[0] && pos[1] + size[1] > point[1];
};

Bounds.rectCirc = function(topLeft, size, center, radius) {
  var circleDistanceX, circleDistanceY, cornerDistance;
  circleDistanceX = Math.abs(center[0] - topLeft[0] - size[0] / 2);
  circleDistanceY = Math.abs(center[1] - topLeft[1] - size[1] / 2);
  if (circleDistanceX > (size[0] / 2 + radius) || circleDistanceY > (size[1] / 2 + radius)) {
    return false;
  }
  if (circleDistanceX <= size[0] / 2 || circleDistanceY <= size[1] / 2) {
    return true;
  }
  cornerDistance = Math.pow(circleDistanceX - size[0] / 2, 2) + Math.pow(circleDistanceY - size[1] / 2, 2);
  return cornerDistance <= Math.pow(radius, 2);
};

Bounds.rectRect = function(pos, size, pos2, size2) {
  return !(pos[0] > pos2[0] + size2[0] || pos[0] + size[0] < pos2[0] || pos[1] > pos2[1] + size2[1] || pos[1] + size[1] < pos2[1]);
};

Bounds.lineRect = function(point1, point2, topLeft, size) {
  var botOverlap, bottomIntersection, bottomPoint, c, m, topIntersection, topOverlap, topPoint, _ref, _ref1;
  this.topLeft = topLeft;
  this.size = size;
  m = (y2 - y1) / (x2 - x1);
  c = y1(-(m * x1));
  if (m > 0) {
    topIntersection = m * rx + c;
    bottomIntersection = m * (rx + rw) + c;
  } else {
    topIntersection = m * (rx + rw) + c;
    bottomIntersection = m * rx + c;
  }
  if (y1 < y2) {
    topPoint = y1;
    bottomPoint = y2;
  } else {
    topPoint = y2;
    bottomPoint = y1;
  }
  topOverlap = (_ref = topIntersection > topPoint) != null ? _ref : {
    topIntersection: topPoint
  };
  botOverlap = (_ref1 = bottomIntersection < bottomPoint) != null ? _ref1 : {
    bottomIntersection: bottomPoint
  };
  return (topOverlap < botOverlap) && (!((botOverlap < ry) || (topOverlap > ry + rh)));
};

Bounds.lineCirc = function(point1, point2, center, radius) {
  var a, b, bb4ac, c, dx, dy, ix1, ix2, iy1, iy2, mu, testX, testY;
  dx = x2 - x1;
  dy = y2 - y1;
  a = dx * dx + dy * dy;
  b = 2 * (dx * (x1 - cx) + dy * (y1 - cy));
  c = cx * cx + cy * cy;
  c += x1 * x1 + y1 * y1;
  c -= 2 * (cx * x1 + cy * y1);
  c -= cr * cr;
  bb4ac = b * b - 4 * a * c;
  if (bb4ac < 0) {
    return false;
  }
  mu = (-b + sqrt(b * b - 4 * a * c)) / (2 * a);
  ix1 = x1 + mu * dx;
  iy1 = y1 + mu * dy;
  mu = (-b - sqrt(b * b - 4 * a * c)) / (2 * a);
  ix2 = x1 + mu * dx;
  iy2 = y1 + mu * dy;
  if (dist(x1, y1, cx, cy) < dist(x2, y2, cx, cy)) {
    testX = x2;
    testY = y2;
  } else {
    testX = x1;
    testY = y1;
  }
  if (dist(testX, testY, ix1, iy1) < dist(x1, y1, x2, y2) || dist(testX, testY, ix2, iy2) < dist(x1, y1, x2, y2)) {
    return true;
  }
  return false;
};

new Pool(Bounds);

BoundsDebug = (function(_super) {

  __extends(BoundsDebug, _super);

  BoundsDebug.prototype.tag = 'boundsDebug';

  BoundsDebug.prototype.attributes = {
    color: Color.gray,
    opacity: 0.5,
    fill: false
  };

  function BoundsDebug() {
    this.color = Vec2();
  }

  BoundsDebug.prototype.instantiate = function(attributes) {
    this.opacity = attributes.opacity, this.fill = attributes.fill;
    Vec2.copy(this.color, attributes.color);
    return this;
  };

  BoundsDebug.prototype.render = function(ctx) {
    var bounds, size;
    bounds = this.bounds;
    ctx.save();
    if (this.fill) {
      ctx.fillStyle = Color.rgba(this.color, this.opacity * 0.5);
    }
    ctx.strokeStyle = Color.rgba(this.color, this.opacity);
    ctx.lineWidth = 1;
    this.transform.applyMatrix(ctx);
    if (bounds.shape === 'circle') {
      ctx.beginPath();
      ctx.lineTo(0, bounds.radius);
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, bounds.radius | 0, 0, Math.TAU);
      if (this.fill) {
        ctx.fill();
      }
      ctx.stroke();
    } else {
      size = bounds.size;
      ctx.strokeRect(-size[0] / 2 | 0, -size[1] / 2 | 0, size[0] | 0, size[1] | 0);
      if (this.fill) {
        ctx.fillRect(-size[0] / 2 | 0, -size[1] / 2 | 0, size[0] | 0, size[1] | 0);
      }
    }
    ctx.restore();
    return this;
  };

  return BoundsDebug;

})(Component);

new Pool(BoundsDebug);

Bounds.Debug = BoundsDebug;

module.exports = Bounds;
