// Generated by CoffeeScript 1.6.1
var Pool, fn, _i, _len, _ref;

require('./math');

Pool = (function() {

  Pool.typedHooks = ['fixedUpdate', 'simulate', 'update', 'postUpdate', 'preRender', 'render'];

  Pool.regxHook = /^on[A-Z]/;

  Pool.regxGetter = /^get[A-Z]/;

  Pool.hooks = {};

  Pool.byTag = {};

  Pool.defaults = {};

  Pool.order = {
    render: false
  };

  Pool.prototype.toString = function() {
    return "Pool {@tag} [" + this.allocd + " / " + this.register.length + "]";
  };

  function Pool(cls) {
    var fn, key, keys, proto, types, _i, _j, _len, _len1,
      _this = this;
    this.cls = cls;
    proto = cls.prototype;
    proto.pool = this;
    cls.pool = this;
    this.register = [];
    this.subs = [];
    this.hooks = [];
    this.enabled = false;
    this.allocd = 0;
    this.tag = proto.tag;
    if (this.tag) {
      Pool.byTag[this.tag] = this;
    }
    this.isComponent = this.tag && this.tag !== 'entity';
    this.light = (!this.isComponent) || proto.light || false;
    this.layer = proto.layer || cls.layer || 0;
    if (this.isComponent) {
      if (!this.light) {
        types = Pool.typedHooks;
        keys = Object.keys(proto).concat(Object.keys(cls));
        for (_i = 0, _len = keys.length; _i < _len; _i++) {
          fn = keys[_i];
          if (Pool.regxHook.test(fn)) {
            if (!~types.indexOf(fn)) {
              types.push(fn);
              Pool.hooks[fn] = [];
            }
            this.subs.push(fn);
          } else if (Pool.regxGetter.test(fn)) {
            key = fn.substr(3, 1).toLowerCase() + fn.substr(4);
            Pool.defineGetter(proto, key, fn);
          }
        }
        for (_j = 0, _len1 = types.length; _j < _len1; _j++) {
          fn = types[_j];
          if (fn in cls) {
            this[fn] = cls[fn];
            Pool.hooks[fn].push(this);
          } else if (fn in proto) {
            this.hooks.push(fn);
          }
        }
      }
    }
    cls.alloc = function(parent, attributes) {
      return _this.alloc(parent, attributes);
    };
  }

  Pool.prototype.preinstantiate = function(i) {
    while (i--) {
      this.instantiate();
    }
    return this;
  };

  Pool.prototype.instantiate = function() {
    var cls, hook, _i, _len, _ref;
    cls = new this.cls();
    this.register.push(cls);
    _ref = this.hooks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      hook = _ref[_i];
      Pool.hooks[hook].push(cls);
    }
    return cls;
  };

  Pool.prototype.alloc = function(parent, attributes) {
    var defaults, entity, hook, i, key, register, topic, uid, _i, _j, _len, _len1, _ref, _ref1;
    register = this.register;
    i = register.length;
    while (i--) {
      if (!register[i].allocd) {
        entity = register[i];
        break;
      }
    }
    if (!entity) {
      entity = this.instantiate();
    }
    this.allocd++;
    this.enabled = true;
    entity.uid = uid = Math.uid();
    entity.enabled = true;
    entity.allocd = true;
    entity.parent = parent || null;
    entity.root = parent && parent.root || parent || entity;
    if (this.isComponent) {
      _ref = this.hooks;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        hook = _ref[_i];
        if (Pool.order[hook] != null) {
          Pool.order[hook] = true;
        }
      }
      entity.layer = (parent && parent.layer || 0) + this.layer + 2 - 1 / uid;
      if ((defaults = entity.attributes)) {
        if (attributes && !attributes._merged) {
          if (attributes.__proto__) {
            attributes.__proto__ = defaults;
          } else {
            for (key in defaults) {
              if (!key in attributes) {
                attributes[key] = defaults[key];
              }
            }
          }
          attributes._merged = true;
        }
      }
      _ref1 = this.subs;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        topic = _ref1[_j];
        parent.sub(entity, topic);
      }
    }
    entity.alloc(attributes || defaults || null);
    return entity;
  };

  Pool.prototype.destroy = function(entity) {
    entity.enabled = false;
    Pool.hooks.free.push(entity);
    return this;
  };

  Pool.prototype.free = function(entity) {
    entity.allocd = false;
    entity.uid = null;
    entity.root = null;
    entity.parent = null;
    this.enabled = this.allocd-- > 1;
    return this;
  };

  Pool.prototype.invoke = function(fn, a0, a1, a2, a3) {
    var i, stack;
    stack = this.register;
    i = this.register.length;
    while (i--) {
      if (stack[i].enabled) {
        stack[i][fn](a0, a1, a2, a3);
      }
    }
    return this;
  };

  return Pool;

})();

Pool.hooks.free = [];

_ref = Pool.typedHooks;
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
  fn = _ref[_i];
  Pool.hooks[fn] = [];
}

Pool.dump = function(flush) {
  var pool, tag, _ref1;
  _ref1 = Pool.byTag;
  for (tag in _ref1) {
    pool = _ref1[tag];
    console.log("%s: %d/%d allocd", tag, pool.allocd, pool.register.length);
  }
  if (flush) {
    Pool.flush();
  }
  return null;
};

Pool.defineGetter = function(proto, key, fn) {
  Object.defineProperty(proto, key, {
    get: proto[fn],
    enumerable: true,
    configurable: true
  });
  return proto;
};

Pool.free = function() {
  var item, stack, _j, _len1;
  stack = this.hooks.free;
  for (_j = 0, _len1 = stack.length; _j < _len1; _j++) {
    item = stack[_j];
    item.free();
  }
  stack.length = 0;
  return this;
};

Pool.flush = function() {
  var freed, i, pool, register, tag, _ref1;
  _ref1 = Pool.byTag;
  for (tag in _ref1) {
    pool = _ref1[tag];
    register = pool.register;
    i = register.length;
    freed = 0;
    while (i--) {
      if (!(!register[i].allocd)) {
        continue;
      }
      register.splice(i, 1);
      freed++;
    }
    console.log("%s: %d/%d flushed", tag, freed, pool.register.length);
  }
  return this;
};

Pool.invoke = function(fn, a0, a1, a2, a3) {
  var i = 0, stack;
  if ((stack = this.hooks[fn]) && (i = stack.length)) {
    if (Pool.order[fn]) {
      stack.sort(Pool.orderFn);
      Pool.order[fn] = false;
    }
    while (i-- > 0) {
      if (stack[i].enabled) {
        stack[i][fn](a0, a1, a2, a3);
      }
    }
  }
  return this;
};

Pool.orderFn = function(a, b) {
  return b.layer - a.layer;
};

module.exports = Pool;
