// Generated by CoffeeScript 1.5.0
var Composite, Engine, Pool, Vec2, engine, perf, requestAnimationFrame,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Composite = require('./composite');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
  return setTimeout(callback, 20);
};

perf = window.performance || {};

perf.now = perf.now || perf.webkitNow || perf.msNow || perf.mozNow || Date.now;

Engine = (function(_super) {

  __extends(Engine, _super);

  function Engine() {
    Engine.__super__.constructor.apply(this, arguments);
  }

  Engine.prototype.type = 'engine';

  Engine.prototype.init = function(element) {
    var Input,
      _this = this;
    this.element = element;
    this.time = 0.0;
    this.frame = 0;
    this.tail = 0.0;
    this.debug = {
      step: false,
      fps: false,
      fpsLength: 0,
      fpsSum: 0,
      mspf: true,
      mspfLength: 0,
      mspfSum: 0,
      stats: false,
      profile: 0
    };
    this.fdt = 1 / 60;
    this.dtCap = 0.5;
    this.fdtCap = this.fdt * 5;
    this.scale = 1;
    this.fps = 0;
    this.mspf = 0;
    Input = require('./input');
    Input.alloc(this);
    return this.tickBound = function(now) {
      return _this.tick(now);
    };
  };

  Engine.prototype.play = function(scene) {
    this.scene = scene;
    this.input.root = this.scene;
    if (this.debug.stats) {
      this.startStats();
    }
    if (!this.running) {
      return this.start();
    }
  };

  Engine.prototype.start = function() {
    this.running = true;
    requestAnimationFrame(this.tickBound);
    return this;
  };

  Engine.prototype.tick = function(now) {
    var debug, dt, mspfStart;
    now = (now && now < 1e12 ? now : perf.now()) / 1000;
    debug = this.debug;
    if (this.lastTime) {
      if ((dt = now - this.lastTime) > 0.5) {
        dt = this.fdt;
      } else if (dt > 0.01) {
        if (debug.fpsSum > 0.333) {
          this.fps = debug.fpsLength / debug.fpsSum;
          debug.fpsLength = 0;
          debug.fpsSum = 0;
        }
        debug.fpsSum += dt;
        debug.fpsLength++;
      }
      this.dt = (dt *= this.scale);
      this.time += dt;
      this.frame++;
      if (debug._stats) {
        debug._stats.begin();
      }
      if (debug.mspf) {
        mspfStart = perf.now();
      }
      if (debug.profile && !debug.profileFrom) {
        debug.profileFrom = debug.profile;
        console.profile("Frame " + debug.profileFrom);
      }
      this.update(dt);
      if (debug.profileFrom) {
        if (!--debug.profile) {
          console.profileEnd("Frame " + debug.profileFrom);
          debug.profileFrom = 0;
        }
      }
      if (debug.step) {
        debugger;
      }
      if (debug.mspf) {
        if (debug.mspfSum > 100) {
          this.mspf = debug.mspfSum / debug.mspfLength;
          debug.mspfLength = 0;
          debug.mspfSum = 0;
        }
        debug.mspfSum += perf.now() - mspfStart;
        debug.mspfLength++;
      }
      if (debug._stats) {
        debug._stats.end();
      }
    } else {
      this.time = now;
    }
    this.lastTime = now;
    if (this.running) {
      requestAnimationFrame(this.tickBound);
    }
    return this;
  };

  Engine.prototype.update = function(dt) {
    var ctx, fdt, fps, mspf, tail;
    ctx = this.renderer.save();
    tail = Math.min(this.tail + dt, this.fdtCap * this.scale);
    fdt = this.fdt;
    while (tail > fdt) {
      tail -= fdt;
      Pool.invoke('fixedUpdate', fdt);
      Pool.invoke('simulate', fdt);
    }
    this.tail = tail;
    Pool.invoke('update', dt);
    Pool.invoke('lateUpdate', dt);
    Pool.invoke('render', ctx, dt);
    if (this.debug.fps && this.fps < 55) {
      fps = Math.round(this.fps);
      ctx.fillStyle = 'black';
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 2;
      ctx.strokeText(fps, 2, 11);
      ctx.fillText(fps, 2, 11);
    }
    if (this.debug.mspf) {
      mspf = Math.round(this.mspf);
      ctx.fillStyle = 'black';
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 2;
      ctx.strokeText(mspf, 2, 11);
      ctx.fillText(mspf, 2, 11);
    }
    return this.renderer.restore();
  };

  Engine.prototype.startStats = function() {
    var el, stats;
    if (this.debug._stats || !window.Stats) {
      return;
    }
    this.debug._stats = stats = new Stats();
    el = stats.domElement;
    el.style.position = 'absolute';
    el.style.left = 0;
    el.style.top = 0;
    document.body.appendChild(el);
    return this;
  };

  return Engine;

})(Composite);

engine = new Engine();

if ('console' in window) {
  window.mgame = console.m = {
    pool: Pool.dump,
    profile: function(frames) {
      if (frames == null) {
        frames = 1;
      }
      engine.debug.profile = frames;
      return null;
    },
    step: function() {
      engine.debug.step = !engine.debug.step;
      return null;
    }
  };
}

module.exports = engine;
