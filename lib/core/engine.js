// Generated by CoffeeScript 1.6.1
var Engine, Entity, Pool, Vec2, engine, perf, requestAnimationFrame,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Entity = require('./entity');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
  return setTimeout(callback, 20);
};

perf = window.performance || {};

perf.now = perf.now || perf.webkitNow || perf.msNow || perf.mozNow || Date.now;

Engine = (function(_super) {

  __extends(Engine, _super);

  function Engine() {
    return Engine.__super__.constructor.apply(this, arguments);
  }

  Engine.prototype.tag = 'engine';

  Engine.prototype.init = function(element) {
    var Console, Input,
      _this = this;
    this.element = element;
    this.time = 0.0;
    this.lastTime = 0.0;
    this.frame = 0;
    this.tail = 0.0;
    this.debug = {
      profile: 0,
      step: false,
      time: true
    };
    this.samples = {
      dt: 0,
      lag: 0,
      tick: 0,
      fixedUpdate: 0,
      update: 0,
      render: 0
    };
    this.fdt = 1 / 30;
    this.dtMin = 1 / 60;
    this.dtCap = 0.5;
    this.fdtCap = this.fdt * 5;
    this.scale = 1;
    Console = require('./console');
    Console.alloc(this);
    Input = require('./input');
    Input.alloc(this);
    return this.tickBound = function(now) {
      return _this.tick(now);
    };
  };

  Engine.prototype.play = function(scene) {
    this.scene = scene;
    return this.start();
  };

  Engine.prototype.start = function() {
    if (!this.running) {
      this.running = true;
      requestAnimationFrame(this.tickBound);
    }
    return this;
  };

  Engine.prototype.tick = function(time) {
    var ctx, debug, dt, fdt, lag, ping, pingTick, pong, samples, tail;
    this.time = time = (time && time < 1e12 ? time : perf.now()) / 1000;
    debug = this.debug, samples = this.samples, fdt = this.fdt;
    if (this.lastTime) {
      if ((dt = time - this.lastTime) > this.dtCap) {
        dt = this.dtMin;
      } else if (dt > 0.01) {
        samples.dt = dt;
        if ((lag = time - samples.next) > 0) {
          samples.lag = lag * 1000;
        }
      }
      this.dt = (dt *= this.scale);
      this.frame++;
      if (debug.profile && !debug.profileFrom) {
        debug.profileFrom = debug.profile;
        console.profile("Frame " + debug.profileFrom);
      }
      pingTick = ping = perf.now();
      tail = Math.min(this.tail + dt, this.fdtCap * this.scale);
      while (tail > fdt) {
        tail -= fdt;
        Pool.invoke('fixedUpdate', fdt);
        Pool.invoke('simulate', fdt);
      }
      this.tail = tail;
      pong = perf.now();
      samples.fixedUpdate = pong - ping;
      ping = pong;
      Pool.invoke('update', dt);
      Pool.free();
      Pool.invoke('postUpdate', dt);
      pong = perf.now();
      samples.update = pong - ping;
      ping = pong;
      Pool.invoke('preRender', dt);
      ctx = this.renderer.save();
      Pool.invoke('render', ctx, dt);
      this.renderer.restore();
      pong = perf.now();
      samples.render = pong - ping;
      samples.tick = pong - pingTick;
      if (debug.step) {
        debugger;
      }
      if (debug.profileFrom) {
        if (!--debug.profile) {
          console.profileEnd("Frame " + debug.profileFrom);
          debug.profileFrom = 0;
        }
      }
    }
    this.lastTime = time;
    samples.next = Math.max(time + 1 / 60, perf.now() / 1000);
    this.pub('onTimeEnd', samples);
    if (this.pauseNext) {
      this.pub('onPause');
      this.paused = true;
      this.tickBound(samples.next * 1000);
    } else if (this.running) {
      requestAnimationFrame(this.tickBound);
    }
    return this;
  };

  return Engine;

})(Entity);

engine = new Engine();

if ('console' in window) {
  console.m = {
    pool: function(flush) {
      Pool.dump(flush);
      return null;
    },
    profile: function(frames) {
      if (frames == null) {
        frames = 60;
      }
      engine.debug.profile = frames;
      return null;
    },
    step: function() {
      engine.debug.step = !engine.debug.step;
      return null;
    }
  };
}

module.exports = engine;
