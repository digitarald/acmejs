// Generated by CoffeeScript 1.6.1
var Boid, Component, Kinetic, Pool, Vec2, avoidance, cohesion, imitation, impulse, stretch,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

Kinetic = require('./kinetic');

Boid = (function(_super) {

  __extends(Boid, _super);

  Boid.prototype.tag = 'boid';

  Boid.prototype.attributes = {
    perception: 100,
    aura: 25
  };

  function Boid() {
    this.mod = 2;
    this.cohesionMod = 1;
    this.avoidanceMod = 2;
    this.imitationMod = 1;
  }

  Boid.prototype.instantiate = function(attributes) {
    this.perception = attributes.perception, this.aura = attributes.aura;
    if (!this.aura && this.bounds) {
      this.aura = this.bounds.radius * 1.5;
    }
    this.perceptionSq = this.perception * this.perception;
    this.auraSq = this.aura * this.aura;
    return this;
  };

  return Boid;

})(Component);

cohesion = Vec2();

avoidance = Vec2();

imitation = Vec2();

stretch = Vec2();

impulse = Vec2();

Boid.fixedUpdate = function(dt) {
  var avoidanceCount, boid1, boid2, boids, cohesionCount, diffSq, entity1, entity2, i, imitationCount, j, len, mod, pos1, pos2, vel;
  boids = this.register;
  i = len = boids.length;
  while (i--) {
    boid1 = boids[i];
    if (!boid1.enabled) {
      continue;
    }
    avoidanceCount = imitationCount = cohesionCount = 0;
    entity1 = boid1.entity;
    pos1 = entity1.transform.pos;
    vel = entity1.kinetic.velocity;
    Vec2.set(impulse);
    j = len;
    while (j--) {
      boid2 = boids[j];
      if (!boid2.enabled || boid1 === boid2) {
        continue;
      }
      entity2 = boid2.entity;
      pos2 = entity2.transform.pos;
      diffSq = Vec2.distSq(pos1, pos2);
      if (diffSq < boid1.perceptionSq && diffSq) {
        Vec2.sub(pos2, pos1, stretch);
        Vec2.scal(stretch, Math.sqrt(entity1.kinetic.mass / entity2.kinetic.mass));
        if (!cohesionCount++) {
          Vec2.copy(cohesion, stretch);
        } else {
          Vec2.add(cohesion, stretch);
        }
        if (!imitationCount++) {
          Vec2.copy(imitation, entity2.kinetic.velocity);
        } else {
          Vec2.add(imitation, entity2.kinetic.velocity);
        }
        if (diffSq < boid1.auraSq) {
          if (!avoidanceCount++) {
            Vec2.copy(avoidance, stretch);
          } else {
            Vec2.add(avoidance, stretch);
          }
        }
      }
    }
    mod = boid1.mod;
    if (cohesionCount && boid1.cohesionMod) {
      if (cohesionCount > 1) {
        Vec2.scal(cohesion, 1 / cohesionCount);
      }
      Vec2.add(entity1.kinetic.force, Vec2.scal(cohesion, boid1.cohesionMod * mod));
    }
    if (imitationCount && boid1.imitationMod) {
      if (imitationCount > 1) {
        Vec2.scal(imitation, 1 / imitationCount);
      }
      Vec2.add(impulse, Vec2.scal(imitation, boid1.imitationMod * mod));
      Vec2.add(entity1.kinetic.force, Vec2.sub(impulse, vel));
    }
    if (avoidanceCount && boid1.avoidanceMod) {
      if (avoidanceCount > 1) {
        Vec2.scal(avoidance, 1 / avoidanceCount);
      }
      Vec2.sub(entity1.kinetic.force, Vec2.scal(avoidance, boid1.avoidanceMod * mod));
    }
  }
  return this;
};

Boid.explode = function() {
  var comp, _i, _len, _ref;
  _ref = Boid.pool.register;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    comp = _ref[_i];
    if (comp.enabled) {
      comp.entity.explode();
    }
  }
  return this;
};

new Pool(Boid);

module.exports = Boid;
