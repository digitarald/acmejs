// Generated by CoffeeScript 1.5.0
var Collider, Component, Engine, Pool, Vec2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

Engine = require('./engine');

Collider = (function(_super) {

  __extends(Collider, _super);

  function Collider() {
    Collider.__super__.constructor.apply(this, arguments);
  }

  Collider.prototype.type = 'collider';

  Collider.prototype.presets = {
    trigger: false
  };

  Collider.prototype.reset = function(presets) {
    this.trigger = presets.trigger;
    return this;
  };

  return Collider;

})(Component);

Collider.simulate = function(dt) {
  var collider1, collider2, colliders, diff, diffSq, i, j, kinetic1, kinetic2, mass1, mass2, n, p, parent1, parent2, pos1, pos2, radius1, radius2, radiusSum, vel1, vel2, vn1, vn2, vp1, vp1After, vp2, vp2After;
  colliders = this.roster;
  i = colliders.length;
  while (i--) {
    collider1 = colliders[i];
    if (!collider1.enabled) {
      continue;
    }
    j = i;
    while (j--) {
      collider2 = colliders[j];
      kinetic1 = collider1.kinetic;
      kinetic2 = collider2.kinetic;
      if (!collider2.enabled || (kinetic1.sleeping && kinetic2.sleeping)) {
        continue;
      }
      parent1 = collider1.parent;
      parent2 = collider2.parent;
      radius1 = parent1.radius || parent1.bounds.radius;
      radius2 = parent2.radius || parent2.bounds.radius;
      pos1 = parent1.transform.pos;
      pos2 = parent2.transform.pos;
      radiusSum = radius1 + radius2;
      diffSq = Vec2.distSq(pos1, pos2);
      if (diffSq > radiusSum * radiusSum) {
        continue;
      }
      p = Vec2.norm(Vec2.sub(pos1, pos2, Vec2.cache[0]));
      diff = Math.sqrt(diffSq);
      if (collider1.trigger || collider2.trigger) {
        parent1.pub('onTrigger', parent2, p, diff);
        parent2.pub('onTrigger', parent1, p, diff);
        continue;
      }
      diff -= radiusSum;
      vel1 = kinetic1.vel;
      vel2 = kinetic2.vel;
      mass1 = kinetic1.mass || 1;
      mass2 = kinetic2.mass || 1;
      if (diff < 0) {
        Vec2.add(pos1, Vec2.scal(p, -diff * 2 * radius1 / radiusSum, Vec2.cache[1]));
        Vec2.add(pos2, Vec2.scal(p, diff * 2 * radius2 / radiusSum, Vec2.cache[1]));
      }
      n = Vec2.perp(p, Vec2.cache[1]);
      vp1 = Vec2.dot(vel1, p);
      vn1 = Vec2.dot(vel1, n);
      vp2 = Vec2.dot(vel2, p);
      vn2 = Vec2.dot(vel2, n);
      vp1After = (mass1 * vp1 + mass2 * (2 * vp2 - vp1)) / (mass1 + mass2);
      vp2After = (mass1 * (2 * vp1 - vp2) + mass2 * vp2) / (mass1 + mass2);
      Vec2.add(Vec2.scal(p, vp1After, Vec2.cache[2]), Vec2.scal(n, vn1, Vec2.cache[3]), vel1);
      Vec2.add(Vec2.scal(p, vp2After, Vec2.cache[2]), Vec2.scal(n, vn2, Vec2.cache[3]), vel2);
      parent1.pub('onCollide', parent2, n);
      parent2.pub('onCollide', parent1, n);
    }
  }
  return this;
};

new Pool(Collider);

module.exports = Collider;
