// Generated by CoffeeScript 1.6.1
var Collider, Component, Engine, Pool, Vec2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

Engine = require('./engine');

Collider = (function(_super) {

  __extends(Collider, _super);

  function Collider() {
    return Collider.__super__.constructor.apply(this, arguments);
  }

  Collider.prototype.tag = 'collider';

  Collider.prototype.attributes = {
    trigger: false,
    include: null,
    exclude: null
  };

  Collider.prototype.instantiate = function(attributes) {
    this.trigger = attributes.trigger, this.include = attributes.include, this.exclude = attributes.exclude;
    return this;
  };

  return Collider;

})(Component);

Collider.simulate = function(dt) {
  var collider1, collider2, colliders, diff, diffSq, entity1, entity2, i, j, kinetic1, kinetic2, mass1, mass2, n, p, pos1, pos2, radius1, radius2, radiusSum, vel1, vel2, vn1, vn2, vp1, vp1After, vp2, vp2After;
  colliders = this.register;
  i = colliders.length;
  while (i--) {
    collider1 = colliders[i];
    if (!collider1.enabled) {
      continue;
    }
    j = i;
    while (j-- && collider1.enabled) {
      collider2 = colliders[j];
      kinetic1 = collider1.kinetic;
      kinetic2 = collider2.kinetic;
      entity1 = collider1.entity;
      entity2 = collider2.entity;
      if (!collider2.enabled || (kinetic1.sleeping && kinetic2.sleeping) || (collider1.include && !collider2[collider1.include]) || (collider2.include && !collider1[collider2.include]) || (collider1.exclude && collider2[collider1.exclude]) || (collider2.exclude && collider1[collider2.exclude])) {
        continue;
      }
      radius1 = entity1.bounds.radius;
      radius2 = entity2.bounds.radius;
      pos1 = entity1.transform.pos;
      pos2 = entity2.transform.pos;
      radiusSum = radius1 + radius2;
      diffSq = Vec2.distSq(pos1, pos2);
      if (diffSq > radiusSum * radiusSum) {
        continue;
      }
      p = Vec2.norm(Vec2.sub(pos1, pos2, Vec2.cache[0]));
      diff = Math.sqrt(diffSq);
      if (collider1.trigger || collider2.trigger) {
        entity1.pub('onTrigger', entity2, p, diff);
        entity2.pub('onTrigger', entity1, p, diff);
        continue;
      }
      diff -= radiusSum;
      vel1 = kinetic1.vel;
      vel2 = kinetic2.vel;
      mass1 = kinetic1.mass || 1;
      mass2 = kinetic2.mass || 1;
      if (diff < 0) {
        Vec2.add(pos1, Vec2.scal(p, -diff * 2 * radius1 / radiusSum, Vec2.cache[1]));
        Vec2.add(pos2, Vec2.scal(p, diff * 2 * radius2 / radiusSum, Vec2.cache[1]));
      }
      n = Vec2.perp(p, Vec2.cache[1]);
      vp1 = Vec2.dot(vel1, p);
      vn1 = Vec2.dot(vel1, n);
      vp2 = Vec2.dot(vel2, p);
      vn2 = Vec2.dot(vel2, n);
      vp1After = (mass1 * vp1 + mass2 * (2 * vp2 - vp1)) / (mass1 + mass2);
      vp2After = (mass1 * (2 * vp1 - vp2) + mass2 * vp2) / (mass1 + mass2);
      Vec2.add(Vec2.scal(p, vp1After, Vec2.cache[2]), Vec2.scal(n, vn1, Vec2.cache[3]), vel1);
      Vec2.add(Vec2.scal(p, vp2After, Vec2.cache[2]), Vec2.scal(n, vn2, Vec2.cache[3]), vel2);
      entity1.pub('onCollide', entity2, n);
      entity2.pub('onCollide', entity1, n);
    }
  }
  return this;
};

new Pool(Collider);

module.exports = Collider;
