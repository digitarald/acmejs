// Generated by CoffeeScript 1.5.0
var Mat, Vec2, abs, epsilon, fn, i, objCache, objVecCache, pow, powIn, radCache, random, sqrt, toInOut, toOut, transition, typedArray, _i, _len, _ref;

Mat = Math;

sqrt = Mat.sqrt, pow = Mat.pow, abs = Mat.abs, random = Mat.random;

Mat.epsilon = epsilon = 0.001;

Mat.TypedArray = typedArray = Float64Array || Float32Array || function(arr) {
  return arr;
};

Mat.Vec2 = Vec2 = function(fromOrX, y) {
  if (y != null) {
    return new typedArray([fromOrX, y]);
  }
  if (fromOrX != null) {
    return new typedArray(fromOrX);
  }
  return new typedArray(Vec2.zero);
};

Vec2.zero = Vec2.center = Vec2(0, 0);

Vec2.cache = [Vec2(), Vec2(), Vec2(), Vec2(), Vec2()];

Vec2.topLeft = Vec2(-1, -1);

Vec2.topCenter = Vec2(0, -1);

Vec2.topRight = Vec2(1, -1);

Vec2.centerLeft = Vec2(-1, 0);

Vec2.centerRight = Vec2(1, 0);

Vec2.bottomLeft = Vec2(-1, 1);

Vec2.bottomCenter = Vec2(0, 1);

Vec2.bottomRight = Vec2(1, 1);

radCache = [Vec2(), Vec2()];

objCache = {
  x: 0,
  y: 0
};

objVecCache = Vec2();

Vec2.set = function(result, x, y) {
  result[0] = x || 0;
  result[1] = y || 0;
  return result;
};

Vec2.copy = function(result, b) {
  result[0] = b[0];
  result[1] = b[1];
  return result;
};

Vec2.valid = function(a) {
  return !(isNaN(a[0]) || isNaN(a[1]));
};

Vec2.toString = function(a) {
  return "[" + a[0] + ", " + a[1] + "]";
};

Vec2.fromObj = function(obj, a) {
  a || (a = objVecCache);
  a[0] = obj.x;
  a[1] = obj.y;
  return a;
};

Vec2.toObj = function(a, obj) {
  obj || (obj = objCache);
  obj.x = a[0];
  obj.y = a[1];
  return obj;
};

Vec2.eq = function(a, b) {
  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
};

Vec2.add = function(a, b, result) {
  result || (result = a);
  result[0] = a[0] + b[0];
  result[1] = a[1] + b[1];
  return result;
};

Vec2.sub = function(a, b, result) {
  result || (result = a);
  result[0] = a[0] - b[0];
  result[1] = a[1] - b[1];
  return result;
};

Vec2.mul = function(a, b, result) {
  result || (result = a);
  result[0] = a[0] * b[0];
  result[1] = a[1] * b[1];
  return result;
};

Vec2.scal = function(a, scalar, result) {
  result || (result = a);
  result[0] = a[0] * scalar;
  result[1] = a[1] * scalar;
  return result;
};

Vec2.norm = function(a, result, scalar) {
  var len, x, y;
  if (scalar == null) {
    scalar = 1;
  }
  result || (result = a);
  x = a[0];
  y = a[1];
  len = scalar / (sqrt(x * x + y * y) || 1);
  result[0] = x * len;
  result[1] = y * len;
  return result;
};

Vec2.lenSq = function(a) {
  return a[0] * a[0] + a[1] * a[1];
};

Vec2.len = function(a) {
  return sqrt(a[0] * a[0] + a[1] * a[1]);
};

Vec2.dot = function(a, b) {
  return a[0] * b[0] + a[1] * b[1];
};

Vec2.cross = function(a, b) {
  return a[0] * b[1] - a[1] * b[0];
};

Vec2.lerp = function(a, b, scalar, result) {
  result || (result = a);
  result[0] = a[0] + scalar * (b[0] - a[0]);
  result[1] = a[1] + scalar * (b[1] - a[1]);
  return result;
};

Vec2.max = function(a, b, axis) {
  if (axis != null) {
    if (a[axis] > b[axis]) {
      return a;
    } else {
      return b;
    }
  }
  if (Vec2.lenSq(a) > Vec2.lenSq(b)) {
    return a;
  } else {
    return b;
  }
};

Vec2.perp = function(a, result) {
  var x;
  result || (result = a);
  x = a[0];
  result[0] = a[1];
  result[1] = -x;
  return result;
};

Vec2.dist = function(a, b) {
  var x, y;
  x = b[0] - a[0];
  y = b[1] - a[1];
  return sqrt(x * x + y * y);
};

Vec2.distSq = function(a, b) {
  var x, y;
  x = b[0] - a[0];
  y = b[1] - a[1];
  return x * x + y * y;
};

Vec2.limit = function(a, max, result) {
  var ratio, x, y;
  result || (result = a);
  x = a[0];
  y = a[1];
  if ((ratio = max / sqrt(x * x + y * y)) < 1) {
    result[0] = x * ratio;
    result[1] = y * ratio;
  } else if (result !== a) {
    result[0] = x;
    result[1] = y;
  }
  return result;
};

Vec2.rad = function(a, b) {
  if (!b) {
    return Mat.atan2(a[1], a[0]);
  }
  return Mat.acos(Vec2.dot(Vec2.norm(a, radCache[0]), Vec2.norm(b, radCache[1])));
};

Vec2.rot = function(a, theta, result) {
  var cosA, sinA, x, y;
  result || (result = a);
  sinA = Mat.sin(theta);
  cosA = Mat.cos(theta);
  x = a[0];
  y = a[1];
  result[0] = x * cosA - y * sinA;
  result[1] = x * sinA + y * cosA;
  return result;
};

Vec2.rotAxis = function(a, b, theta, result) {
  return Vec2.add(Vec2.rot(Vec2.sub(a, b, result || a), theta), b);
};

Vec2.lookAt = function(a, b, result) {
  var len;
  len = Vec2.len(a);
  return Vec2.norm(Vec2.rot(a, Mat.atan2(b[0] - a[0], b[1] - a[1]) - Mat.atan2(a[1], a[0]), result || a), null, len);
};

random = Mat.random, pow = Mat.pow;

Mat.TAU = Mat.PI * 2;

Mat.UID = 1;

Mat.uid = function() {
  return Mat.UID++;
};

Mat.clamp = function(a, low, high) {
  if (a < low) {
    return low;
  }
  if (a > high) {
    return high;
  } else {
    return a;
  }
};

Mat.rand = function(low, high, ease) {
  return (ease || Mat.linear)(random()) * (high - low) + low;
};

Mat.randArray = function(array) {
  return array[random() * array.length | 0];
};

Mat.chance = function(chance) {
  return random() <= chance;
};

powIn = function(strength) {
  if (strength == null) {
    strength = 2;
  }
  return function(t) {
    return pow(t, strength);
  };
};

toOut = function(fn) {
  return function(t) {
    return 1 - fn(1 - t);
  };
};

toInOut = function(fn) {
  return function(t) {
    return (t < 0.5 ? fn(t * 2) : 2 - fn(2 * (1 - t))) / 2;
  };
};

Mat.linear = function(t) {
  return t;
};

_ref = ['quad', 'cubic', 'quart', 'quint'];
for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
  transition = _ref[i];
  Mat[transition + 'In'] = fn = powIn(i + 2);
  Mat[transition + 'Out'] = toOut(fn);
  Mat[transition + 'InOut'] = toInOut(fn);
}

module.exports.Vec2 = Vec2;
