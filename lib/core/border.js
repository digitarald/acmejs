// Generated by CoffeeScript 1.6.1
var Border, Component, Engine, Pool, Vec2, pos,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

Engine = require('./engine');

Border = (function(_super) {

  __extends(Border, _super);

  function Border() {
    return Border.__super__.constructor.apply(this, arguments);
  }

  Border.prototype.type = 'border';

  Border.prototype.presets = {
    mode: 'bounce',
    restitution: 1
  };

  Border.prototype.reset = function(presets) {
    this.mode = presets.mode, this.restitution = presets.restitution;
    return this;
  };

  return Border;

})(Component);

pos = Vec2();

Border.simulate = function(dt) {
  var border, bounce, diff, hit, horizontal, kinetic, mirror, mode, parent, radius, restitution, size, vel, vertical, viewport, _i, _len, _ref;
  size = Engine.renderer.content;
  viewport = Engine.renderer.pos;
  horizontal = Vec2.set(Vec2.cache[0], viewport[0], viewport[0] + size[0]);
  vertical = Vec2.set(Vec2.cache[1], viewport[1], viewport[1] + size[1]);
  _ref = this.roster;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    border = _ref[_i];
    if (!border.enabled) {
      continue;
    }
    parent = border.parent, restitution = border.restitution, mode = border.mode, kinetic = border.kinetic;
    vel = null;
    if (kinetic) {
      if (!kinetic.enabled || kinetic.sleeping) {
        continue;
      }
      vel = kinetic.vel;
    }
    mirror = mode === 'mirror';
    bounce = mode === 'bounce' && vel;
    Vec2.copy(pos, parent.transform.pos);
    radius = parent.bounds.radius;
    if (mirror) {
      radius *= -1;
    }
    hit = 0;
    if ((diff = pos[0] - radius - horizontal[0]) < 0) {
      if (mirror) {
        pos[0] = horizontal[1] - radius;
      } else {
        pos[0] -= diff;
        if (bounce) {
          vel[0] *= -restitution;
        }
      }
      hit = -1;
    } else {
      diff = pos[0] + radius - horizontal[1];
      if (diff > 0) {
        if (mirror) {
          pos[0] = radius;
        } else {
          pos[0] -= diff;
          if (bounce) {
            vel[0] *= -restitution;
          }
        }
        hit = -1;
      }
    }
    if ((diff = pos[1] - radius - vertical[0]) < 0) {
      if (mirror) {
        pos[1] = vertical[1] - radius;
      } else {
        pos[1] -= diff;
        if (bounce) {
          vel[1] *= -restitution;
        }
      }
      hit = 1;
    } else {
      diff = pos[1] + radius - vertical[1];
      if (diff > 0) {
        if (mirror) {
          pos[1] = radius;
        } else {
          pos[1] -= diff;
          if (bounce) {
            vel[1] *= -restitution;
          }
        }
        hit = 1;
      }
    }
    if (hit != null) {
      parent.transform.setTransform(pos);
      parent.pub('onBorder', hit);
      if (border.mode === 'kill') {
        parent.free();
      }
    }
  }
  return this;
};

new Pool(Border);

module.exports = Border;
