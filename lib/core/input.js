// Generated by CoffeeScript 1.6.1
var Component, Engine, Input, Pool, Vec2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

Engine = require('./engine');

Input = (function(_super) {

  __extends(Input, _super);

  Input.prototype.tag = 'input';

  Input.prototype.support = {
    touch: 'ontouchstart' in window,
    orientation: 'ondeviceorientation' in window
  };

  function Input() {
    var code, key, type, _ref;
    this.queue = [];
    this.locks = {};
    this.pos = Vec2();
    this.prevPos = Vec2();
    this.touchState = null;
    this.axis = Vec2();
    this.mouseAxis = Vec2();
    this.orientation = Vec2();
    this.prevOrientation = Vec2();
    this.baseOrientation = Vec2();
    this.map = {
      32: 'space',
      192: 'debug',
      38: 'up',
      87: 'up',
      39: 'right',
      68: 'right',
      40: 'bottom',
      83: 'bottom',
      37: 'left',
      65: 'left',
      219: 'squareLeft',
      221: 'squareRight'
    };
    this.axisMap = {
      left: Vec2(0, -1),
      right: Vec2(0, 1),
      up: Vec2(1, -1),
      bottom: Vec2(1, 1)
    };
    this.keyNames = [];
    this.keys = {};
    _ref = this.map;
    for (code in _ref) {
      key = _ref[code];
      if (!~this.keyNames.indexOf(key)) {
        this.keyNames.push(key);
        this.keys[key] = null;
      }
    }
    this.throttled = {
      mousemove: true,
      deviceorientation: true
    };
    this.lastEvent = null;
    this.events = this.support.touch ? {
      touchstart: 'startTouch',
      touchmove: 'moveTouch',
      touchend: 'endTouch',
      touchcancel: 'endTouch'
    } : {
      mousedown: 'startTouch',
      mousemove: 'moveTouch',
      mouseup: 'endTouch',
      keydown: 'keyStart',
      keyup: 'keyEnd'
    };
    this.events.blur = 'blur';
    for (type in this.events) {
      window.addEventListener(type, this, false);
    }
  }

  Input.prototype.handleEvent = function(event) {
    var type;
    if (event.metaKey) {
      return;
    }
    event.preventDefault();
    type = event.type;
    if (this.throttled[type] && this.lastEvent === type) {
      this.queue[this.queue.length - 1] = event;
    } else {
      this.lastEvent = type;
      this.queue.push(event);
    }
    return this;
  };

  Input.prototype.keyStart = function(event) {
    var key;
    if ((key = this.map[event.keyCode]) && !this.keys[key]) {
      if (!this.lock('key-' + key)) {
        return false;
      }
      this.keys[key] = 'began';
      this.updateAxis(key);
      Engine.pub('onKeyBegan', key);
    }
    return this;
  };

  Input.prototype.keyEnd = function(event) {
    var key;
    if (key = this.map[event.keyCode]) {
      if (!this.lock('key-' + key)) {
        return false;
      }
      this.keys[key] = 'ended';
      this.updateAxis(key, true);
      Engine.pub('onKeyEnded', key);
    }
    return this;
  };

  Input.prototype.startTouch = function(event) {
    if (!this.lock('touch')) {
      return false;
    }
    this.resolve(event);
    if (!this.touchState && !event.metaKey) {
      this.touchState = 'began';
      Engine.pub('onTouchBegan');
    }
    return this;
  };

  Input.prototype.moveTouch = function(event) {
    var state;
    state = this.touchState;
    if ((state === 'began' || state === 'ended') && !this.lock('touch')) {
      return false;
    }
    this.resolve(event);
    if (state && state !== 'ended' && state !== 'moved') {
      this.touchState = 'moved';
    }
    return this;
  };

  Input.prototype.endTouch = function(event) {
    if (!this.lock('touch')) {
      return false;
    }
    this.resolve(event);
    if (this.touchState && (!this.support.touch || !event.targetTouches.length)) {
      Engine.pub('onTouchEnded');
      this.touchState = 'ended';
    }
    return this;
  };

  Input.prototype.updateAxis = function(key, ended) {
    var axis;
    if ((axis = this.axisMap[key])) {
      if (ended) {
        this.axis[axis[0]] -= axis[1];
      } else {
        this.axis[axis[0]] += axis[1];
      }
    }
    return this;
  };

  Input.prototype.blur = function() {
    var key, keys, _i, _len, _ref;
    if (this.touchState && this.touchState !== 'ended') {
      this.touchState = 'ended';
    }
    keys = this.keys;
    _ref = this.keyNames;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      if (keys[key] && keys[key] !== 'ended') {
        keys[key] = 'ended';
        this.updateAxis(key, true);
      }
    }
    return this;
  };

  Input.prototype.calibrateOrientation = function() {
    this.baseOrientationTime = this.orientationTime;
    Vec2.copy(this.baseOrientation, this.orientation);
    Vec2.set(this.orientation);
    return this;
  };

  Input.prototype.deviceOrientation = function(event) {
    Vec2.copy(this.prevOrientation, this.orientation);
    Vec2.sub(Vec2.set(this.orientation, event.gamma | 0, event.beta | 0), this.baseOrientation);
    this.orientationTime = event.timeStamp / 1000;
    if (!this.baseOrientationTime) {
      this.calibrateOrientation();
    }
    return this;
  };

  Input.prototype.resolve = function(event) {
    var coords, renderer;
    coords = this.support.touch ? event.targetTouches[0] : event;
    if (coords) {
      this.prevTime = this.time;
      this.time = event.timeStamp / 1000;
      Vec2.copy(this.prevPos, this.pos);
      renderer = Engine.renderer;
      Vec2.set(this.pos, (coords.pageX - renderer.margin[0]) / renderer.scale | 0, (coords.pageY - renderer.margin[1]) / renderer.scale | 0);
    }
    return this;
  };

  Input.prototype.lock = function(key) {
    if (this.locks[key] === this.frame) {
      return false;
    }
    this.locks[key] = this.frame;
    return true;
  };

  Input.prototype.postUpdate = function() {
    var event, key, keys, queue, type, _i, _len, _ref;
    switch (this.touchState) {
      case 'began':
        this.touchState = 'stationary';
        break;
      case 'ended':
        this.touchState = null;
        break;
    }
    keys = this.keys;
    _ref = this.keyNames;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      switch (keys[key]) {
        case 'began':
          keys[key] = 'pressed';
          break;
        case 'ended':
          keys[key] = null;
          break;
      }
    }
    this.frame = Engine.frame;
    queue = this.queue;
    while ((event = queue[0])) {
      type = event.type;
      if (!this[this.events[type] || type](event)) {
        break;
      }
      queue.shift();
    }
    if (!queue.length) {
      this.lastEvent = null;
    }
    return this;
  };

  return Input;

})(Component);

new Pool(Input);

module.exports = Input;
