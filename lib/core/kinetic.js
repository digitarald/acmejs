// Generated by CoffeeScript 1.6.1
var Component, Kinetic, Pool, Vec2, cache, copyVel,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

cache = Vec2();

copyVel = Vec2();

Kinetic = (function(_super) {

  __extends(Kinetic, _super);

  Kinetic.prototype.tag = 'kinetic';

  Kinetic.gravity = null;

  Kinetic.prototype.attributes = {
    mass: 1,
    drag: 0.999,
    friction: 15,
    fixed: false,
    maxVelocity: 75,
    maxForce: 2000,
    force: Vec2(),
    continuous: Vec2(),
    velocity: Vec2(),
    sleepVelocity: 0,
    fast: false
  };

  function Kinetic() {
    this.velocity = Vec2();
    this.force = Vec2();
    this.continuous = Vec2();
  }

  Kinetic.prototype.instantiate = function(attributes) {
    this.mass = attributes.mass, this.drag = attributes.drag, this.friction = attributes.friction, this.fixed = attributes.fixed, this.maxVelocity = attributes.maxVelocity, this.maxForce = attributes.maxForce, this.fast = attributes.fast, this.sleepVelocity = attributes.sleepVelocity;
    Vec2.copy(this.velocity, attributes.velocity);
    Vec2.copy(this.force, attributes.force);
    Vec2.copy(this.continuous, attributes.continuous);
    this.sleeping = false;
    return this;
  };

  Kinetic.prototype.applyImpulse = function(impulse) {
    Vec2.add(this.force, this.mass !== 1 ? Vec2.scal(impulse, 1 / (this.mass || 1), cache) : impulse);
    return this;
  };

  Kinetic.prototype.applyForce = function(force) {
    Vec2.add(this.continuous, force);
    return this;
  };

  return Kinetic;

})(Component);

Kinetic.simulate = function(dt) {
  var epsilon, force, gravity, kinetic, sleepVelocity, velocity, _i, _len, _ref;
  epsilon = Math.epsilon;
  _ref = this.register;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    kinetic = _ref[_i];
    if (!(kinetic.enabled && !kinetic.fixed)) {
      continue;
    }
    velocity = kinetic.velocity;
    force = Vec2.add(kinetic.force, kinetic.continuous);
    if (kinetic.fast) {
      if (kinetic.maxForce) {
        Vec2.limit(force, kinetic.maxForce);
      }
      Vec2.add(velocity, Vec2.scal(force, dt));
      Vec2.set(force);
      if (kinetic.maxVelocity) {
        Vec2.limit(velocity, kinetic.maxVelocity);
      }
      Vec2.add(kinetic.transform.pos, Vec2.scal(velocity, dt, cache));
      continue;
    }
    if ((gravity = kinetic.root.gravity) && kinetic.mass > epsilon) {
      Vec2.add(force, kinetic.mass !== 1 ? Vec2.scal(gravity, 1 / kinetic.mass, cache) : gravity);
    }
    if (kinetic.friction) {
      Vec2.add(force, Vec2.scal(Vec2.norm(velocity, cache), -kinetic.friction));
    }
    if (kinetic.maxForce) {
      Vec2.limit(force, kinetic.maxForce);
    }
    Vec2.copy(copyVel, velocity);
    Vec2.add(velocity, Vec2.scal(force, dt));
    if (kinetic.maxVelocity) {
      Vec2.limit(velocity, kinetic.maxVelocity);
    }
    Vec2.scal(Vec2.add(copyVel, velocity), dt / 2);
    Vec2.add(kinetic.transform.pos, copyVel);
    Vec2.add(velocity, force);
    if (kinetic.drag < 1) {
      Vec2.scal(velocity, kinetic.drag);
    }
    if ((sleepVelocity = kinetic.sleepVelocity)) {
      if (Vec2.lenSq(velocity) <= sleepVelocity * sleepVelocity) {
        if (!kinetic.sleeping) {
          Vec2.set(velocity);
          kinetic.sleeping = true;
          kinetic.entity.pubUp('onKineticSleep', kinetic);
        }
      } else {
        if (kinetic.sleeping) {
          kinetic.sleeping = false;
          kinetic.entity.pubUp('onKineticWake', kinetic);
        }
      }
    }
    Vec2.set(force);
  }
  return this;
};

new Pool(Kinetic);

module.exports = Kinetic;
