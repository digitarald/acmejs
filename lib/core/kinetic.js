// Generated by CoffeeScript 1.6.1
var Component, Force, Kinetic, Pool, Vec2, cache, copyVel,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Force = require('./force');

Vec2 = require('./math').Vec2;

cache = Vec2();

copyVel = Vec2();

Kinetic = (function(_super) {

  __extends(Kinetic, _super);

  Kinetic.prototype.type = 'kinetic';

  Kinetic.gravity = null;

  Kinetic.friction = 15;

  Kinetic.drag = 0.999;

  Kinetic.prototype.presets = {
    mass: 0,
    drag: Kinetic.drag,
    friction: Kinetic.friction,
    fixed: false,
    maxVel: 75,
    maxAcc: 2000,
    acc: Vec2(),
    vel: Vec2(),
    fast: false
  };

  function Kinetic() {
    this.vel = Vec2();
    this.acc = Vec2();
    this.sleepVelSq = 0.2;
  }

  Kinetic.prototype.reset = function(presets) {
    this.mass = presets.mass, this.drag = presets.drag, this.friction = presets.friction, this.fixed = presets.fixed, this.maxVel = presets.maxVel, this.maxAcc = presets.maxAcc, this.fast = presets.fast;
    Vec2.copy(this.vel, presets.vel);
    Vec2.copy(this.acc, presets.acc);
    this.pos = this.transform.pos;
    this.sleeping = false;
    return this;
  };

  Kinetic.prototype.applyImpulse = function(acc) {
    Vec2.add(this.acc, Vec2.scal(acc, 1 / (this.mass || 1), cache));
    return this;
  };

  Kinetic.prototype.applyForce = function(acc) {
    if (!this.force) {
      Force.alloc(this);
    }
    this.force.add(acc);
    return this;
  };

  return Kinetic;

})(Component);

Kinetic.simulate = function(dt) {
  var acc, epsilon, kinetic, vel, _i, _len, _ref;
  epsilon = Math.epsilon;
  _ref = this.roster;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    kinetic = _ref[_i];
    if (!(kinetic.enabled && !kinetic.fixed)) {
      continue;
    }
    vel = kinetic.vel;
    acc = kinetic.acc;
    if (kinetic.fast) {
      if (kinetic.maxAcc) {
        Vec2.limit(acc, kinetic.maxAcc);
      }
      Vec2.add(vel, Vec2.scal(acc, dt));
      Vec2.set(acc);
      if (kinetic.maxVel) {
        Vec2.limit(vel, kinetic.maxVel);
      }
      Vec2.add(kinetic.pos, Vec2.scal(vel, dt, cache));
      continue;
    }
    if (kinetic.root.gravity && kinetic.mass > epsilon) {
      Vec2.add(acc, Vec2.scal(kinetic.root.gravity, 1 / kinetic.mass, cache));
    }
    if (kinetic.friction) {
      Vec2.add(acc, Vec2.scal(Vec2.norm(vel, cache), -kinetic.friction));
    }
    if (kinetic.maxAcc) {
      Vec2.limit(acc, kinetic.maxAcc);
    }
    Vec2.copy(copyVel, vel);
    Vec2.add(vel, Vec2.scal(acc, dt));
    if (kinetic.maxVel) {
      Vec2.limit(vel, kinetic.maxVel);
    }
    Vec2.scal(Vec2.add(copyVel, vel), dt / 2);
    Vec2.add(kinetic.pos, copyVel);
    Vec2.add(vel, acc);
    if (kinetic.drag < 1) {
      Vec2.scal(vel, kinetic.drag);
    }
    if (kinetic.sleepVelSq) {
      if (Vec2.lenSq(vel) <= kinetic.sleepVelSq) {
        if (!kinetic.sleeping) {
          Vec2.set(vel);
          kinetic.sleeping = true;
          kinetic.parent.pubUp('onKineticSleep', kinetic);
        }
      } else {
        if (kinetic.sleeping) {
          kinetic.sleeping = false;
          kinetic.parent.pubUp('onKineticWake', kinetic);
        }
      }
    }
    Vec2.set(acc);
  }
  return this;
};

new Pool(Kinetic);

module.exports = Kinetic;
