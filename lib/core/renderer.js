// Generated by CoffeeScript 1.6.1
var Bounds, Color, Composite, Renderer, Vec2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Composite = require('./composite');

Bounds = require('./bounds');

Vec2 = require('./math').Vec2;

Color = require('./math');

Renderer = (function(_super) {

  __extends(Renderer, _super);

  function Renderer(element, client) {
    var fullscreenChange, self;
    this.element = element;
    this.client = Vec2(client);
    this.content = Vec2(client);
    this.canvas = document.createElement('canvas');
    this.element.appendChild(this.canvas);
    this.ctx = this.canvas.getContext('2d');
    this.browser = Vec2();
    this.margin = Vec2();
    this.pos = Vec2();
    this.scale = 0;
    this.orientation = 'landscape';
    this.buffer = false;
    this.buf = document.createElement('canvas');
    this.bufctx = this.buf.getContext('2d');
    this.buf.width = this.canvas.width = this.content[0];
    this.buf.height = this.canvas.height = this.content[1];
    this.element.style.width = this.content[0] + 'px';
    this.element.style.height = this.content[1] + 'px';
    window.addEventListener('resize', this, false);
    self = this;
    fullscreenChange = function() {
      return self.fullscreenChange();
    };
    document.addEventListener('fullscreenchange', fullscreenChange(false));
    document.addEventListener('mozfullscreenchange', fullscreenChange, false);
    document.addEventListener('webkitfullscreenchange', fullscreenChange, false);
    this.reflow();
    this;
  }

  Renderer.prototype.isFullscreen = function() {
    var doc;
    doc = document;
    return doc.fullscreen || doc.mozFullScreen || doc.webkitIsFullScreen;
  };

  Renderer.prototype.requestFullscreen = function() {
    var target;
    if (!this.isFullscreen()) {
      target = this.element.parentNode;
      if ('webkitRequestFullScreen' in target) {
        target.webkitRequestFullScreen();
      } else if ('mozRequestFullScreen' in target) {
        target.mozRequestFullScreen();
      }
    }
    return this;
  };

  Renderer.prototype.fullscreenChange = function() {
    if (this.orientation) {
      this.lockOrientation(this.orientation);
    }
    return this;
  };

  Renderer.prototype.lockOrientation = function(format) {
    var target;
    if (format == null) {
      format = this.orientation;
    }
    target = window.screen;
    if ('lockOrientation' in target) {
      screen.lockOrientation(format);
    } else if ('mozLockOrientation' in target) {
      screen.mozLockOrientation(format);
    }
    return this;
  };

  Renderer.prototype.handleEvent = function() {
    this.reflow();
    return this;
  };

  Renderer.prototype.reflow = function() {
    var browser, rule, scale;
    browser = Vec2.set(this.browser, window.innerWidth, window.innerHeight);
    scale = Math.min(this.browser[0] / this.content[0], this.browser[1] / this.content[1]);
    if (scale !== this.scale) {
      this.scale = scale;
      Vec2.scal(this.content, this.scale, this.client);
    }
    Vec2.scal(Vec2.sub(browser, this.client, this.margin), 0.5);
    rule = "translate(" + this.margin[0] + "px, " + this.margin[1] + "px) scale(" + this.scale + ")";
    this.element.style.transform = rule;
    this.element.style.webkitTransform = rule;
    return this;
  };

  Renderer.prototype.save = function() {
    var ctx;
    ctx = this.buffer ? this.bufctx : this.ctx;
    ctx.clearRect(0, 0, this.content[0], this.content[1]);
    ctx.save();
    ctx.translate(this.pos[0] | 0, this.pos[1] | 0);
    return ctx;
  };

  Renderer.prototype.restore = function() {
    if (this.buffer) {
      this.bufctx.restore();
      this.ctx.clearRect(0, 0, this.content[0], this.content[1]);
      this.ctx.drawImage(this.buf, 0, 0);
    } else {
      this.ctx.restore();
    }
    return this;
  };

  Renderer.prototype.center = function(pos) {
    Vec2.set(this.pos, pos[0] - this.client[0] / 2, pos[0] - this.client[1] / 2);
    return this;
  };

  Renderer.prototype.cull = function(entity) {
    var bounds;
    if (!(bounds = entity.bounds)) {
      return false;
    }
    if (bounds.withinRect(this.pos, this.content)) {
      if (bounds.culled) {
        bounds.culled = false;
      }
      return false;
    }
    if (!bounds.culled) {
      bounds.culled = true;
    }
    return true;
  };

  return Renderer;

})(Composite);

module.exports = Renderer;
