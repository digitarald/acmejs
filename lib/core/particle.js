// Generated by CoffeeScript 1.6.1
var Color, Component, Engine, Entity, Kinetic, Particle, Pool, Sprite, Transform, Vec2, crop, cropOffset, offset,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Entity = require('./entity');

Component = require('./component');

Pool = require('./pool');

Engine = require('./engine');

Vec2 = require('./math').Vec2;

Color = require('./color');

Transform = require('./transform');

Kinetic = require('./kinetic');

Sprite = require('./sprite').Asset;

Particle = (function(_super) {

  __extends(Particle, _super);

  Particle.prototype.tag = 'particle';

  Particle.layer = 10;

  Particle.prototype.attributes = {
    color: Color.black,
    colorVariant: 0,
    lifetime: 1,
    radius: 1,
    radiusVariant: 0,
    alpha: 1,
    alphaVariant: 0,
    composite: null,
    sprite: null,
    shrink: Math.quintIn,
    fade: Math.quintIn
  };

  function Particle() {
    this.color = Color();
  }

  Particle.prototype.instantiate = function(attributes) {
    var variant;
    this.lifetime = attributes.lifetime, this.radius = attributes.radius, this.alpha = attributes.alpha, this.composite = attributes.composite, this.sprite = attributes.sprite, this.shrink = attributes.shrink, this.fade = attributes.fade;
    Color.copy(this.color, attributes.color);
    if ((variant = attributes.colorVariant)) {
      Color.variant(this.color, variant);
    }
    if ((variant = attributes.radiusVariant)) {
      this.radius += Math.rand(-variant, variant);
    }
    if ((variant = attributes.alphaVariant)) {
      this.alpha = Math.clamp(this.alpha + Math.rand(-variant, variant), 0, 1);
    }
    this.age = 0;
    return this;
  };

  Particle.prototype.update = function(dt) {
    if ((this.age += dt) > this.lifetime) {
      this.entity.destroy();
    } else if (this.shrink && (this.radius *= 1 - this.shrink(this.age / this.lifetime)) < 1) {
      this.entity.destroy();
    } else if (this.fade && (this.alpha *= 1 - this.fade(this.age / this.lifetime)) <= 0.02) {
      this.entity.destroy();
    }
    return this;
  };

  return Particle;

})(Component);

Particle.defaultEntity = null;

crop = Vec2();

cropOffset = Vec2();

offset = Vec2();

Particle.render = function(ctx) {
  var alpha, alphaPrev, composite, compositePrev, defaultComposite, entityPrev, fill, fillPrev, particle, pos, radius, _i, _len, _ref;
  ctx.save();
  Vec2.set(crop, 50, 50);
  Vec2.set(cropOffset, -25, -25);
  alphaPrev = 1;
  entityPrev = null;
  fillPrev = null;
  defaultComposite = Particle.defaultComposite;
  _ref = this.register;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    particle = _ref[_i];
    if (!particle.enabled) {
      continue;
    }
    radius = particle.radius;
    pos = particle.transform.pos;
    alpha = particle.alpha;
    composite = particle.composite || defaultComposite;
    if (composite !== compositePrev) {
      ctx.globalCompositeOperation = compositePrev = composite;
    }
    if (particle.sprite) {
      Vec2.set(offset, 0, 50 * (radius - 1 | 0));
      if (alpha !== alphaPrev) {
        ctx.globalAlpha = alphaPrev = alpha;
      }
      particle.sprite.draw(ctx, pos, Vec2.center, crop, offset);
    } else {
      particle.color[3] = alpha;
      fill = Color.rgba(particle.color);
      if (fill !== fillPrev) {
        ctx.fillStyle = fillPrev = fill;
      }
      ctx.fillRect(pos[0] - radius / 2 | 0, pos[1] - radius / 2 | 0, radius | 0, radius | 0);
    }
  }
  ctx.restore();
  return this;
};

Particle.generateSprite = function(color, alpha, max) {
  var size;
  if (color == null) {
    color = Color.white;
  }
  if (alpha == null) {
    alpha = 1;
  }
  if (max == null) {
    max = 25;
  }
  color = Color(color);
  size = max * 2;
  return new Sprite(function(ctx) {
    var grad, radius, top, _i, _results;
    _results = [];
    for (radius = _i = 1; _i <= max; radius = _i += 1) {
      top = max + size * (radius - 1);
      grad = ctx.createRadialGradient(max, top, 0, max, top, radius);
      color[3] = alpha;
      grad.addColorStop(0, Color.rgba(color));
      color[3] = 0;
      grad.addColorStop(1, Color.rgba(color));
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(max, top, radius, 0, Math.TAU, true);
      ctx.closePath();
      _results.push(ctx.fill());
    }
    return _results;
  }, Vec2(size, size * max));
};

Particle.sprite = Particle.generateSprite();

Particle.Prefab = new Entity.Prefab({
  transform: null,
  kinetic: {
    mass: 0
  },
  particle: null
});

new Pool(Particle);

module.exports = Particle;
