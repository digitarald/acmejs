// Generated by CoffeeScript 1.6.1
var B2, Body, Component, Pool, Vec2, empty, impulseCache, manifoldCache, pointCache,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./../../core/component');

Pool = require('./../../core/pool');

Vec2 = require('./../../core/math').Vec2;

B2 = require('./b2');

Body = (function(_super) {

  __extends(Body, _super);

  Body.prototype.tag = 'b2Body';

  Body.prototype.attributes = {
    fixed: false,
    vel: Vec2(),
    allowSleep: true,
    angularVelocity: 0,
    awake: true,
    bullet: false,
    fixedRotation: false,
    density: 1,
    friction: 0.5,
    restitution: 0.2
  };

  Body.definitionPresets = ['allowSleep', 'angularVelocity', 'awake', 'bullet', 'fixedRotation'];

  Body.fixturePresets = ['density', 'friction', 'restitution'];

  function Body() {
    this.definition = new B2.BodyDef();
    this.fixture = new B2.FixtureDef();
  }

  Body.prototype.instantiate = function(attributes) {
    var bounds, definition, fixed, fixture, gravity, key, world, _i, _j, _len, _len1, _ref, _ref1;
    if (!(world = this.root.b2World)) {
      gravity = new B2.Vec2(this.root.gravity[0], this.root.gravity[1]);
      world = new B2.World(gravity);
      this.root.b2World = world;
      Body.b2World = world;
    }
    definition = this.definition, fixture = this.fixture;
    _ref = Body.definitionPresets;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      definition[key] = attributes[key];
    }
    definition.userData = this;
    Vec2.toObj(this.transform.pos, definition.position);
    definition.angle = this.transform.angle;
    Vec2.toObj(attributes.vel, definition.linearVelocity);
    this.fixed = fixed = attributes.fixed;
    definition.type = fixed ? B2.Body.b2_staticBody : B2.Body.b2_dynamicBody;
    this.b2body = world.CreateBody(definition);
    _ref1 = Body.fixturePresets;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      key = _ref1[_j];
      fixture[key] = attributes[key];
    }
    bounds = this.bounds;
    switch (bounds.shape) {
      case 'circle':
        fixture.shape = new B2.CircleShape(bounds.radius);
        break;
      case 'poly':
        fixture.shape = new B2.PolygonShape(bounds.radius);
        fixture.shape.SetAsArray(bounds.points, bounds.points.length);
        break;
      case 'rect':
        fixture.shape = new B2.PolygonShape();
        fixture.shape.SetAsBox(bounds.size[0] / 2, bounds.size[1] / 2);
        break;
    }
    this.b2body.CreateFixture(fixture);
    return this;
  };

  Body.prototype.onTransform = function() {
    this.b2body.SetPositionAndAngle(Vec2.toObj(this.transform.pos), this.transform.angle);
    return this;
  };

  Body.prototype.onEnable = function() {
    this.b2body.SetActive(true);
    return this;
  };

  Body.prototype.onDisable = function() {
    this.b2body.SetActive(false);
    return this;
  };

  Body.prototype.free = function() {
    Body.b2World.DestroyBody(this.b2body);
    this.b2body = null;
    return Body.__super__.free.call(this);
  };

  Body.prototype.applyForce = function(acc) {
    this.b2body.ApplyImpulse(Vec2.toObj(acc), this.b2body.GetWorldCenter());
    return this;
  };

  return Body;

})(Component);

manifoldCache = new B2.WorldManifold();

impulseCache = Vec2();

pointCache = Vec2();

Body.PostSolve = function(contact, impulse) {
  var bodyA, bodyB;
  bodyA = contact.GetFixtureA().GetBody().GetUserData();
  bodyB = contact.GetFixtureB().GetBody().GetUserData();
  Vec2.copy(impulseCache, impulse.tangentImpulses);
  contact.GetWorldManifold(manifoldCache);
  Vec2.fromObj(manifoldCache.m_points[0], pointCache);
  bodyA.entity.pub('onCollide', bodyB.entity, impulseCache);
  bodyB.entity.pub('onCollide', bodyA.entity, impulseCache);
  return null;
};

empty = function(contact) {
  return null;
};

Body.BeginContact = empty;

Body.EndContact = empty;

Body.PreSolve = empty;

Body.fixedUpdate = function(dt) {
  var b2body, body, _i, _len, _ref;
  Body.b2World.Step(dt * 2, 4, 2);
  _ref = this.register;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    body = _ref[_i];
    if (!(body.enabled && !body.fixed)) {
      continue;
    }
    b2body = body.b2body;
    if (b2body.IsAwake()) {
      Vec2.fromObj(b2body.GetPosition(), body.transform.pos);
      body.transform.angle = b2body.GetAngle();
    }
  }
  return this;
};

new Pool(Body);

module.exports = Body;
