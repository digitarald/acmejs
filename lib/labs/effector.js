// Generated by CoffeeScript 1.6.1
var Component, Effector, Pool, Vec2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

Effector = (function(_super) {

  __extends(Effector, _super);

  function Effector() {
    return Effector.__super__.constructor.apply(this, arguments);
  }

  Effector.prototype.tag = 'effector';

  Effector.prototype.alloc = function(entity, radius, mass) {
    this.radius = radius != null ? radius : 100;
    this.mass = mass != null ? mass : this.entity.mass;
    Effector.__super__.alloc.call(this, entity);
    this.radiusSq = this.radius * this.radius;
    this.ease = Math.quadIn;
    return this;
  };

  return Effector;

})(Component);

Effector.simulate = function(dt) {
  var acc, avoidanceCount, cohesionCount, diff, diffSq, effector1, effector2, effectors, entity1, entity2, i, imitationCount, j;
  effectors = this.register;
  i = effectors.length;
  while (i--) {
    effector1 = effectors[i];
    if (!effector1.enabled) {
      continue;
    }
    avoidanceCount = imitationCount = cohesionCount = 0;
    j = effectors.length;
    while (j--) {
      effector2 = effectors[j];
      if (!effector2.enabled || effector1 === effector2) {
        continue;
      }
      entity1 = effector1.entity;
      entity2 = effector2.entity;
      acc = entity1.acc;
      diffSq = Vec2.distSq(entity1.pos, entity2.pos);
      if (diffSq < effector1.radiusSq) {
        diff = Math.sqrt(diffSq);
        Vec2.add(acc, Vec2.scal(Vec2.sub(entity1.pos, entity2.pos, avoidance), 2));
      }
    }
    if (cohesionCount) {
      if (cohesionCount > 1) {
        Vec2.scal(cohesion, 1 / cohesionCount);
      }
      Vec2.limit(Vec2.sub(cohesion, entity1.pos), limit);
      Vec2.add(acc, Vec2.scal(cohesion, effector1.cohesionMod));
    }
    if (imitationCount) {
      if (imitationCount > 1) {
        Vec2.scal(imitation, 1 / imitationCount);
      }
      Vec2.limit(imitation, limit);
      Vec2.add(acc, Vec2.scal(imitation, effector1.imitationMod));
    }
  }
  return this;
};

new Pool(Effector);

module.exports = Effector;
