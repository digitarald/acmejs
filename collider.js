// Generated by CoffeeScript 1.3.3
var Collider,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Collider = (function() {

  function Collider() {}

  Collider.prototype.alloc = function(owner) {
    owner.collider = this;
    owner.pubsub.sub(this, 'free');
    return this.owner = owner;
  };

  Collider.prototype.free = function() {
    this.allocd = false;
    this.owner.pubsub.unsub(this);
    this.owner = this.owner.collider = null;
    return this;
  };

  return Collider;

})();

Pool.Colliders = (function(_super) {

  __extends(Colliders, _super);

  function Colliders() {
    return Colliders.__super__.constructor.apply(this, arguments);
  }

  Colliders.prototype.instantiate = function() {
    return new Collider();
  };

  Colliders.prototype.update = function(dt) {
    var collider1, collider2, colliders, diff, diffSq, i, j, mass1, mass2, n, owner1, owner2, p, radius1, radius2, radiusSum, vn1, vn2, vp1, vp1After, vp2, vp2After;
    dt /= 1000;
    colliders = this.roster;
    i = colliders.length;
    while (i--) {
      collider1 = colliders[i];
      if (!collider1.allocd) {
        continue;
      }
      j = i;
      while (j--) {
        collider2 = colliders[j];
        if (!collider2.allocd) {
          continue;
        }
        owner1 = collider1.owner;
        owner2 = collider2.owner;
        radius1 = owner1.radius;
        radius2 = owner2.radius;
        radiusSum = radius1 + radius2;
        diffSq = Vec2.distSq(owner1.pos, owner2.pos);
        if (diffSq > radiusSum * radiusSum) {
          continue;
        }
        diff = Math.sqrt(diffSq) - radiusSum;
        mass1 = owner1.mass || radius1;
        mass2 = owner2.mass || radius2;
        p = Vec2.norm(Vec2.sub(owner1.pos, owner2.pos, Vec2.cache[0]));
        if (diff < 0) {
          Vec2.add(owner1.pos, Vec2.scal(p, -diff * 2 * radius1 / radiusSum, Vec2.cache[1]));
          Vec2.add(owner2.pos, Vec2.scal(p, diff * 2 * radius2 / radiusSum, Vec2.cache[1]));
        }
        n = Vec2.set(Vec2.cache[1], p[1], -p[0]);
        vp1 = Vec2.dot(owner1.vel, p);
        vn1 = Vec2.dot(owner1.vel, n);
        vp2 = Vec2.dot(owner2.vel, p);
        vn2 = Vec2.dot(owner2.vel, n);
        vp1After = (mass1 * vp1 + mass2 * (2 * vp2 - vp1)) / (mass1 + mass2);
        vp2After = (mass1 * (2 * vp1 - vp2) + mass2 * vp2) / (mass1 + mass2);
        Vec2.add(Vec2.scal(p, vp1After, Vec2.cache[2]), Vec2.scal(n, vn1, Vec2.cache[3]), owner1.vel);
        Vec2.add(Vec2.scal(p, vp2After, Vec2.cache[2]), Vec2.scal(n, vn2, Vec2.cache[3]), owner2.vel);
        if (!owner2.pubsub) {
          debugger;
        }
        owner1.pubsub.pub('collide', owner2, n);
        owner2.pubsub.pub('collide', owner1, n);
      }
    }
    return this;
  };

  return Colliders;

})(Pool);

Collider.pool = new Pool.Colliders(128);
