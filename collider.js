// Generated by CoffeeScript 1.3.3
var Collider,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Collider = (function() {

  function Collider() {}

  Collider.prototype.acquire = function(host) {
    this.acquired = true;
    host.collider = this;
    host.pubsub.sub('release', this);
    return this.host = host;
  };

  Collider.prototype.release = function() {
    this.acquired = false;
    this.host.pubsub.unsub(null, this);
    this.host = this.host.collider = null;
    return this;
  };

  Collider.prototype.collide = function(target) {
    var diff, diffSq, host1, host2, mass1, mass2, n, normal, radius1, radius2, radiusSum, vn1, vn2, vp1, vp1After, vp2, vp2After;
    host1 = this.host;
    host2 = target.host;
    radius1 = host1.radius;
    radius2 = host2.radius;
    radiusSum = radius1 + radius2;
    diffSq = Vec2.distSq(host1.pos, host2.pos);
    if (diffSq > radiusSum * radiusSum) {
      return false;
    }
    diff = Math.sqrt(diffSq) - radiusSum;
    mass1 = host1.mass || radius1;
    mass2 = host2.mass || radius2;
    normal = Vec2.norm(Vec2.sub(host1.pos, host2.pos, Vec2.cache[0]));
    if (diff < 0) {
      Vec2.add(host1.pos, Vec2.scal(normal, -diff * radius1 / radiusSum, Vec2.cache[1]));
      Vec2.add(host2.pos, Vec2.scal(normal, diff * radius2 / radiusSum, Vec2.cache[1]));
    }
    n = Vec2.set(Vec2.cache[1], normal[1], -normal[0]);
    vp1 = Vec2.dot(host1.vel, normal);
    vn1 = Vec2.dot(host1.vel, n);
    vp2 = Vec2.dot(host2.vel, normal);
    vn2 = Vec2.dot(host2.vel, n);
    vp1After = (mass1 * vp1 + mass2 * (2 * vp2 - vp1)) / (mass1 + mass2);
    vp2After = (mass1 * (2 * vp1 - vp2) + mass2 * vp2) / (mass1 + mass2);
    Vec2.add(Vec2.scal(normal, vp1After, Vec2.cache[2]), Vec2.scal(n, vn1, Vec2.cache[3]), host1.vel);
    Vec2.add(Vec2.scal(normal, vp2After, Vec2.cache[2]), Vec2.scal(n, vn2, Vec2.cache[3]), host2.vel);
    return true;
  };

  return Collider;

})();

Pool.Colliders = (function(_super) {

  __extends(Colliders, _super);

  function Colliders() {
    return Colliders.__super__.constructor.apply(this, arguments);
  }

  Colliders.prototype.allocate = function() {
    return new Collider();
  };

  Colliders.prototype.update = function(delta) {
    var collider, colliders, i, j;
    delta /= 1000;
    colliders = this.buffer;
    i = colliders.length;
    while (i--) {
      collider = colliders[i];
      if (!collider.acquired) {
        continue;
      }
      j = i;
      while (j--) {
        if (colliders[j].acquired) {
          collider.collide(colliders[j]);
        }
      }
    }
    return this;
  };

  return Colliders;

})(Pool);

Collider.pool = new Pool.Colliders(128);
