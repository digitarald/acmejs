// Generated by CoffeeScript 1.3.3
var Pool, fn, _i, _len, _ref;

require('./math');

Pool = (function() {

  Pool.typedHooks = ['fixedUpdate', 'simulate', 'update', 'lateUpdate', 'render'];

  Pool.hookRegx = /^on[A-Z]/;

  Pool.hooks = {};

  Pool.types = {};

  Pool.defaults = {};

  Pool.order = {
    render: false
  };

  Pool.prototype.toString = function() {
    return "Pool {@type} [" + this.roster.length + "]";
  };

  function Pool(cls) {
    var fn, keys, proto, types, _i, _j, _len, _len1,
      _this = this;
    this.cls = cls;
    this.roster = [];
    this.subs = [];
    this.hooks = [];
    this.enabled = false;
    this.allocd = 0;
    proto = cls.prototype;
    this.type = proto.type;
    this.dirty = false;
    this.extended = this.type && this.type !== 'composite';
    Pool.types[this.type] = this;
    proto.pool = this;
    cls.pool = this;
    if (this.extended) {
      types = Pool.typedHooks;
      keys = Object.keys(proto).concat(Object.keys(cls));
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        fn = keys[_i];
        if (Pool.hookRegx.test(fn)) {
          if (!~types.indexOf(fn)) {
            types.push(fn);
            Pool.hooks[fn] = [];
          }
          this.subs.push(fn);
        }
      }
      for (_j = 0, _len1 = types.length; _j < _len1; _j++) {
        fn = types[_j];
        if (fn in cls) {
          this[fn] = cls[fn];
          Pool.hooks[fn].push(this);
        } else if (fn in proto) {
          this.hooks.push(fn);
        }
      }
    }
    cls.alloc = function(parent, presets) {
      return _this.alloc(parent, presets);
    };
  }

  Pool.prototype.preinstantiate = function(i) {
    while (i--) {
      this.instantiate();
    }
    return this;
  };

  Pool.prototype.instantiate = function() {
    var cls, hook, _i, _len, _ref;
    cls = new this.cls();
    this.roster.push(cls);
    _ref = this.hooks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      hook = _ref[_i];
      Pool.hooks[hook].push(cls);
    }
    return cls;
  };

  Pool.prototype.alloc = function(parent, presets) {
    var defaults, entity, i, roster, topic, _i, _len, _ref;
    roster = this.roster;
    i = roster.length;
    while (i--) {
      if (!roster[i].allocd) {
        entity = roster[i];
        break;
      }
    }
    if (!entity) {
      entity = this.instantiate();
    }
    this.allocd++;
    this.enabled = true;
    if (fn in Pool.order) {
      Pool.order[fn] = true;
    }
    entity.uid = Math.uid();
    entity.enabled = true;
    entity.allocd = true;
    entity.parent = parent;
    entity.root = parent.root || parent || entity;
    entity.layer = (parent && parent.layer || -1) + 1 + (entity.layer || 0);
    if (this.extended) {
      if (defaults = entity.presets) {
        if (presets && !presets._merged) {
          presets.__proto__ = defaults;
          presets._merged = true;
        }
      }
      _ref = this.subs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        topic = _ref[_i];
        parent.sub(entity, topic);
      }
    }
    entity.alloc(presets || defaults || null);
    return entity;
  };

  Pool.prototype.free = function(entity) {
    this.enabled = this.allocd-- > 1;
    entity.enabled = false;
    entity.allocd = false;
    entity.uid = null;
    entity.root = null;
    return entity.parent = null;
  };

  return Pool;

})();

_ref = Pool.typedHooks;
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
  fn = _ref[_i];
  Pool.hooks[fn] = [];
}

Pool.invoke = function(fn, a0, a1, a2, a3) {
  var i, stack;
  if ((stack = this.hooks[fn]) && (i = stack.length)) {
    if (fn in Pool.order && Pool.order[fn]) {
      stack.sort(Pool.orderFn);
      Pool.order[fn] = false;
    }
    while (i--) {
      if (stack[i].enabled) {
        stack[i][fn](a0, a1, a2, a3);
      }
    }
  }
  return this;
};

Pool.orderFn = function(a, b) {
  return (b.layer - a.layer) || (a.uid < b.uid);
};

module.exports = Pool;
