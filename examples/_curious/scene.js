// Generated by CoffeeScript 1.6.1
var Catapult, Component, Earth, Engine, Entity, Particle, Pool, Scene, Sky, Sprite, Vec2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Entity = require('./entity');

Pool = require('./pool');

Engine = require('./engine');

Vec2 = require('../math/vec2');

Catapult = require('./catapult');

Sprite = require('./sprite').Asset;

Particle = require('./particle');

Scene = (function(_super) {

  __extends(Scene, _super);

  Scene.prototype.type = 'scene';

  function Scene() {
    this.gravity = null;
    this.friction = 0;
    this.drag = 1;
    this.catapult = Catapult.alloc(this, Vec2(100, 540));
    Sky.alloc(this);
    Earth.alloc(this, Vec2(840, 520));
  }

  return Scene;

})(Entity);

module.exports = Scene;

Earth = (function(_super) {

  __extends(Earth, _super);

  function Earth() {
    return Earth.__super__.constructor.apply(this, arguments);
  }

  Earth.prototype.type = 'earth';

  Earth.prototype.onTrigger = function(entity) {
    var pos;
    pos = entity.transform.position;
    entity.destroy();
    require('./explosion').alloc(this, pos);
    return this;
  };

  Earth.prototype.render = function(ctx) {
    Earth.sprite.draw(ctx, this.transform.position);
    return this;
  };

  return Earth;

})(Component);

Earth.sprite = new Sprite('assets/earth.png');

new Pool(Earth);

Sky = (function(_super) {

  __extends(Sky, _super);

  Sky.prototype.type = 'sky';

  function Sky() {
    this.stars = [];
  }

  Sky.prototype.create = function() {
    var i, size, _i, _results;
    size = Engine.renderer.size;
    _results = [];
    for (i = _i = 0; _i <= 100; i = ++_i) {
      _results.push(this.stars.push(Vec2(Math.rand(-size[0] / 2, size[0] * 1.5), Math.rand(-size[1] / 2, size[1] * 1.5)), Math.rand(1, 10) | 0, Math.rand(1, 4) | 0));
    }
    return _results;
  };

  Sky.prototype.update = function(dt, scene) {
    var input, pos;
    input = Engine.input;
    pos = input.position;
    if (input.keys.space === 'began') {
      pos = input.position;
      require('./explosion').alloc(this, pos);
    }
    if (input.touchState === 'began' && scene.catapult.state !== 'active') {
      require('./../meteor').alloc(this, pos);
    }
    return this;
  };

  Sky.prototype.render = function(ctx, scene) {
    var crop, cropOffset, i, input, layer, offset, pos, radius, _i, _ref;
    if (!Particle.sprite) {
      return;
    }
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    crop = Vec2.set(Vec2.cache[0], 50, 50);
    cropOffset = Vec2.set(Vec2.cache[1], -25, -25);
    input = Engine.input.current;
    for (i = _i = 0, _ref = this.stars.length - 1; _i <= _ref; i = _i += 3) {
      pos = this.stars[i];
      layer = this.stars[i + 1];
      radius = this.stars[i + 2];
      pos = Vec2.add(pos, cropOffset, Vec2.cache[2]);
      offset = Vec2.set(Vec2.cache[3], 0, 50 * (radius - 1));
      ctx.globalAlpha = 1 / layer;
      Particle.sprite.draw(ctx, pos, crop, offset);
    }
    ctx.restore();
    return this;
  };

  return Sky;

})(Component);

new Pool(Sky);
