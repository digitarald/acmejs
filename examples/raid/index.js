// Generated by CoffeeScript 1.6.1
'use strict';
var Border, Collider, Color, Component, Damageable, Enemy, Engine, Entity, GameController, Hero, Kinetic, Pool, Projectile, Renderer, Sprite, Transform, Vec2, defaultSequence,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Vec2 = require('../../lib/core/math').Vec2;

Engine = require('../../lib/core/engine');

Engine.init(document.getElementById('game-1'));

Renderer = require('../../lib/core/renderer');

Engine.renderer = new Renderer(Engine.element.getElementsByClassName('game-canvas')[0], Vec2(480, 320));

Entity = require('../../lib/core/entity');

Component = require('../../lib/core/component');

Pool = require('../../lib/core/pool');

Color = require('../../lib/core/color');

Sprite = require('../../lib/core/sprite');

Transform = require('../../lib/core/transform');

Border = require('../../lib/core/border');

Collider = require('../../lib/core/collider');

Kinetic = require('../../lib/core/kinetic');

GameController = (function(_super) {

  __extends(GameController, _super);

  function GameController() {
    return GameController.__super__.constructor.apply(this, arguments);
  }

  GameController.prototype.tag = 'gameController';

  GameController.prototype.instantiate = function() {
    Hero.Prefab.alloc(this.root, {
      transform: {
        pos: Vec2(20, 160)
      }
    });
    this.cooldown = 0;
    return this;
  };

  GameController.prototype.postUpdate = function(dt) {
    var enemy;
    if ((this.cooldown -= dt) > 0) {
      return this;
    }
    this.cooldown = Math.rand(0.5, 1.5);
    enemy = Enemy.Prefab.alloc(this.root, {
      transform: {
        pos: Vec2(550, Math.rand(50, 270))
      }
    });
    return this;
  };

  return GameController;

})(Component);

new Pool(GameController);

defaultSequence = {
  walkS: {
    frames: [0, 1, 2, 1],
    next: 'walkS'
  },
  walkW: {
    frames: [3, 4, 5, 4],
    next: 'walkW'
  },
  walkN: {
    frames: [9, 10, 11, 10],
    next: 'walkN'
  },
  walkE: {
    frames: [6, 7, 8, 7],
    next: 'walkE'
  }
};

Hero = (function(_super) {

  __extends(Hero, _super);

  Hero.prototype.tag = 'hero';

  function Hero() {
    this.aimNormal = Vec2();
  }

  Hero.prototype.instantiate = function() {
    this.cooldown = 0;
    return this;
  };

  Hero.prototype.fixedUpdate = function() {
    var axis, pos, speed;
    axis = Engine.input.axis;
    pos = this.transform.pos;
    speed = 1;
    if (axis[1] < 0) {
      pos[1] -= speed;
    } else if (axis[1] > 0) {
      pos[1] += speed;
    }
    if (axis[0] < 0) {
      pos[0] -= speed;
    } else if (axis[0] > 0) {
      pos[0] += speed;
    }
    return this;
  };

  Hero.prototype.update = function(dt) {
    var angle, axis, input, projectile, spriteTween, vel;
    input = Engine.input;
    Vec2.sub(input.pos, this.transform.pos, this.aimNormal);
    axis = input.axis;
    spriteTween = this.spriteTween;
    if (Vec2.len(axis) > 0) {
      spriteTween.goto('walkE').play();
    } else if (!spriteTween.paused) {
      spriteTween.pause().goto('walkE');
    }
    if ((this.cooldown -= dt) < 0 && input.touchState) {
      angle = Vec2.rad(this.aimNormal);
      vel = Vec2.rot(Vec2(400, 0), angle);
      projectile = Projectile.Prefab.alloc(this.root, {
        transform: {
          pos: this.transform.pos
        },
        kinetic: {
          velocity: vel
        }
      });
      this.cooldown = 0.1;
    }
    return this;
  };

  return Hero;

})(Component);

new Pool(Hero);

Hero.sheet = new Sprite.Sheet({
  sprites: new Sprite.Asset('./assets/hero.png'),
  size: Vec2(32, 32),
  speed: 0.15,
  sequences: defaultSequence
});

Hero.Prefab = new Entity.Prefab({
  transform: null,
  spriteTween: {
    asset: Hero.sheet,
    sequence: 'walkS'
  },
  bounds: {
    radius: 16,
    shape: 'circle'
  },
  border: null,
  hero: null
});

Damageable = (function(_super) {

  __extends(Damageable, _super);

  function Damageable() {
    return Damageable.__super__.constructor.apply(this, arguments);
  }

  Damageable.prototype.tag = 'damageable';

  Damageable.prototype.attributes = {
    health: 100,
    current: 100
  };

  Damageable.prototype.instantiate = function(attributes) {
    this.health = attributes.health, this.current = attributes.current;
    return this;
  };

  Damageable.prototype.hit = function(source, amount) {
    this.entity.pub('onDamage', amount);
    if ((this.current -= amount) < 0) {
      this.entity.pub('onDead');
      this.entity.destroy();
    }
    return this;
  };

  return Damageable;

})(Component);

new Pool(Damageable);

Enemy = (function(_super) {

  __extends(Enemy, _super);

  function Enemy() {
    return Enemy.__super__.constructor.apply(this, arguments);
  }

  Enemy.prototype.tag = 'enemy';

  Enemy.prototype.instantiate = function() {
    return this;
  };

  Enemy.prototype.update = function() {
    if (this.transform.pos[0] < 25) {
      this.transform.pos[0] = 550;
    }
    return this;
  };

  Enemy.prototype.onDamage = function() {
    this.kinetic.applyImpulse(Vec2(-500, 0));
    return this;
  };

  Enemy.prototype.onDead = function() {
    this.entity.destroy();
    return this;
  };

  return Enemy;

})(Component);

new Pool(Enemy);

Enemy.sheet = new Sprite.Sheet({
  sprites: new Sprite.Asset('./assets/skeleton.png'),
  size: Vec2(32, 32),
  speed: 0.15,
  sequences: defaultSequence
});

Enemy.Prefab = new Entity.Prefab({
  transform: null,
  bounds: {
    radius: 14,
    shape: 'circle'
  },
  collider: {
    trigger: true
  },
  kinetic: {
    mass: 1,
    drag: 1,
    friction: 0,
    force: Vec2(-100, 0)
  },
  boundsDebug: null,
  damageable: null,
  spriteTween: {
    asset: Enemy.sheet,
    sequence: 'walkW'
  }
});

Projectile = (function(_super) {

  __extends(Projectile, _super);

  Projectile.prototype.tag = 'projectile';

  function Projectile() {
    this.lastPos = Vec2();
  }

  Projectile.prototype.instantiate = function() {
    Vec2.copy(this.lastPos, this.transform.pos);
    return this;
  };

  Projectile.prototype.render = function(ctx) {
    var pos;
    pos = this.transform.pos;
    ctx.save();
    ctx.strokeStyle = Color.rgba(Color.white);
    ctx.beginPath();
    ctx.moveTo(this.lastPos[0] | 0, this.lastPos[1] | 0);
    ctx.lineTo(pos[0] | 0, pos[1] | 0);
    ctx.stroke();
    ctx.restore();
    Vec2.copy(this.lastPos, pos);
    return this;
  };

  Projectile.prototype.onTrigger = function(entity) {
    entity.damageable.hit(this.entity, Math.rand(10, 15));
    this.entity.destroy();
    return this;
  };

  return Projectile;

})(Component);

new Pool(Projectile);

Projectile.Prefab = new Entity.Prefab({
  transform: null,
  bounds: {
    shape: 'circle',
    radius: 2
  },
  kinetic: {
    mass: 0.1,
    drag: 1,
    friction: 0,
    maxVelocity: 0,
    maxForce: 0
  },
  collider: {
    include: 'damageable',
    trigger: true
  },
  border: {
    mode: 'kill'
  },
  projectile: null
});

Engine.gameScene = Entity.alloc(null, {
  gameController: null
});

Engine.play(Engine.gameScene);
