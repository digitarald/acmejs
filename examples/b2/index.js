// Generated by CoffeeScript 1.6.1
'use strict';
var Body, Box, Color, Component, Engine, Entity, Explosion, GameController, Pool, Renderer, Spark, Vec2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Vec2 = require('../../lib/core/math').Vec2;

Engine = require('../../lib/core/engine');

Engine.init(document.getElementById('game-1'));

Renderer = require('../../lib/core/renderer');

Engine.renderer = new Renderer(Engine.element.getElementsByClassName('game-canvas')[0], Vec2(480, 290));

Entity = require('../../lib/core/entity');

Component = require('../../lib/core/component');

Pool = require('../../lib/core/pool');

Color = require('../../lib/core/color');

require('../../lib/core/transform');

require('../../lib/core/border');

Body = require('../../lib/vendor/b2/body');

GameController = (function(_super) {

  __extends(GameController, _super);

  function GameController() {
    return GameController.__super__.constructor.apply(this, arguments);
  }

  GameController.prototype.tag = 'gameController';

  GameController.prototype.instantiate = function() {
    this.root.gravity = Vec2(0, 10);
    Entity.alloc(this.root, {
      transform: {
        pos: Vec2(240, 283)
      },
      bounds: {
        shape: 'rect',
        size: Vec2(480, 15)
      },
      b2Body: {
        fixed: true
      },
      boundsDebug: null
    });
    Entity.alloc(this.root, {
      transform: {
        pos: Vec2(240, 7)
      },
      bounds: {
        shape: 'rect',
        size: Vec2(480, 15)
      },
      b2Body: {
        fixed: true
      },
      boundsDebug: null
    });
    Entity.alloc(this.root, {
      transform: {
        pos: Vec2(7, 160)
      },
      bounds: {
        shape: 'rect',
        size: Vec2(15, 320)
      },
      b2Body: {
        fixed: true
      },
      boundsDebug: null
    });
    Entity.alloc(this.root, {
      transform: {
        pos: Vec2(473, 160)
      },
      bounds: {
        shape: 'rect',
        size: Vec2(15, 320)
      },
      b2Body: {
        fixed: true
      },
      boundsDebug: null
    });
    this.spawnBoxes();
    return this;
  };

  GameController.prototype.spawnBox = function() {
    var size, sphere;
    size = Math.rand(5, 25);
    sphere = Math.chance(0.5);
    Box.Prefab.alloc(this.root, {
      transform: {
        pos: Vec2(Math.rand(25, 450), Math.rand(25, 265))
      },
      bounds: {
        radius: size / 2,
        size: Vec2(size, size),
        shape: sphere ? 'circle' : 'rect'
      },
      b2Body: {
        awake: false
      }
    });
    return this;
  };

  GameController.prototype.spawnBoxes = function() {
    var i, _i;
    for (i = _i = 0; _i <= 10; i = ++_i) {
      this.spawnBox();
    }
    return this;
  };

  GameController.prototype.update = function() {
    var input;
    input = Engine.input;
    if (input.touchState === 'began') {
      Explosion.Prefab.alloc(this.root, {
        transform: {
          pos: input.pos
        }
      });
    }
    if (input.keys.space === 'began') {
      this.spawnBoxes();
      return this;
    }
  };

  return GameController;

})(Component);

new Pool(GameController);

Box = (function(_super) {

  __extends(Box, _super);

  function Box() {
    return Box.__super__.constructor.apply(this, arguments);
  }

  Box.prototype.tag = 'box';

  Box.prototype.onCollide = function(other, impulse) {
    return this;
  };

  return Box;

})(Component);

new Pool(Box);

Box.Prefab = new Entity.Prefab({
  transform: null,
  bounds: {
    shape: 'circle',
    radius: 10
  },
  box: null,
  b2Body: {
    restitution: 0.9,
    density: 0.5
  },
  border: {
    mirror: true
  },
  boundsDebug: null
});

Explosion = (function(_super) {

  __extends(Explosion, _super);

  Explosion.prototype.tag = 'explosion';

  Explosion.prototype.attributes = {
    lifetime: 0.25,
    maxSize: 100,
    color: Color.white
  };

  function Explosion() {
    this.color = Color();
  }

  Explosion.prototype.instantiate = function(attributes) {
    Color.copy(this.color, attributes.color);
    this.lifetime = attributes.lifetime;
    this.maxSize = attributes.maxSize;
    this.impulse = 50000;
    this.pos = this.transform.pos;
    this.age = 0;
    return this;
  };

  Explosion.prototype.update = function(dt) {
    var age;
    if (!this.age) {
      this.explode();
    }
    age = (this.age += dt);
    if (age >= this.lifetime) {
      this.entity.destroy();
    } else {
      this.factor = Math.quadOut(age / this.lifetime);
      this.size = this.factor * this.maxSize;
    }
    return this;
  };

  Explosion.prototype.explode = function() {
    var body, distSq, factor, i, impulse, maxSize, maxSizeSq, pos, pos2, _i, _j, _len, _ref;
    maxSize = this.maxSize, impulse = this.impulse;
    pos = this.transform.pos;
    maxSizeSq = maxSize * maxSize;
    _ref = Body.pool.register;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      body = _ref[_i];
      if (!(body.enabled && !body.fixed)) {
        continue;
      }
      pos2 = body.transform.pos;
      distSq = Vec2.distSq(pos, pos2);
      if (distSq < maxSizeSq) {
        factor = 1 - Math.sqrt(distSq) / maxSize;
        body.applyForce(Vec2.norm(Vec2.sub(pos2, pos, Vec2.cache[0]), null, Math.quadIn(factor) * impulse));
      }
    }
    return this;
    for (i = _j = 0; _j <= 10; i = ++_j) {
      Spark.Prefab.alloc(this.root, {
        transform: {
          pos: pos
        },
        b2Body: {
          velocity: Vec2(Math.rand(-100, 100), Math.rand(-100, 100))
        }
      });
    }
    return this;
  };

  Explosion.prototype.render = function(ctx) {
    var circles, factor, i, pos, _i;
    ctx.save();
    pos = this.pos;
    circles = 10;
    for (i = _i = 1; _i <= circles; i = _i += 1) {
      factor = Math.quadOut(i / circles);
      ctx.beginPath();
      ctx.arc(pos[0] | 0, pos[1] | 0, this.size * factor | 0, 0, Math.TAU, true);
      ctx.closePath();
      this.color[3] = factor * (1 - this.factor);
      ctx.lineWidth = 10 * factor;
      ctx.strokeStyle = Color.rgba(this.color);
      ctx.stroke();
    }
    ctx.restore();
    return this;
  };

  return Explosion;

})(Component);

new Pool(Explosion);

Explosion.Prefab = new Entity.Prefab({
  transform: null,
  explosion: null
});

Spark = (function(_super) {

  __extends(Spark, _super);

  Spark.prototype.tag = 'spark';

  function Spark() {
    this.lastPos = Vec2();
  }

  Spark.prototype.instantiate = function() {
    Vec2.copy(this.lastPos, this.transform.pos);
    this.lifetime = 2.5;
    this.age = 0;
    return this;
  };

  Spark.prototype.update = function(dt) {
    var age;
    age = (this.age += dt);
    if (age >= this.lifetime) {
      this.entity.destroy();
    }
    return this;
  };

  Spark.prototype.render = function(ctx) {
    var pos;
    pos = this.transform.pos;
    ctx.save();
    ctx.strokeStyle = Color.rgba(Color.white);
    ctx.beginPath();
    ctx.moveTo(this.lastPos[0] | 0, this.lastPos[1] | 0);
    ctx.lineTo(pos[0] | 0, pos[1] | 0);
    ctx.stroke();
    ctx.restore();
    Vec2.copy(this.lastPos, pos);
    return this;
  };

  return Spark;

})(Component);

new Pool(Spark);

Spark.Prefab = new Entity.Prefab({
  transform: null,
  bounds: {
    shape: 'circle',
    radius: 0.1
  },
  spark: null,
  b2Body: {
    restitution: 1,
    density: 0.1,
    friction: 0
  },
  border: {
    kill: true
  }
});

Engine.gameScene = Entity.alloc(null, {
  gameController: null
});

Engine.debug.stats = true;

Engine.play(Engine.gameScene);
