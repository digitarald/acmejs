(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process','global'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return window.setImmediate;\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/lib/math.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.3.3\nvar Mat, Vec2, abs, epsilon, fn, i, pow, powIn, radCache, random, sqrt, toInOut, toOut, transition, typedArray, _i, _len, _ref;\n\nMat = Math;\n\nMat.epsilon = 0.001;\n\nsqrt = Mat.sqrt, pow = Mat.pow, abs = Mat.abs, random = Mat.random, epsilon = Mat.epsilon;\n\nMat.TypedArray = typedArray = Float64Array || Float32Array || function(arr) {\n  return arr;\n};\n\nVec2 = function(fromOrX, y) {\n  if (y != null) {\n    return new typedArray([fromOrX, y]);\n  }\n  if (fromOrX != null) {\n    return new typedArray(fromOrX);\n  }\n  return new typedArray(Vec2.zero);\n};\n\nVec2.zero = Vec2.center = Vec2(0, 0);\n\nVec2.cache = [Vec2(), Vec2(), Vec2(), Vec2(), Vec2()];\n\nVec2.topLeft = Vec2(1, -1);\n\nVec2.topCenter = Vec2(0, -1);\n\nVec2.topRight = Vec2(-1, -1);\n\nVec2.centerLeft = Vec2(1, 0);\n\nVec2.centerRight = Vec2(-1, 0);\n\nVec2.bottomLeft = Vec2(1, 1);\n\nVec2.bottomCenter = Vec2(0, 1);\n\nVec2.bottomRight = Vec2(-1, 1);\n\nradCache = [Vec2(), Vec2()];\n\nVec2.set = function(result, x, y) {\n  result[0] = x || 0;\n  result[1] = y || 0;\n  return result;\n};\n\nVec2.copy = function(result, b) {\n  result[0] = b[0];\n  result[1] = b[1];\n  return result;\n};\n\nVec2.valid = function(a) {\n  return !(isNaN(a[0]) || isNaN(a[0]));\n};\n\nVec2.eq = function(a, b) {\n  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;\n};\n\nVec2.add = function(a, b, result) {\n  result || (result = a);\n  result[0] = a[0] + b[0];\n  result[1] = a[1] + b[1];\n  return result;\n};\n\nVec2.sub = function(a, b, result) {\n  result || (result = a);\n  result[0] = a[0] - b[0];\n  result[1] = a[1] - b[1];\n  return result;\n};\n\nVec2.mul = function(a, b, result) {\n  result || (result = a);\n  result[0] = a[0] * b[0];\n  result[1] = a[1] * b[1];\n  return result;\n};\n\nVec2.scal = function(a, scalar, result) {\n  result || (result = a);\n  result[0] = a[0] * scalar;\n  result[1] = a[1] * scalar;\n  return result;\n};\n\nVec2.norm = function(a, result, scalar) {\n  var len, x, y;\n  if (scalar == null) {\n    scalar = 1;\n  }\n  result || (result = a);\n  x = a[0];\n  y = a[1];\n  len = scalar / (sqrt(x * x + y * y) || 1);\n  result[0] = x * len;\n  result[1] = y * len;\n  return result;\n};\n\nVec2.lenSq = function(a) {\n  return a[0] * a[0] + a[1] * a[1];\n};\n\nVec2.len = function(a) {\n  return sqrt(a[0] * a[0] + a[1] * a[1]);\n};\n\nVec2.dot = function(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n};\n\nVec2.cross = function(a, b) {\n  return a[0] * b[1] - a[1] * b[0];\n};\n\nVec2.lerp = function(a, b, scalar, result) {\n  result || (result = a);\n  result[0] = a[0] + scalar * (b[0] - a[0]);\n  result[1] = a[1] + scalar * (b[1] - a[1]);\n  return result;\n};\n\nVec2.perp = function(a, result) {\n  var x;\n  result || (result = a);\n  x = a[0];\n  result[0] = a[1];\n  result[1] = -x;\n  return result;\n};\n\nVec2.dist = function(a, b) {\n  var x, y;\n  x = b[0] - a[0];\n  y = b[1] - a[1];\n  return sqrt(x * x + y * y);\n};\n\nVec2.distSq = function(a, b) {\n  var x, y;\n  x = b[0] - a[0];\n  y = b[1] - a[1];\n  return x * x + y * y;\n};\n\nVec2.limit = function(a, max, result) {\n  var ratio, x, y;\n  result || (result = a);\n  x = a[0];\n  y = a[1];\n  if ((ratio = max / sqrt(x * x + y * y)) < 1) {\n    result[0] = x * ratio;\n    result[1] = y * ratio;\n  } else if (result !== a) {\n    result[0] = x;\n    result[1] = y;\n  }\n  return result;\n};\n\nVec2.rad = function(a, b) {\n  if (!b) {\n    return Mat.atan2(a[1], a[0]);\n  }\n  return Mat.acos(Vec2.dot(Vec2.norm(a, radCache[0]), Vec2.norm(b, radCache[1])));\n};\n\nVec2.rot = function(a, theta, result) {\n  var cosA, sinA, x, y;\n  result || (result = a);\n  sinA = Mat.sin(theta);\n  cosA = Mat.cos(theta);\n  x = a[0];\n  y = a[1];\n  result[0] = x * cosA - y * sinA;\n  result[1] = x * sinA + y * cosA;\n  return result;\n};\n\nVec2.lookAt = function(a, b, result) {\n  var len;\n  result || (result = a);\n  len = Vec2.len(a);\n  return Vec2.norm(Vec2.rot(a, Mat.atan2(b[0] - a[0], b[1] - a[1]) - Mat.atan2(a[1], a[0]), result), null, len);\n};\n\nrandom = Mat.random, pow = Mat.pow;\n\nMat.TAU = Mat.PI * 2;\n\nMat.UID = 1;\n\nMat.uid = function() {\n  return Mat.UID++;\n};\n\nMat.clamp = function(a, low, high) {\n  if (a < low) {\n    return low;\n  }\n  if (a > high) {\n    return high;\n  } else {\n    return a;\n  }\n};\n\nMat.rand = function(low, high, ease) {\n  return low + (ease || Mat.linear)(random()) * (high - low + 1);\n};\n\nMat.chance = function(chance) {\n  return random() <= chance;\n};\n\npowIn = function(strength) {\n  if (strength == null) {\n    strength = 2;\n  }\n  return function(t) {\n    return pow(t, strength);\n  };\n};\n\ntoOut = function(fn) {\n  return function(t) {\n    return 1 - fn(1 - t);\n  };\n};\n\ntoInOut = function(fn) {\n  return function(t) {\n    return (t < 0.5 ? fn(t * 2) : 2 - fn(2 * (1 - t))) / 2;\n  };\n};\n\nMat.linear = function(t) {\n  return t;\n};\n\n_ref = ['quad', 'cubic', 'quart', 'quint'];\nfor (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n  transition = _ref[i];\n  Mat[transition + 'In'] = fn = powIn(i + 2);\n  Mat[transition + 'Out'] = toOut(fn);\n  Mat[transition + 'InOut'] = toInOut(fn);\n}\n\nmodule.exports.Vec2 = Vec2;\n\n//@ sourceURL=/lib/math.js"
));

require.define("/lib/engine.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.3.3\nvar Composite, Engine, Pool, Vec2, requestAnimationFrame,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComposite = require('./composite');\n\nPool = require('./pool');\n\nVec2 = require('./math').Vec2;\n\nEngine = (function(_super) {\n\n  __extends(Engine, _super);\n\n  function Engine() {\n    return Engine.__super__.constructor.apply(this, arguments);\n  }\n\n  Engine.prototype.type = 'engine';\n\n  Engine.prototype.init = function(element) {\n    var Input,\n      _this = this;\n    this.element = element;\n    this.time = 0.0;\n    this.frame = 0;\n    this.tail = 0.0;\n    this.debug = false;\n    this.fdt = 1 / 60;\n    this.dtCap = 0.5;\n    this.fdtCap = this.fdt * 5;\n    this.scale = 1;\n    this.fps = 1 / 60;\n    Input = require('./input');\n    Input.alloc(this);\n    this.tickBound = function(now) {\n      return _this.tick(now);\n    };\n    this.element.addEventListener('dblclick', function() {\n      if ('webkitRequestFullScreen' in _this.element) {\n        return _this.element.webkitRequestFullScreen();\n      } else if ('mozRequestFullScreen' in _this.element) {\n        return _this.element.mozRequestFullScreen();\n      }\n    }, false);\n    return this;\n  };\n\n  Engine.prototype.play = function(scene) {\n    this.scene = scene;\n    this.input.root = this.scene;\n    if (!this.running) {\n      return this.start();\n    }\n  };\n\n  Engine.prototype.start = function() {\n    this.running = true;\n    requestAnimationFrame(this.tickBound);\n    return this;\n  };\n\n  Engine.prototype.tick = function(now) {\n    var dt;\n    now = (now && now > 1e12 ? now : Date.now()) / 1000;\n    if (this.lastTime) {\n      if ((dt = now - this.lastTime) > 0.5) {\n        dt = this.fdt;\n      } else if (dt) {\n        this.fps = this.fps * 0.9 + 0.1 / dt;\n      }\n      this.dt = (dt *= this.scale);\n      this.time += dt;\n      this.frame++;\n      this.update(dt);\n      if (this.debug) {\n        debugger;\n      }\n    } else {\n      this.time = now;\n    }\n    this.lastTime = now;\n    if (this.running) {\n      requestAnimationFrame(this.tickBound);\n    }\n    return this;\n  };\n\n  Engine.prototype.update = function(dt) {\n    var ctx, fdt, tail;\n    ctx = this.renderer.save();\n    tail = Math.min(this.tail + dt, this.fdtCap * this.scale);\n    fdt = this.fdt;\n    while (tail > fdt) {\n      tail -= fdt;\n      Pool.invoke('fixedUpdate', fdt);\n      Pool.invoke('simulate', fdt);\n    }\n    this.tail = tail;\n    Pool.invoke('update', dt);\n    Pool.invoke('lateUpdate', dt);\n    Pool.invoke('render', ctx, dt);\n    ctx.fillStyle = 'black';\n    ctx.strokeStyle = 'white';\n    ctx.font = '11px sans-serif';\n    ctx.lineWidth = 3;\n    ctx.strokeText(this.fps | 0, 0, 11);\n    ctx.fillText(this.fps | 0, 0, 11);\n    return this.renderer.restore();\n  };\n\n  return Engine;\n\n})(Composite);\n\nrequestAnimationFrame = (function() {\n  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {\n    return setTimeout(callback, 20);\n  };\n})();\n\nmodule.exports = new Engine();\n\n//@ sourceURL=/lib/engine.js"
));

require.define("/lib/composite.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.3.3\nvar Composite, Pool;\n\nPool = require('./pool');\n\nComposite = (function() {\n\n  function Composite() {\n    this.children = {};\n    this.components = {};\n  }\n\n  Composite.prototype.toString = function() {\n    return \"Composite \" + (this.name || this.type) + \"#\" + this.uid;\n  };\n\n  Composite.prototype.alloc = function(presets) {\n    var child, pool, preset, type, _i, _len;\n    if (this.parent) {\n      this.parent.children[this.uid] = this;\n    }\n    if (presets) {\n      for (type in presets) {\n        preset = presets[type];\n        switch (type) {\n          case 'children':\n            for (_i = 0, _len = preset.length; _i < _len; _i++) {\n              child = preset[_i];\n              Composite.alloc(this, child);\n            }\n            break;\n          case 'name':\n            this.name = presets[type];\n            break;\n          default:\n            if ((pool = Pool.types[type])) {\n              pool.alloc(this, preset);\n            }\n        }\n      }\n    }\n    return this;\n  };\n\n  Composite.prototype.free = function() {\n    var key, ref, refSubs, _i, _len;\n    if (refSubs = this.refSubs) {\n      for (_i = 0, _len = refSubs.length; _i < _len; _i++) {\n        ref = refSubs[_i];\n        ref.unsub(this);\n      }\n    }\n    this.refSubs = this.subs = null;\n    for (key in this.components) {\n      this.components[key].free();\n    }\n    for (key in this.children) {\n      this.children[key].free();\n    }\n    if (this.parent) {\n      delete this.parent.children[this.uid];\n    }\n    this.pool.free(this);\n    return this;\n  };\n\n  Composite.prototype.enable = function(state, deep) {\n    var key;\n    this.enabled = state != null ? state : state = !this.state;\n    this.parent.pub('on' + (state ? 'Enable' : 'Disable'), this);\n    for (key in this.components) {\n      this.components[key].enable(state);\n    }\n    if (deep) {\n      for (key in this.children) {\n        this.children[key].enable(state, true);\n      }\n    }\n    return this;\n  };\n\n  Composite.prototype.sub = function(scope, topic, method) {\n    var items, refs, subs;\n    if (scope == null) {\n      scope = this;\n    }\n    subs = this.subs || (this.subs = {});\n    items = subs[topic] || (subs[topic] = []);\n    items.push(scope, method);\n    if (scope !== this) {\n      refs = scope.refSubs || (scope.refSubs = []);\n      if (!~refs.indexOf(this)) {\n        refs.push(this);\n      }\n    }\n    return this;\n  };\n\n  Composite.prototype.pub = function(topic, a0, a1, a2, a3) {\n    var i, items, scope;\n    if (this.subs && (items = this.subs[topic]) && (i = items.length)) {\n      while (scope = items[i -= 2]) {\n        scope[items[i + 1] || topic](a0, a1, a2, a3);\n      }\n    }\n    return this;\n  };\n\n  Composite.prototype.pubUp = function(topic, a0, a1, a2, a3) {\n    var comp;\n    comp = this;\n    while (comp) {\n      if (comp.pub(topic, a0, a1, a2, a3) === false) {\n        break;\n      }\n      comp = comp.parent;\n    }\n    return this;\n  };\n\n  Composite.prototype.pubAll = function(topic, a0, a1, a2, a3) {\n    return Pool.call(topic, a0, a1, a2, a3);\n  };\n\n  Composite.prototype.unsub = function(unscope, untopic) {\n    var i, items, length, scope, subs, topic;\n    if (subs = this.subs) {\n      for (topic in subs) {\n        items = subs[topic];\n        if (!((i = items.length) && (!untopic || untopic === topic))) {\n          continue;\n        }\n        length = i / 2;\n        while ((i -= 2) >= 0) {\n          if (scope = items[i]) {\n            if (unscope && scope !== unscope) {\n              continue;\n            } else {\n              items[i] = null;\n            }\n            length--;\n          }\n        }\n        if (!length) {\n          items.length = 0;\n        }\n      }\n    }\n    return this;\n  };\n\n  return Composite;\n\n})();\n\nnew Pool(Composite);\n\nComposite.Prefab = (function() {\n\n  function Prefab(presets) {\n    var key;\n    this.presets = presets;\n    for (key in presets) {\n      presets[key] = this.presets[key] || {};\n    }\n  }\n\n  Prefab.prototype.alloc = function(parent, presets) {\n    var defaults, key, subKey, subPresets, value;\n    if ((defaults = this.presets) && presets) {\n      for (key in defaults) {\n        value = defaults[key];\n        if (!(key in presets)) {\n          presets[key] = value;\n        } else {\n          subPresets = presets[key];\n          if (key === 'children') {\n            subPresets.unshift.apply(subPresets, value);\n          } else if (typeof value === 'object') {\n            for (subKey in value) {\n              if (!(subKey in subPresets)) {\n                subPresets[subKey] = value[subKey];\n              }\n            }\n          }\n          delete presets[key];\n          presets[key] = subPresets;\n        }\n      }\n    }\n    return Composite.alloc(parent, presets || defaults);\n  };\n\n  return Prefab;\n\n})();\n\nmodule.exports = Composite;\n\n//@ sourceURL=/lib/composite.js"
));

require.define("/lib/pool.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.3.3\nvar Pool, fn, _i, _len, _ref;\n\nrequire('./math');\n\nPool = (function() {\n\n  Pool.typedHooks = ['fixedUpdate', 'simulate', 'update', 'lateUpdate', 'render'];\n\n  Pool.hookRegx = /^on[A-Z]/;\n\n  Pool.hooks = {};\n\n  Pool.types = {};\n\n  Pool.defaults = {};\n\n  Pool.order = {\n    render: false\n  };\n\n  Pool.prototype.toString = function() {\n    return \"Pool {@type} [\" + this.roster.length + \"]\";\n  };\n\n  function Pool(cls) {\n    var fn, keys, proto, types, _i, _j, _len, _len1,\n      _this = this;\n    this.cls = cls;\n    proto = cls.prototype;\n    this.type = proto.type;\n    this.isComponent = this.type && this.type !== 'composite';\n    this.light = (!this.isComponent) || proto.light || false;\n    if (this.type) {\n      Pool.types[this.type] = this;\n    }\n    proto.pool = this;\n    cls.pool = this;\n    this.roster = [];\n    this.subs = [];\n    this.hooks = [];\n    this.enabled = false;\n    this.allocd = 0;\n    this.layer = proto.layer || cls.layer || 0;\n    if (this.isComponent && !this.light) {\n      types = Pool.typedHooks;\n      keys = Object.keys(proto).concat(Object.keys(cls));\n      for (_i = 0, _len = keys.length; _i < _len; _i++) {\n        fn = keys[_i];\n        if (Pool.hookRegx.test(fn)) {\n          if (!~types.indexOf(fn)) {\n            types.push(fn);\n            Pool.hooks[fn] = [];\n          }\n          this.subs.push(fn);\n        }\n      }\n      for (_j = 0, _len1 = types.length; _j < _len1; _j++) {\n        fn = types[_j];\n        if (fn in cls) {\n          this[fn] = cls[fn];\n          Pool.hooks[fn].push(this);\n        } else if (fn in proto) {\n          this.hooks.push(fn);\n        }\n      }\n    }\n    cls.alloc = function(parent, presets) {\n      return _this.alloc(parent, presets);\n    };\n  }\n\n  Pool.prototype.preinstantiate = function(i) {\n    while (i--) {\n      this.instantiate();\n    }\n    return this;\n  };\n\n  Pool.prototype.instantiate = function() {\n    var cls, hook, _i, _len, _ref;\n    cls = new this.cls();\n    this.roster.push(cls);\n    _ref = this.hooks;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      hook = _ref[_i];\n      Pool.hooks[hook].push(cls);\n    }\n    return cls;\n  };\n\n  Pool.prototype.alloc = function(parent, presets) {\n    var defaults, entity, hook, i, roster, topic, uid, _i, _j, _len, _len1, _ref, _ref1;\n    roster = this.roster;\n    i = roster.length;\n    while (i--) {\n      if (!roster[i].allocd) {\n        entity = roster[i];\n        break;\n      }\n    }\n    if (!entity) {\n      entity = this.instantiate();\n    }\n    this.allocd++;\n    this.enabled = true;\n    _ref = this.hooks;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      hook = _ref[_i];\n      if (hook in Pool.order) {\n        Pool.order[hook] = true;\n      }\n    }\n    entity.uid = uid = Math.uid();\n    entity.enabled = true;\n    entity.allocd = true;\n    entity.parent = parent || null;\n    entity.root = parent && parent.root || parent || entity;\n    entity.layer = (parent && parent.layer || 0) + this.layer + 2 - 1 / uid;\n    if (entity.root.descendants) {\n      entity.root.descendants[uid] = entity;\n    } else {\n      entity.descendants = {};\n    }\n    if (this.isComponent) {\n      if (defaults = entity.presets) {\n        if (presets && !presets._merged) {\n          presets.__proto__ = defaults;\n          presets._merged = true;\n        }\n      }\n      _ref1 = this.subs;\n      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n        topic = _ref1[_j];\n        parent.sub(entity, topic);\n      }\n    }\n    entity.alloc(presets || defaults || null);\n    return entity;\n  };\n\n  Pool.prototype.free = function(entity) {\n    if (entity.root === entity) {\n      entity.descendants = null;\n    } else if (entity.root.descendants) {\n      delete entity.root.descendants[entity.uid];\n    }\n    entity.enabled = false;\n    entity.allocd = false;\n    entity.uid = null;\n    entity.root = null;\n    entity.parent = null;\n    this.enabled = this.allocd-- > 1;\n    return this;\n  };\n\n  return Pool;\n\n})();\n\n_ref = Pool.typedHooks;\nfor (_i = 0, _len = _ref.length; _i < _len; _i++) {\n  fn = _ref[_i];\n  Pool.hooks[fn] = [];\n}\n\nPool.dump = function(free) {\n  var pool, type, _ref1;\n  _ref1 = Pool.types;\n  for (type in _ref1) {\n    pool = _ref1[type];\n    console.log(\"%s: %d/%d allocd\", type, pool.allocd, pool.roster.length);\n  }\n  if (free) {\n    Pool.free();\n  }\n  return null;\n};\n\nif ('console' in window) {\n  console.pool = Pool.dump;\n}\n\nPool.free = function() {\n  var freed, i, pool, roster, type, _ref1;\n  _ref1 = Pool.types;\n  for (type in _ref1) {\n    pool = _ref1[type];\n    roster = pool.roster;\n    i = roster.length;\n    freed = 0;\n    while (i--) {\n      if (!(!roster[i].allocd)) {\n        continue;\n      }\n      roster.splice(i, 1);\n      freed++;\n    }\n    console.log(\"%s: %d/%d freed\", type, freed, pool.roster.length);\n  }\n  return this;\n};\n\nPool.invoke = function(fn, a0, a1, a2, a3) {\n  var i, stack;\n  if ((stack = this.hooks[fn]) && (i = stack.length)) {\n    if (fn in Pool.order && Pool.order[fn]) {\n      stack.sort(Pool.orderFn);\n      Pool.order[fn] = false;\n    }\n    while (i--) {\n      if (stack[i].enabled) {\n        stack[i][fn](a0, a1, a2, a3);\n      }\n    }\n  }\n  return this;\n};\n\nPool.orderFn = function(a, b) {\n  return b.layer - a.layer;\n};\n\nmodule.exports = Pool;\n\n//@ sourceURL=/lib/pool.js"
));

require.define("/lib/input.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.3.3\nvar Component, Engine, Input, Pool, Vec2, pool,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComponent = require('./component');\n\nPool = require('./pool');\n\nVec2 = require('./math').Vec2;\n\nEngine = require('./engine');\n\nInput = (function(_super) {\n\n  __extends(Input, _super);\n\n  Input.prototype.type = 'input';\n\n  function Input() {\n    var code, key, type, _ref;\n    this.pos = Vec2();\n    this.touchState = null;\n    this.axis - Vec2();\n    this.prevPos = Vec2();\n    this.queue = [];\n    this.map = {\n      32: 'space',\n      192: 'debug'\n    };\n    this.keyNames = [];\n    this.keys = {};\n    _ref = this.map;\n    for (code in _ref) {\n      key = _ref[code];\n      if (!~this.keyNames.indexOf(key)) {\n        this.keyNames.push(key);\n        this.keys[key] = null;\n      }\n    }\n    this.throttled = {\n      mousemove: true,\n      touchmove: true\n    };\n    this.hasTouch = 'ontouchstart' in window;\n    this.events = this.hasTouch ? {\n      touchstart: 'startTouch',\n      touchmove: 'moveTouch',\n      touchend: 'endTouch',\n      touchcancel: 'endTouch'\n    } : {\n      mousedown: 'startTouch',\n      mousemove: 'moveTouch',\n      mouseup: 'endTouch',\n      keydown: 'keyStart',\n      keyup: 'keyEnd'\n    };\n    for (type in this.events) {\n      document.addEventListener(type, this, false);\n    }\n  }\n\n  Input.prototype.handleEvent = function(event) {\n    var type;\n    if (event.metaKey) {\n      return;\n    }\n    event.preventDefault();\n    type = event.type;\n    if (this.throttled[type] && this.queued === type) {\n      this.queue[this.queue.length - 1] = event;\n    } else {\n      this.queued = type;\n      this.queue.push(event);\n    }\n    return true;\n  };\n\n  Input.prototype.keyStart = function(event) {\n    var key;\n    if ((key = this.map[event.keyCode]) && !this.keys[key]) {\n      this.keys[key] = 'began';\n      Engine.pub('onKeyBegan', key);\n    }\n    return this;\n  };\n\n  Input.prototype.keyEnd = function(event) {\n    var key;\n    if (key = this.map[event.keyCode]) {\n      this.keys[key] = 'ended';\n      Engine.pub('onKeyEnded', key);\n    }\n    return this;\n  };\n\n  Input.prototype.startTouch = function(event) {\n    this.resolve(event);\n    if (!this.touchState && !event.metaKey) {\n      this.touchState = 'began';\n    }\n    return this;\n  };\n\n  Input.prototype.moveTouch = function(event) {\n    var state;\n    this.resolve(event);\n    state = this.touchState;\n    if (state && state !== 'ended' && state !== 'moved') {\n      this.touchState = 'moved';\n    }\n    return this;\n  };\n\n  Input.prototype.endTouch = function(event) {\n    this.resolve(event);\n    if (this.touchState && (!this.hasTouch || !event.targetTouches.length)) {\n      this.touchState = 'ended';\n    }\n    return this;\n  };\n\n  Input.prototype.resolve = function(event) {\n    var coords, renderer;\n    coords = this.hasTouch ? event.targetTouches[0] : event;\n    if (coords) {\n      this.prevTime = this.time;\n      this.time = event.timeStamp / 1000;\n      Vec2.copy(this.prevPos, this.pos);\n      renderer = Engine.renderer;\n      Vec2.set(this.pos, (coords.pageX - renderer.margin[0]) / renderer.scale | 0, (coords.pageY - renderer.margin[1]) / renderer.scale | 0);\n    }\n    return this;\n  };\n\n  Input.prototype.lateUpdate = function(dt, scene) {\n    var event, key, keys, _i, _len, _ref;\n    switch (this.touchState) {\n      case 'began':\n        this.touchState = 'stationary';\n        break;\n      case 'ended':\n        this.touchState = null;\n        break;\n    }\n    keys = this.keys;\n    _ref = this.keyNames;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      key = _ref[_i];\n      switch (keys[key]) {\n        case 'began':\n          keys[key] = 'pressed';\n          Engine.pub('onKeyPressed', key);\n          break;\n        case 'ended':\n          keys[key] = null;\n          break;\n      }\n    }\n    event = this.queue.shift();\n    if (event) {\n      this[this.events[event.type]](event);\n    }\n    this.queued = null;\n    return this;\n  };\n\n  return Input;\n\n})(Component);\n\npool = new Pool(Input);\n\nmodule.exports = Input;\n\n//@ sourceURL=/lib/input.js"
));

require.define("/lib/component.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.3.3\nvar Component;\n\nrequire('./math');\n\nComponent = (function() {\n\n  function Component() {}\n\n  Component.prototype.type = 'component';\n\n  Component.prototype.toString = function() {\n    return \"Component \" + this.type + \"#\" + this.uid + \" [\" + this.parent + \"]\";\n  };\n\n  Component.prototype.alloc = function(presets) {\n    var component, components, type;\n    this.parent.components[this.type] = this;\n    this.parent[this.type] = this;\n    components = this.parent.components;\n    for (type in components) {\n      this[type] = component = components[type];\n      component[this.type] = this;\n    }\n    if (this.reset) {\n      this.reset(presets);\n    }\n    return this;\n  };\n\n  Component.prototype.free = function() {\n    var components, type;\n    delete this.parent.components[this.type];\n    this.parent[this.type] = null;\n    components = this.parent.components;\n    for (type in components) {\n      this[components[type].type] = null;\n      components[type][this.type] = null;\n    }\n    this.pool.free(this);\n    return this;\n  };\n\n  Component.prototype.enable = function(state) {\n    this.enabled = state != null ? state : state = !this.state;\n    this.parent.pub('onComponent' + (state ? 'Enable' : 'Disable'), this);\n    return this;\n  };\n\n  Component.prototype.sub = function(scope, topic, method) {\n    if (scope == null) {\n      scope = this;\n    }\n    this.parent.sub(scope, topic, method);\n    return this;\n  };\n\n  return Component;\n\n})();\n\nmodule.exports = Component;\n\n//@ sourceURL=/lib/component.js"
));

require.define("/lib/renderer.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.3.3\nvar Bounds, Composite, Renderer, Vec2,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComposite = require('./composite');\n\nBounds = require('./bounds');\n\nVec2 = require('./math').Vec2;\n\nRenderer = (function(_super) {\n\n  __extends(Renderer, _super);\n\n  function Renderer(element, client) {\n    this.element = element;\n    this.client = Vec2(client);\n    this.content = Vec2(client);\n    this.canvas = document.createElement('canvas');\n    this.element.appendChild(this.canvas);\n    this.ctx = this.canvas.getContext('2d');\n    this.browser = Vec2();\n    this.margin = Vec2();\n    this.pos = Vec2();\n    this.scale = 0;\n    this.buf = document.createElement('canvas');\n    this.bufctx = this.buf.getContext('2d');\n    window.addEventListener('resize', this, false);\n    window.addEventListener('orientationchange', this, false);\n    this.reflow();\n  }\n\n  Renderer.prototype.handleEvent = function() {\n    return this.reflow();\n  };\n\n  Renderer.prototype.reflow = function() {\n    var scale;\n    Vec2.set(this.browser, window.innerWidth, window.innerHeight);\n    scale = Math.min(this.browser[0] / this.content[0], this.browser[1] / this.content[1]);\n    scale = Math.clamp((scale * 2 | 0) / 2, 0.5, 3);\n    if (scale !== this.scale) {\n      this.scale = scale;\n      Vec2.scal(this.content, this.scale, this.client);\n      this.buf.width = this.canvas.width = this.client[0];\n      this.buf.height = this.canvas.height = this.client[1];\n    }\n    return this.alignContainer();\n  };\n\n  Renderer.prototype.alignContainer = function() {\n    Vec2.scal(Vec2.sub(this.browser, this.client, this.margin), 0.5);\n    this.element.style.left = this.margin[0] + 'px';\n    this.element.style.top = this.margin[1] + 'px';\n    this.element.style.width = this.client[0] + 'px';\n    this.element.style.height = this.client[1] + 'px';\n    return this;\n  };\n\n  Renderer.prototype.save = function() {\n    this.bufctx.save();\n    this.bufctx.translate(this.pos[0] | 0, this.pos[1] | 0);\n    this.bufctx.clearRect(0, 0, this.client[0], this.client[1]);\n    this.bufctx.scale(this.scale, this.scale);\n    return this.bufctx;\n  };\n\n  Renderer.prototype.restore = function() {\n    this.bufctx.restore();\n    this.ctx.clearRect(0, 0, this.client[0], this.client[1]);\n    this.ctx.drawImage(this.buf, 0, 0);\n    return this;\n  };\n\n  Renderer.prototype.center = function(pos) {\n    Vec2.set(this.pos, pos[0] - this.client[0] / 2, pos[0] - this.client[1] / 2);\n    return this;\n  };\n\n  Renderer.prototype.cull = function(entity) {\n    var bounds;\n    if (!(bounds = entity.bounds)) {\n      return false;\n    }\n    if (bounds.withinRect(this.pos, this.content)) {\n      if (bounds.culled) {\n        bounds.culled = false;\n      }\n      return false;\n    }\n    if (!bounds.culled) {\n      bounds.culled = true;\n    }\n    return true;\n  };\n\n  return Renderer;\n\n})(Composite);\n\nmodule.exports = Renderer;\n\n//@ sourceURL=/lib/renderer.js"
));

require.define("/lib/bounds.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.3.3\nvar Bounds, Component, Pool, Vec2,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComponent = require('./component');\n\nPool = require('./pool');\n\nVec2 = require('./math').Vec2;\n\nBounds = (function(_super) {\n\n  __extends(Bounds, _super);\n\n  Bounds.prototype.type = 'bounds';\n\n  Bounds.prototype.presets = {\n    shape: 'rect',\n    radius: 0,\n    size: Vec2()\n  };\n\n  function Bounds() {\n    this.size = Vec2();\n  }\n\n  Bounds.prototype.reset = function(presets) {\n    Vec2.copy(this.size, presets.size);\n    this.shape = presets.shape;\n    this.radius = presets.radius;\n    return this;\n  };\n\n  Bounds.prototype.intersectLine = function(p1, p2) {\n    return null;\n  };\n\n  Bounds.prototype.intersect = function(bound) {\n    return null;\n  };\n\n  Bounds.prototype.contains = function(point) {\n    var pos;\n    pos = this.parent.transform.pos;\n    switch (this.shape) {\n      case 'circle':\n        return Bounds.circPoint(pos, this.radius, point);\n      case 'rect':\n        return Bounds.rectPoint(pos, this.size, point);\n    }\n    return false;\n  };\n\n  Bounds.prototype.withinRect = function(pos, size) {\n    var mypos;\n    mypos = this.parent.transform.pos;\n    switch (this.shape) {\n      case 'circle':\n        return Bounds.rectCirc(pos, size, mypos, this.radius);\n      case 'rect':\n        return Bounds.rectRect(pos, size, mypos, this.size);\n    }\n    return false;\n  };\n\n  return Bounds;\n\n})(Component);\n\nBounds.circPoint = function(center, radius, point) {\n  return Vec2.distSq(point, center) <= radius * radius;\n};\n\nBounds.rectPoint = function(pos, size, point) {\n  return pos[0] < point[0] && pos[1] < point[1] && pos[0] + size[0] > point[0] && pos[1] + size[1] > point[1];\n};\n\nBounds.rectCirc = function(topLeft, size, center, radius) {\n  var circleDistanceX, circleDistanceY, cornerDistance;\n  circleDistanceX = Math.abs(center[0] - topLeft[0] - size[0] / 2);\n  circleDistanceY = Math.abs(center[1] - topLeft[1] - size[1] / 2);\n  if (circleDistanceX > (size[0] / 2 + radius) || circleDistanceY > (size[1] / 2 + radius)) {\n    return false;\n  }\n  if (circleDistanceX <= size[0] / 2 || circleDistanceY <= size[1] / 2) {\n    return true;\n  }\n  cornerDistance = Math.pow(circleDistanceX - size[0] / 2, 2) + Math.pow(circleDistanceY - size[1] / 2, 2);\n  return cornerDistance <= Math.pow(radius, 2);\n};\n\nBounds.rectRect = function(pos, size, pos2, size2) {\n  return !(pos[0] > pos2[0] + size2[0] || pos[0] + size[0] < pos2[0] || pos[1] > pos2[1] + size2[1] || pos[1] + size[1] < pos2[1]);\n};\n\nBounds.lineRect = function(point1, point2, topLeft, size) {\n  var botOverlap, bottomIntersection, bottomPoint, c, m, topIntersection, topOverlap, topPoint, _ref, _ref1;\n  this.topLeft = topLeft;\n  this.size = size;\n  m = (y2 - y1) / (x2 - x1);\n  c = y1(-(m * x1));\n  if (m > 0) {\n    topIntersection = m * rx + c;\n    bottomIntersection = m * (rx + rw) + c;\n  } else {\n    topIntersection = m * (rx + rw) + c;\n    bottomIntersection = m * rx + c;\n  }\n  if (y1 < y2) {\n    topPoint = y1;\n    bottomPoint = y2;\n  } else {\n    topPoint = y2;\n    bottomPoint = y1;\n  }\n  topOverlap = (_ref = topIntersection > topPoint) != null ? _ref : {\n    topIntersection: topPoint\n  };\n  botOverlap = (_ref1 = bottomIntersection < bottomPoint) != null ? _ref1 : {\n    bottomIntersection: bottomPoint\n  };\n  return (topOverlap < botOverlap) && (!((botOverlap < ry) || (topOverlap > ry + rh)));\n};\n\nBounds.lineCirc = function(point1, point2, center, radius) {\n  var a, b, bb4ac, c, dx, dy, ix1, ix2, iy1, iy2, mu, testX, testY;\n  dx = x2 - x1;\n  dy = y2 - y1;\n  a = dx * dx + dy * dy;\n  b = 2 * (dx * (x1 - cx) + dy * (y1 - cy));\n  c = cx * cx + cy * cy;\n  c += x1 * x1 + y1 * y1;\n  c -= 2 * (cx * x1 + cy * y1);\n  c -= cr * cr;\n  bb4ac = b * b - 4 * a * c;\n  if (bb4ac < 0) {\n    return false;\n  }\n  mu = (-b + sqrt(b * b - 4 * a * c)) / (2 * a);\n  ix1 = x1 + mu * dx;\n  iy1 = y1 + mu * dy;\n  mu = (-b - sqrt(b * b - 4 * a * c)) / (2 * a);\n  ix2 = x1 + mu * dx;\n  iy2 = y1 + mu * dy;\n  if (dist(x1, y1, cx, cy) < dist(x2, y2, cx, cy)) {\n    testX = x2;\n    testY = y2;\n  } else {\n    testX = x1;\n    testY = y1;\n  }\n  if (dist(testX, testY, ix1, iy1) < dist(x1, y1, x2, y2) || dist(testX, testY, ix2, iy2) < dist(x1, y1, x2, y2)) {\n    return true;\n  }\n  return false;\n};\n\nnew Pool(Bounds);\n\nmodule.exports = Bounds;\n\n//@ sourceURL=/lib/bounds.js"
));

require.define("/lib/color.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.3.3\nvar Color, typedArray;\n\nrequire('./math');\n\ntypedArray = Math.TypedArray;\n\nColor = function(fromOrR, g, b, a) {\n  var _ref;\n  if (g != null) {\n    return new typedArray([fromOrR, g, b, a != null ? a : 1]);\n  }\n  if (fromOrR != null) {\n    return new typedArray([fromOrR[0], fromOrR[1], fromOrR[2], (_ref = fromOrR[3]) != null ? _ref : 1]);\n  }\n  return new typedArray(Color.black);\n};\n\nColor.white = Color(255, 255, 255);\n\nColor.black = Color(0, 0, 0);\n\nColor.cache = [Color(), Color(), Color(), Color()];\n\nColor.set = function(result, r, g, b, a) {\n  result[0] = r || 0;\n  result[1] = g || 0;\n  result[2] = b || 0;\n  result[3] = a || 0;\n  return result;\n};\n\nColor.copy = function(result, b) {\n  result[0] = b[0];\n  result[1] = b[1];\n  result[2] = b[2];\n  result[3] = b[3];\n  return result;\n};\n\nColor.lerp = function(a, b, t, alpha, result) {\n  result || (result = a);\n  result[0] = t * a[0] + (1 - t) * b[0];\n  result[1] = t * a[1] + (1 - t) * b[1];\n  result[2] = t * a[2] + (1 - t) * b[2];\n  if (alpha > 0.05) {\n    result[3] = t * a[3] + (1 - t) * b[3];\n  } else {\n    result[3] = a[3];\n  }\n  return result;\n};\n\nColor.rgba = function(a) {\n  if (a[3] > 0.98) {\n    return \"rgb(\" + (a[0] | 0) + \", \" + (a[1] | 0) + \", \" + (a[2] | 0) + \")\";\n  } else {\n    return \"rgba(\" + (a[0] | 0) + \", \" + (a[1] | 0) + \", \" + (a[2] | 0) + \", \" + a[3] + \")\";\n  }\n};\n\nmodule.exports = Color;\n\n//@ sourceURL=/lib/color.js"
));

require.define("/lib/sprite.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.3.3\nvar Component, Pool, SpriteAsset, SpriteTween, Vec2,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nVec2 = require('./math').Vec2;\n\nComponent = require('./component');\n\nPool = require('./pool');\n\nSpriteAsset = (function() {\n\n  function SpriteAsset(srcOrRepaint, size, baseScale) {\n    var img,\n      _this = this;\n    this.baseScale = baseScale != null ? baseScale : 1;\n    this.size = Vec2(size);\n    this.bufferSize = Vec2(size);\n    this.defaultOffset = Vec2();\n    this.defaultMargin = Vec2();\n    this.buffer = document.createElement('canvas');\n    this.bufferCtx = this.buffer.getContext('2d');\n    this.scale = 1;\n    switch (typeof srcOrRepaint) {\n      case 'string':\n        this.img = img = new Image();\n        img.onload = function() {\n          if (!img.onload) {\n            return;\n          }\n          img.onload = null;\n          Vec2.set(_this.size, img.width, img.height);\n          return _this.refresh();\n        };\n        img.src = srcOrRepaint;\n        if (img.onload && img.width && img.height) {\n          img.onload();\n        }\n        break;\n      case 'function':\n        this.repaint = srcOrRepaint;\n        this.refresh();\n        break;\n    }\n  }\n\n  SpriteAsset.prototype.draw = function(ctx, pos, crop, offset) {\n    if (pos == null) {\n      pos = this.defaultOffset;\n    }\n    if (crop == null) {\n      crop = this.bufferSize;\n    }\n    if (offset == null) {\n      offset = this.defaultMargin;\n    }\n    if (this.ready) {\n      ctx.drawImage(this.buffer, offset[0] | 0, offset[1] | 0, crop[0], crop[1], pos[0] | 0, pos[1] | 0, crop[0], crop[1]);\n    }\n    return this;\n  };\n\n  SpriteAsset.prototype.repaint = function() {\n    var size;\n    size = this.size;\n    this.buffer.width = size[0];\n    this.buffer.height = size[1];\n    this.bufferCtx.drawImage(this.img, 0, 0, size[0], size[1]);\n    this.sample();\n    return this;\n  };\n\n  SpriteAsset.prototype.sample = function() {\n    var bufferCtx, data, i, scale, size, x, y, _i, _j, _ref, _ref1;\n    scale = this.scale, size = this.size, bufferCtx = this.bufferCtx;\n    data = bufferCtx.getImageData(0, 0, size[0], size[1]).data;\n    this.buffer.width = this.bufferSize[0];\n    this.buffer.height = this.bufferSize[1];\n    for (x = _i = 0, _ref = size[0]; _i <= _ref; x = _i += 1) {\n      for (y = _j = 0, _ref1 = size[1]; _j <= _ref1; y = _j += 1) {\n        i = (y * size[0] + x) * 4;\n        bufferCtx.fillStyle = \"rgba(\" + data[i] + \", \" + data[i + 1] + \", \" + data[i + 2] + \", \" + (data[i + 3] / 255) + \")\";\n        bufferCtx.fillRect(x * scale, y * scale, scale, scale);\n      }\n    }\n    return this;\n  };\n\n  SpriteAsset.prototype.refresh = function(scale) {\n    scale = (scale || 1) * this.baseScale;\n    if (!this.ready || this.scale !== scale) {\n      this.scale = scale;\n      this.buffer.width = this.bufferSize[0] = this.size[0] * scale | 0;\n      this.buffer.height = this.bufferSize[1] = this.size[1] * scale | 0;\n      Vec2.scal(this.bufferSize, -0.5, this.defaultOffset);\n      this.repaint(this.bufferCtx, scale);\n      this.ready = true;\n    }\n    return this;\n  };\n\n  return SpriteAsset;\n\n})();\n\nSpriteTween = (function(_super) {\n\n  __extends(SpriteTween, _super);\n\n  function SpriteTween() {\n    return SpriteTween.__super__.constructor.apply(this, arguments);\n  }\n\n  SpriteTween.prototype.type = 'spriteTween';\n\n  SpriteTween.prototype.presets = {\n    align: Vec2.center\n  };\n\n  SpriteTween.prototype.reset = function(presets) {\n    this.align = presets.align, this.asset = presets.asset;\n    return this;\n  };\n\n  SpriteTween.prototype.render = function(ctx) {\n    if (!this.asset.ready) {\n      return this;\n    }\n    ctx.save();\n    this.parent.transform.transform(ctx);\n    this.asset.draw(ctx);\n    ctx.restore();\n    return this;\n  };\n\n  return SpriteTween;\n\n})(Component);\n\nnew Pool(SpriteTween);\n\nmodule.exports.Asset = SpriteAsset;\n\nmodule.exports.Tween = SpriteTween;\n\n//@ sourceURL=/lib/sprite.js"
));

require.define("/lib/transform.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.3.3\nvar Component, Pool, Transform, Vec2,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComponent = require('./component');\n\nPool = require('./pool');\n\nVec2 = require('./math').Vec2;\n\nTransform = (function(_super) {\n\n  __extends(Transform, _super);\n\n  Transform.prototype.type = 'transform';\n\n  Transform.prototype.presets = {\n    pos: Vec2()\n  };\n\n  function Transform() {\n    this.pos = Vec2();\n  }\n\n  Transform.prototype.reset = function(presets) {\n    Vec2.copy(this.pos, presets.pos);\n    return this;\n  };\n\n  Transform.prototype.toWorld = function() {\n    this.worldPos.copy(this.pos);\n    this.worldAngle = this.angle;\n    return this;\n  };\n\n  Transform.prototype.transform = function(ctx) {\n    ctx.translate(this.pos[0] | 0, this.pos[1] | 0);\n    return this;\n  };\n\n  return Transform;\n\n})(Component);\n\nnew Pool(Transform);\n\nmodule.exports = Transform;\n\n//@ sourceURL=/lib/transform.js"
));

require.define("/lib/kinetic.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.3.3\nvar Component, Force, Kinetic, Pool, Vec2, addForce,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComponent = require('./component');\n\nPool = require('./pool');\n\nForce = require('./force');\n\nVec2 = require('./math').Vec2;\n\naddForce = Vec2();\n\nKinetic = (function(_super) {\n\n  __extends(Kinetic, _super);\n\n  Kinetic.prototype.type = 'kinetic';\n\n  Kinetic.gravity = null;\n\n  Kinetic.friction = 15;\n\n  Kinetic.drag = 0.999;\n\n  Kinetic.prototype.presets = {\n    mass: 0,\n    drag: Kinetic.drag,\n    friction: Kinetic.friction,\n    fixed: false,\n    maxVel: 75,\n    maxAcc: 2000,\n    acc: Vec2(),\n    vel: Vec2()\n  };\n\n  function Kinetic() {\n    this.vel = Vec2();\n    this.acc = Vec2();\n    this.sleepVelSq = 0.2;\n  }\n\n  Kinetic.prototype.reset = function(presets) {\n    this.mass = presets.mass, this.drag = presets.drag, this.friction = presets.friction, this.fixed = presets.fixed, this.maxVel = presets.maxVel, this.maxAcc = presets.maxAcc;\n    Vec2.copy(this.vel, presets.vel);\n    Vec2.copy(this.acc, presets.acc);\n    this.pos = this.transform.pos;\n    this.sleeping = false;\n    return this;\n  };\n\n  Kinetic.prototype.applyForce = function(acc, ignoreMass, constant) {\n    if (!ignoreMass && this.mass) {\n      Vec2.scal(acc, 1 / this.mass, addForce);\n    } else {\n      Vec2.copy(addForce, acc);\n    }\n    if (constant && !this.force) {\n      Force.alloc(this);\n    }\n    Vec2.add((constant ? this.force.force : this.acc), addForce);\n    return this;\n  };\n\n  return Kinetic;\n\n})(Component);\n\nKinetic.simulate = function(dt) {\n  var acc, cache, copyVel, epsilon, kinetic, vel, _i, _len, _ref;\n  copyVel = Vec2.cache[0];\n  cache = Vec2.cache[1];\n  epsilon = Math.epsilon;\n  _ref = this.roster;\n  for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n    kinetic = _ref[_i];\n    if (!(kinetic.enabled && !kinetic.fixed)) {\n      continue;\n    }\n    vel = kinetic.vel;\n    acc = kinetic.acc;\n    if (kinetic.root.gravity && kinetic.mass > epsilon) {\n      Vec2.add(acc, Vec2.scal(this.root.gravity, 1 / kinetic.mass, cache));\n    }\n    if (kinetic.friction) {\n      Vec2.add(acc, Vec2.scal(Vec2.norm(vel, cache), -kinetic.friction));\n    }\n    if (kinetic.maxAcc) {\n      Vec2.limit(acc, kinetic.maxAcc);\n    }\n    Vec2.copy(copyVel, vel);\n    Vec2.add(vel, Vec2.scal(acc, dt, cache));\n    if (kinetic.maxVel) {\n      Vec2.limit(vel, kinetic.maxVel);\n    }\n    Vec2.scal(Vec2.add(copyVel, vel), dt / 2);\n    Vec2.add(kinetic.pos, copyVel);\n    Vec2.add(vel, Vec2.scal(acc, dt));\n    if (kinetic.drag < 1) {\n      Vec2.scal(vel, kinetic.drag);\n    }\n    if (kinetic.sleepVelSq) {\n      if (Vec2.lenSq(vel) <= kinetic.sleepVelSq) {\n        if (!kinetic.sleeping) {\n          Vec2.set(vel);\n          kinetic.sleeping = true;\n          kinetic.parent.pubUp('onKineticSleep', kinetic);\n        }\n      } else {\n        if (kinetic.sleeping) {\n          kinetic.sleeping = false;\n          kinetic.parent.pubUp('onKineticWake', kinetic);\n        }\n      }\n    }\n    Vec2.set(acc);\n  }\n  return this;\n};\n\nnew Pool(Kinetic);\n\nmodule.exports = Kinetic;\n\n//@ sourceURL=/lib/kinetic.js"
));

require.define("/lib/force.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.3.3\nvar Component, Force, Pool, Vec2,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComponent = require('./component');\n\nPool = require('./pool');\n\nVec2 = require('./math').Vec2;\n\nForce = (function(_super) {\n\n  __extends(Force, _super);\n\n  Force.prototype.type = 'force';\n\n  Force.prototype.presets = {\n    force: Vec2(),\n    torque: 0\n  };\n\n  function Force() {\n    this.force = Vec2();\n  }\n\n  Force.prototype.reset = function(presets) {\n    Vec2.copy(this.force, presets.force);\n    this.torque = presets.torque;\n    this.age = 0;\n    return this;\n  };\n\n  Force.prototype.simulate = function(dt) {\n    Vec2.add(this.kinetic.acc, this.force);\n    return this;\n  };\n\n  return Force;\n\n})(Component);\n\nnew Pool(Force);\n\nmodule.exports = Force;\n\n//@ sourceURL=/lib/force.js"
));

require.define("/lib/collider.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.3.3\nvar Collider, Component, Engine, Pool, Vec2,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComponent = require('./component');\n\nPool = require('./pool');\n\nVec2 = require('./math').Vec2;\n\nEngine = require('./engine');\n\nCollider = (function(_super) {\n\n  __extends(Collider, _super);\n\n  function Collider() {\n    return Collider.__super__.constructor.apply(this, arguments);\n  }\n\n  Collider.prototype.type = 'collider';\n\n  Collider.prototype.presets = {\n    trigger: false\n  };\n\n  Collider.prototype.reset = function(presets) {\n    this.trigger = presets.trigger;\n    return this;\n  };\n\n  return Collider;\n\n})(Component);\n\nCollider.simulate = function(dt) {\n  var collider1, collider2, colliders, diff, diffSq, i, j, kinetic1, kinetic2, mass1, mass2, n, p, parent1, parent2, pos1, pos2, radius1, radius2, radiusSum, vel1, vel2, vn1, vn2, vp1, vp1After, vp2, vp2After;\n  colliders = this.roster;\n  i = colliders.length;\n  while (i--) {\n    collider1 = colliders[i];\n    if (!collider1.enabled) {\n      continue;\n    }\n    j = i;\n    while (j--) {\n      collider2 = colliders[j];\n      kinetic1 = collider1.kinetic;\n      kinetic2 = collider2.kinetic;\n      if (!collider2.enabled || (kinetic1.sleeping && kinetic2.sleeping)) {\n        continue;\n      }\n      parent1 = collider1.parent;\n      parent2 = collider2.parent;\n      radius1 = parent1.radius || parent1.bounds.radius;\n      radius2 = parent2.radius || parent2.bounds.radius;\n      pos1 = parent1.transform.pos;\n      pos2 = parent2.transform.pos;\n      radiusSum = radius1 + radius2;\n      diffSq = Vec2.distSq(pos1, pos2);\n      if (diffSq > radiusSum * radiusSum) {\n        continue;\n      }\n      p = Vec2.norm(Vec2.sub(pos1, pos2, Vec2.cache[0]));\n      diff = Math.sqrt(diffSq);\n      if (collider1.trigger || collider2.trigger) {\n        parent1.pub('onTrigger', parent2, p, diff);\n        parent2.pub('onTrigger', parent1, p, diff);\n        continue;\n      }\n      diff -= radiusSum;\n      vel1 = kinetic1.vel;\n      vel2 = kinetic2.vel;\n      mass1 = kinetic1.mass || 1;\n      mass2 = kinetic2.mass || 1;\n      if (diff < 0) {\n        Vec2.add(pos1, Vec2.scal(p, -diff * 2 * radius1 / radiusSum, Vec2.cache[1]));\n        Vec2.add(pos2, Vec2.scal(p, diff * 2 * radius2 / radiusSum, Vec2.cache[1]));\n      }\n      n = Vec2.perp(p, Vec2.cache[1]);\n      vp1 = Vec2.dot(vel1, p);\n      vn1 = Vec2.dot(vel1, n);\n      vp2 = Vec2.dot(vel2, p);\n      vn2 = Vec2.dot(vel2, n);\n      vp1After = (mass1 * vp1 + mass2 * (2 * vp2 - vp1)) / (mass1 + mass2);\n      vp2After = (mass1 * (2 * vp1 - vp2) + mass2 * vp2) / (mass1 + mass2);\n      Vec2.add(Vec2.scal(p, vp1After, Vec2.cache[2]), Vec2.scal(n, vn1, Vec2.cache[3]), vel1);\n      Vec2.add(Vec2.scal(p, vp2After, Vec2.cache[2]), Vec2.scal(n, vn2, Vec2.cache[3]), vel2);\n      parent1.pub('onCollide', parent2, n);\n      parent2.pub('onCollide', parent1, n);\n    }\n  }\n  return this;\n};\n\nnew Pool(Collider);\n\nmodule.exports = Collider;\n\n//@ sourceURL=/lib/collider.js"
));

require.define("/lib/particle.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.3.3\nvar Color, Component, Composite, Engine, Kinetic, Particle, Pool, Sprite, Transform, Vec2,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComposite = require('./composite');\n\nComponent = require('./component');\n\nPool = require('./pool');\n\nEngine = require('./engine');\n\nVec2 = require('./math').Vec2;\n\nColor = require('./color');\n\nTransform = require('./transform');\n\nKinetic = require('./kinetic');\n\nSprite = require('./sprite').Asset;\n\nParticle = (function(_super) {\n\n  __extends(Particle, _super);\n\n  Particle.prototype.type = 'particle';\n\n  Particle.prototype.presets = {\n    color: Color.white,\n    lifetime: 1,\n    radius: 1,\n    sprite: Particle.sprite,\n    shrink: Math.quintIn,\n    fade: Math.quintIn\n  };\n\n  function Particle() {\n    this.color = Color();\n  }\n\n  Particle.prototype.reset = function(presets) {\n    this.lifetime = presets.lifetime, this.radius = presets.radius, this.sprite = presets.sprite, this.shrink = presets.shrink, this.fade = presets.fade;\n    Color.copy(this.color, presets.color);\n    this.age = 0;\n    return this;\n  };\n\n  Particle.prototype.update = function(dt) {\n    if ((this.age += dt) > this.lifetime) {\n      this.parent.free();\n    }\n    if (this.shrink) {\n      if (!(this.radius *= 1 - this.shrink(this.age / this.lifetime)) | 0) {\n        this.parent.free();\n      }\n    }\n    return this;\n  };\n\n  return Particle;\n\n})(Component);\n\nParticle.defaultComposite = 'lighter';\n\nParticle.render = function(ctx) {\n  var alpha, crop, cropOffset, particle, pos, radius, _i, _len, _ref;\n  ctx.save();\n  crop = Vec2.set(Vec2.cache[0], 50, 50);\n  cropOffset = Vec2.set(Vec2.cache[1], -25, -25);\n  _ref = this.roster;\n  for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n    particle = _ref[_i];\n    if (!particle.enabled) {\n      continue;\n    }\n    pos = particle.transform.pos;\n    radius = particle.radius;\n    alpha = 1;\n    if (particle.fade) {\n      alpha -= particle.fade(particle.age / particle.lifetime);\n    }\n    particle.color[3] = alpha;\n    ctx.fillStyle = Color.rgba(particle.color);\n    ctx.fillRect(pos[0] - radius / 2 | 0, pos[1] - radius / 2 | 0, radius | 0, radius | 0);\n  }\n  ctx.restore();\n  return this;\n};\n\nParticle.generateSprite = function(color, alpha, max) {\n  var size;\n  if (color == null) {\n    color = Color.white;\n  }\n  if (alpha == null) {\n    alpha = 1;\n  }\n  if (max == null) {\n    max = 25;\n  }\n  color = Color(color);\n  size = max * 2;\n  return new Sprite(function(ctx) {\n    var grad, radius, top, _i, _results;\n    _results = [];\n    for (radius = _i = 1; _i <= max; radius = _i += 1) {\n      top = max + size * (radius - 1);\n      grad = ctx.createRadialGradient(max, top, 0, max, top, radius);\n      color[3] = alpha;\n      grad.addColorStop(0, Color.rgba(color));\n      color[3] = 0;\n      grad.addColorStop(1, Color.rgba(color));\n      ctx.fillStyle = grad;\n      ctx.beginPath();\n      ctx.arc(max, top, radius, 0, Math.TAU, true);\n      ctx.closePath();\n      _results.push(ctx.fill());\n    }\n    return _results;\n  }, Vec2(size, size * max));\n};\n\nParticle.sprite = Particle.generateSprite();\n\nParticle.Prefab = new Composite.Prefab({\n  transform: null,\n  kinetic: {\n    mass: 0\n  },\n  particle: null\n});\n\nnew Pool(Particle);\n\nmodule.exports = Particle;\n\n//@ sourceURL=/lib/particle.js"
));

require.define("/index-curious.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.3.3\nvar Bounds, Collider, Color, Comet, Component, Composite, Earth, Engine, GameController, Kinetic, MenuController, Particle, Pool, Renderer, Sprite, Transform, Vec2, Weapon,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nVec2 = require('./lib/math').Vec2;\n\nEngine = require('./lib/engine');\n\nEngine.init(document.getElementById('game-1'));\n\nRenderer = require('./lib/renderer');\n\nEngine.renderer = new Renderer(Engine.element.getElementsByClassName('game-canvas')[0], Vec2(480, 320));\n\nComposite = require('./lib/composite');\n\nComponent = require('./lib/component');\n\nPool = require('./lib/pool');\n\nColor = require('./lib/color');\n\nSprite = require('./lib/sprite');\n\nTransform = require('./lib/transform');\n\nBounds = require('./lib/bounds');\n\nKinetic = require('./lib/kinetic');\n\nCollider = require('./lib/collider');\n\nParticle = require('./lib/particle');\n\nMenuController = (function(_super) {\n\n  __extends(MenuController, _super);\n\n  function MenuController() {\n    return MenuController.__super__.constructor.apply(this, arguments);\n  }\n\n  MenuController.prototype.type = 'menuController';\n\n  return MenuController;\n\n})(Component);\n\nnew Pool(MenuController);\n\nEngine.menuScene = Composite.alloc(null, {\n  menuController: null\n});\n\nGameController = (function(_super) {\n\n  __extends(GameController, _super);\n\n  function GameController() {\n    return GameController.__super__.constructor.apply(this, arguments);\n  }\n\n  GameController.prototype.type = 'gameController';\n\n  GameController.prototype.reset = function() {\n    this.baseCharge = 1;\n    this.charge = 1;\n    this.nextCharge = this.baseCharge;\n    Earth.Prefab.alloc(this.root, {\n      transform: {\n        pos: Vec2(240, 160)\n      }\n    });\n    return this;\n  };\n\n  GameController.prototype.update = function(dt) {\n    var comet, pos, radius, vel;\n    this.charge += dt / this.nextCharge;\n    if (this.charge < 1) {\n      return;\n    }\n    this.charge = 0;\n    this.nextCharge = this.baseCharge * Math.rand(1, 1.2);\n    pos = Vec2(Math.rand(-150, 0), Math.rand(-150, 0));\n    radius = Math.rand(3, 7);\n    comet = Comet.Prefab.alloc(this.parent, {\n      transform: {\n        pos: pos\n      },\n      bounds: {\n        radius: radius\n      },\n      kinetic: {\n        mass: radius,\n        drag: 1,\n        friction: 0\n      }\n    });\n    vel = comet.kinetic.vel;\n    Vec2.add(vel, Vec2(Math.rand(0.8, 1.2), Math.rand(0.9, 1.1)));\n    return Vec2.scal(vel, Math.rand(30, 40));\n  };\n\n  return GameController;\n\n})(Component);\n\nnew Pool(GameController);\n\nEarth = (function(_super) {\n\n  __extends(Earth, _super);\n\n  Earth.prototype.type = 'earth';\n\n  function Earth() {\n    this.normal = Vec2();\n  }\n\n  Earth.prototype.reset = function() {\n    this.gravityRadius = 200;\n    this.state = this.hovered = null;\n    return this;\n  };\n\n  Earth.prototype.fixedUpdate = function(dt) {\n    var distSq, factor, gravityRadiusSq, kinetic, pos, pos2, _i, _len, _ref, _results;\n    pos = this.transform.pos;\n    gravityRadiusSq = this.gravityRadius * this.gravityRadius;\n    _ref = Kinetic.pool.roster;\n    _results = [];\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      kinetic = _ref[_i];\n      if (!(kinetic.enabled && !kinetic.fixed && kinetic.mass)) {\n        continue;\n      }\n      pos2 = kinetic.parent.transform.pos;\n      distSq = Vec2.distSq(pos, pos2);\n      if (distSq < gravityRadiusSq) {\n        factor = 1 - Math.sqrt(distSq) / this.gravityRadius;\n        _results.push(kinetic.applyForce(Vec2.norm(Vec2.sub(pos, pos2, Vec2.cache[0]), null, Math.quadIn(factor) * 750 / kinetic.mass)));\n      } else {\n        _results.push(void 0);\n      }\n    }\n    return _results;\n  };\n\n  Earth.prototype.update = function(dt) {\n    var dist, input;\n    input = Engine.input;\n    Vec2.sub(input.pos, this.transform.pos, this.normal);\n    switch (this.state) {\n      case null:\n        dist = Vec2.len(this.normal);\n        if (dist > this.bounds.radius) {\n          if (this.hovered) {\n            this.hovered = false;\n          }\n          break;\n        }\n        if (!this.hovered) {\n          this.hovered = true;\n        }\n        if (input.touchState !== 'began') {\n          break;\n        }\n        this.state = 'active';\n        break;\n      case 'active':\n        this.angle = Vec2.rad(this.normal);\n        if (input.touchState === 'ended') {\n          Weapon.Prefab.alloc(this.root, {\n            transform: {\n              pos: Vec2.add(Vec2.rot(Vec2.set(Vec2.cache[0], this.bounds.radius * 1.2, 0), this.angle), this.transform.pos),\n              angle: this.angle\n            }\n          });\n          this.state = null;\n        }\n    }\n    return this;\n  };\n\n  Earth.prototype.render = function(ctx) {\n    var angle, arc, lowArc;\n    if (!this.state && !this.hovered) {\n      return this;\n    }\n    ctx.save();\n    this.transform.transform(ctx);\n    if (this.hovered) {\n      ctx.beginPath();\n      ctx.arc(0, 0, this.bounds.radius, 0, Math.TAU, true);\n      ctx.closePath();\n      ctx.lineWidth = 1;\n      ctx.strokeStyle = Color.rgba(Color.white);\n      ctx.stroke();\n    }\n    if (this.state === 'active') {\n      arc = Math.TAU / 8 / 2;\n      lowArc = Math.TAU / 45;\n      angle = this.angle;\n      ctx.beginPath();\n      ctx.arc(0, 0, this.bounds.radius + 2, angle - lowArc, angle + lowArc);\n      ctx.arc(0, 0, this.bounds.radius * 3, angle + arc, angle - arc, true);\n      ctx.closePath();\n      ctx.lineWidth = 1;\n      ctx.strokeStyle = Color.rgba(Color.white);\n      ctx.stroke();\n    }\n    ctx.restore();\n    return this;\n  };\n\n  return Earth;\n\n})(Component);\n\nEarth.sprite = new Sprite.Asset('assets/globe.gif', Vec2(11, 11), 5);\n\nnew Pool(Earth);\n\nEarth.Prefab = new Composite.Prefab({\n  transform: null,\n  bounds: {\n    radius: 25\n  },\n  collider: {\n    trigger: true\n  },\n  spriteTween: {\n    asset: Earth.sprite\n  },\n  earth: null\n});\n\nComet = (function(_super) {\n\n  __extends(Comet, _super);\n\n  Comet.prototype.type = 'comet';\n\n  function Comet() {\n    this.normal = Vec2();\n    this.lifetime = 10;\n  }\n\n  Comet.prototype.reset = function(presets) {\n    var center;\n    this.kinetic.maxVel = 100;\n    this.age = 0;\n    this.target = Earth.pool.roster[0].transform;\n    this.color = Color(156, 156, 156);\n    center = this.bounds.radius | 0;\n    return this;\n  };\n\n  Comet.prototype.update = function(dt) {\n    var i, particle, pointer, pos;\n    if ((this.bounds.radius -= dt / 2) < 2 || (this.age += dt) > this.lifetime) {\n      this.explode();\n      return;\n    }\n    this.kinetic.mass = this.bounds.radius;\n    if (this.bounds.culled) {\n      return;\n    }\n    pos = Vec2.cache[0];\n    i = this.bounds.radius * dt * 25 | 0;\n    while (i--) {\n      Vec2.set(pos, Math.rand(-1, 1), Math.rand(-1, 1));\n      Vec2.norm(pos, null, Math.rand(0, 1, Math.quadOut) * this.bounds.radius);\n      pointer = Vec2.copy(Vec2.cache[1], pos);\n      Vec2.add(Vec2.norm(pos, null, this.bounds.radius), this.transform.pos);\n      particle = Composite.alloc(this.root, {\n        transform: {\n          pos: pos\n        },\n        kinetic: {\n          vel: Vec2.scal(pointer, Math.rand(-0.5, -4))\n        },\n        particle: {\n          radius: Math.rand(2.5, 5),\n          lifetime: Math.rand(0.02, 0.1),\n          sprite: Comet.particleTrail\n        }\n      });\n    }\n    return this;\n  };\n\n  Comet.prototype.render = function(ctx) {\n    if (Engine.renderer.cull(this)) {\n      return this;\n    }\n    ctx.beginPath();\n    ctx.arc(this.transform.pos[0], this.transform.pos[1], this.bounds.radius, 0, Math.TAU);\n    ctx.closePath();\n    ctx.fillStyle = Color.rgba(this.color);\n    ctx.fill();\n    return this;\n  };\n\n  Comet.prototype.onTrigger = function(parent2, p, diff) {\n    if (parent2.earth) {\n      this.explode();\n    }\n    return this;\n  };\n\n  Comet.prototype.explode = function() {\n    var i, particle, pointer, pos, radius;\n    if (this.bounds.culled) {\n      this.parent.free();\n      return;\n    }\n    i = this.bounds.radius * 4 | 0;\n    while (i--) {\n      pos = Vec2.set(Vec2.cache[0], Math.rand(-1, 1), Math.rand(-1, 1));\n      Vec2.norm(pos, null, Math.rand(0, 1, Math.quadOut) * this.bounds.radius);\n      pointer = Vec2.copy(Vec2.cache[1], pos);\n      Vec2.add(Vec2.norm(pos, null, this.bounds.radius), this.transform.pos);\n      radius = Math.rand(2, 10);\n      particle = Particle.Prefab.alloc(this.root, {\n        transform: {\n          pos: pos\n        },\n        kinetic: {\n          vel: Vec2.scal(pointer, Math.rand(1, 5))\n        },\n        particle: {\n          radius: radius,\n          lifetime: Math.rand(0.01, 0.04),\n          sprite: Comet.particleTrail\n        }\n      });\n    }\n    this.parent.free();\n    return this;\n  };\n\n  return Comet;\n\n})(Component);\n\nComet.particleTrail = Particle.generateSprite(Color(192, 192, 192), 0.2);\n\nComet.particleFire1 = Particle.generateSprite(Color(252, 238, 51), 0.9);\n\nComet.particleFire2 = Particle.generateSprite(Color(243, 18, 14), 0.9);\n\nnew Pool(Comet);\n\nComet.Prefab = new Composite.Prefab({\n  transform: null,\n  collider: {\n    trigger: true\n  },\n  kinetic: null,\n  comet: null\n});\n\nWeapon = (function(_super) {\n\n  __extends(Weapon, _super);\n\n  Weapon.prototype.type = 'weapon';\n\n  function Weapon() {\n    this.normal = Vec2();\n    this.lockedNorm = Vec2();\n  }\n\n  Weapon.prototype.reset = function(presets) {\n    this.state = null;\n    this.arc = Math.TAU / 8;\n    this.targets = Comet;\n    this.range = 100;\n    this.orbit = this.bounds.radius * 1.2;\n    this.colorAmmo = Color(255, 0, 0);\n    return this;\n  };\n\n  Weapon.prototype.update = function(dt) {\n    var input, normal, particle, pos, rad, rangeSq;\n    input = Engine.input;\n    normal = Vec2.cache[0];\n    pos = this.transform.pos;\n    if (this.transform.angle !== this.angle) {\n      Vec2.rot(Vec2.set(pos, this.orbit, 0), this.angle);\n      Vec2.copy(this.normal, pos);\n      Vec2.add(pos, this.parent.transform.pos);\n      this.transform.angle = this.angle;\n    }\n    rangeSq = this.range * this.range;\n    switch (this.state) {\n      case null:\n        if (Vec2.distSq(input.pos, pos) < this.rangeSq) {\n          rad = Vec2.rad(Vec2.sub(input.pos, pos, normal), this.normal);\n          if (rad < this.arc / 2) {\n            console.log('locked');\n            this.locked = input.pos;\n            this.state = 'locked';\n            debugger;\n          }\n        }\n        break;\n      case 'locked':\n        Vec2.sub(input.pos, pos, this.lockedNorm);\n        this.lockedRad = Vec2.rad(this.lockedNorm, this.normal);\n        if (Vec2.lenSq(this.lockedNorm) > this.rangeSq || this.lockedRad > this.arc / 2) {\n          this.state = this.locked = null;\n        }\n        particle = Composite.alloc(this.root, {\n          transform: {\n            pos: pos\n          },\n          particle: {\n            radius: 1\n          },\n          kinetic: {\n            vel: this.lockedNorm\n          }\n        });\n        break;\n    }\n    return this;\n  };\n\n  Weapon.prototype.render = function(ctx) {\n    ctx.save();\n    ctx.translate(this.transform.pos[0], this.transform.pos[1]);\n    ctx.rotate(this.transform.angle);\n    ctx.fillStyle = Color.rgba(Color.white);\n    ctx.fillRect(-2.5, -2.5, 5, 5);\n    ctx.restore();\n    switch (this.state) {\n      case 'locked':\n        ctx.save();\n        ctx.beginPath();\n        ctx.arc(this.locked[0], this.locked[1], 3, 0, Math.TAU, true);\n        ctx.closePath();\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = Color.rgba(this.colorAmmo);\n        ctx.stroke();\n        ctx.restore();\n        break;\n    }\n    return this;\n  };\n\n  Weapon.prototype.intercept = function(target, targetVel) {\n    var a, b, c, d, interception, pos, tmp, vel;\n    pos = this.transform.pos;\n    vel = this.transform.maxVel;\n    tmp = Vec2.sub(target, pos, Vec2.cache[0]);\n    a = vel * vel - Vec2.dot(targetVel, targetVel);\n    b = -2 * Vec2.dot(targetVel, tmp);\n    c = -Vec2.dot(tmp, tmp);\n    d = (b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n    interception = Vec2.mul(Vec2.add(Vec2.set(tmp, d, d), target), targetVel);\n    return Vec2.scal(Vec2.sub(interception, pos, Vec2()), vel / Math.sqrt(Vec2.dot(dist, dist)));\n  };\n\n  return Weapon;\n\n})(Component);\n\nnew Pool(Weapon);\n\nWeapon.Prefab = new Composite.Prefab({\n  transform: null,\n  bounds: {\n    shape: 'circle'\n  },\n  weapon: null\n});\n\nEngine.gameScene = Composite.alloc(null, {\n  gameController: null\n});\n\nEngine.play(Engine.gameScene);\n\n//@ sourceURL=/index-curious.js"
));
require("/index-curious.js");
})();
