;(function(e,t,n,r){function i(r){if(!n[r]){if(!t[r]){if(e)return e(r);throw new Error("Cannot find module '"+r+"'")}var s=n[r]={exports:{}};t[r][0](function(e){var n=t[r][1][e];return i(n?n:e)},s,s.exports)}return n[r].exports}for(var s=0;s<r.length;s++)i(r[s]);return i})(typeof require!=="undefined"&&require,{1:[function(require,module,exports){// Generated by CoffeeScript 1.5.0
'use strict';
var Border, Collider, Component, Composite, Enemy, Engine, Explosion, GameController, Kinetic, Magician, Pool, Renderer, Sprite, Transform, Vec2, defaultSequence,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Vec2 = require('../../lib/core/math').Vec2;

Engine = require('../../lib/core/engine');

Engine.init(document.getElementById('game-1'));

Renderer = require('../../lib/core/renderer');

Engine.renderer = new Renderer(Engine.element.getElementsByClassName('game-canvas')[0], Vec2(480, 320));

Composite = require('../../lib/core/composite');

Component = require('../../lib/core/component');

Pool = require('../../lib/core/pool');

Sprite = require('../../lib/core/sprite');

Transform = require('../../lib/core/transform');

Border = require('../../lib/core/border');

Collider = require('../../lib/core/collider');

Kinetic = require('../../lib/core/kinetic');

GameController = (function(_super) {

  __extends(GameController, _super);

  function GameController() {
    GameController.__super__.constructor.apply(this, arguments);
  }

  GameController.prototype.type = 'gameController';

  GameController.prototype.reset = function() {
    Magician.Prefab.alloc(this.root, {
      transform: {
        pos: Vec2(240, 200)
      }
    });
    return this;
  };

  GameController.prototype.update = function() {
    var input;
    input = Engine.input;
    if (input.keys.space === 'began') {
      Explosion.Prefab.alloc(this.root, {
        transform: {
          pos: input.pos
        }
      });
      return this;
    }
  };

  return GameController;

})(Component);

new Pool(GameController);

Explosion = (function(_super) {

  __extends(Explosion, _super);

  function Explosion() {
    Explosion.__super__.constructor.apply(this, arguments);
  }

  Explosion.prototype.type = 'explosion';

  Explosion.prototype.onSequenceEnd = function() {
    return this.parent.free();
  };

  return Explosion;

})(Component);

new Pool(Explosion);

Explosion.sheetBlue = new Sprite.Sheet({
  sprites: new Sprite.Asset('./assets/explosion-blue.jpg'),
  size: Vec2(120, 120),
  speed: 0.12
});

Explosion.sheetFire = new Sprite.Sheet({
  sprites: new Sprite.Asset('./assets/explosion-fire.png'),
  size: Vec2(192, 192),
  speed: 0.05
});

Explosion.Prefab = new Composite.Prefab({
  transform: null,
  spriteTween: {
    asset: Explosion.sheetFire
  },
  explosion: null
});

defaultSequence = {
  walkS: {
    frames: [0, 1, 2, 1],
    next: 'walkS'
  },
  walkW: {
    frames: [3, 4, 5, 4],
    next: 'walkW'
  },
  walkN: {
    frames: [9, 10, 11, 10],
    next: 'walkN'
  },
  walkE: {
    frames: [6, 7, 8, 7],
    next: 'walkE'
  }
};

Magician = (function(_super) {

  __extends(Magician, _super);

  function Magician() {
    Magician.__super__.constructor.apply(this, arguments);
  }

  Magician.prototype.type = 'magician';

  Magician.prototype.simulate = function() {
    var axis, pos, speed;
    axis = Engine.input.axis;
    pos = this.transform.pos;
    speed = 1;
    if (axis[1] < 0) {
      pos[1] -= speed;
    } else if (axis[1] > 0) {
      pos[1] += speed;
    }
    if (axis[0] < 0) {
      pos[0] -= speed;
    } else if (axis[0] > 0) {
      pos[0] += speed;
    }
    return this;
  };

  Magician.prototype.lateUpdate = function() {
    var axis, spriteTween;
    axis = Engine.input.axis;
    spriteTween = this.spriteTween;
    if (axis[1] < 0) {
      spriteTween.goto('walkN').play();
    } else if (axis[1] > 0) {
      spriteTween.goto('walkS').play();
    } else if (axis[0] < 0) {
      spriteTween.goto('walkW').play();
    } else if (axis[0] > 0) {
      spriteTween.goto('walkE').play();
    } else if (!spriteTween.paused) {
      spriteTween.pause();
    }
    return this;
  };

  return Magician;

})(Component);

new Pool(Magician);

Magician.sheet = new Sprite.Sheet({
  sprites: new Sprite.Asset('./assets/magician.png'),
  size: Vec2(32, 32),
  speed: 0.15,
  sequences: defaultSequence
});

Magician.Prefab = new Composite.Prefab({
  transform: null,
  spriteTween: {
    asset: Magician.sheet,
    sequence: 'walkS'
  },
  bounds: {
    radius: 15,
    shape: 'circle'
  },
  border: null,
  magician: null
});

Enemy = (function(_super) {

  __extends(Enemy, _super);

  function Enemy() {
    Enemy.__super__.constructor.apply(this, arguments);
  }

  Enemy.prototype.type = 'enemy';

  return Enemy;

})(Component);

new Pool(Enemy);

Enemy.sheet = new Sprite.Sheet({
  sprites: new Sprite.Asset('./assets/grinch.png'),
  size: Vec2(32, 32),
  speed: 0.15,
  sequences: defaultSequence
});

Enemy.Prefab = new Composite.Prefab({
  transform: null,
  spriteTween: {
    asset: Enemy.sheet,
    sequence: 'walkS'
  }
});

Engine.gameScene = Composite.alloc(null, {
  gameController: null
});

Engine.play(Engine.gameScene);

},{"../../lib/core/math":2,"../../lib/core/engine":3,"../../lib/core/renderer":4,"../../lib/core/composite":5,"../../lib/core/component":6,"../../lib/core/pool":7,"../../lib/core/sprite":8,"../../lib/core/transform":9,"../../lib/core/border":10,"../../lib/core/collider":11,"../../lib/core/kinetic":12}],2:[function(require,module,exports){// Generated by CoffeeScript 1.5.0
var Mat, Vec2, abs, epsilon, fn, i, objCache, objVecCache, pow, powIn, radCache, random, sqrt, toInOut, toOut, transition, typedArray, _i, _len, _ref;

Mat = Math;

sqrt = Mat.sqrt, pow = Mat.pow, abs = Mat.abs, random = Mat.random;

Mat.epsilon = epsilon = 0.001;

Mat.TypedArray = typedArray = Float64Array || Float32Array || function(arr) {
  return arr;
};

Mat.Vec2 = Vec2 = function(fromOrX, y) {
  if (y != null) {
    return new typedArray([fromOrX, y]);
  }
  if (fromOrX != null) {
    return new typedArray(fromOrX);
  }
  return new typedArray(Vec2.zero);
};

Vec2.zero = Vec2.center = Vec2(0, 0);

Vec2.cache = [Vec2(), Vec2(), Vec2(), Vec2(), Vec2()];

Vec2.topLeft = Vec2(-1, -1);

Vec2.topCenter = Vec2(0, -1);

Vec2.topRight = Vec2(1, -1);

Vec2.centerLeft = Vec2(-1, 0);

Vec2.centerRight = Vec2(1, 0);

Vec2.bottomLeft = Vec2(-1, 1);

Vec2.bottomCenter = Vec2(0, 1);

Vec2.bottomRight = Vec2(1, 1);

radCache = [Vec2(), Vec2()];

objCache = {
  x: 0,
  y: 0
};

objVecCache = Vec2();

Vec2.set = function(result, x, y) {
  result[0] = x || 0;
  result[1] = y || 0;
  return result;
};

Vec2.copy = function(result, b) {
  result[0] = b[0];
  result[1] = b[1];
  return result;
};

Vec2.valid = function(a) {
  return !(isNaN(a[0]) || isNaN(a[1]));
};

Vec2.toString = function(a) {
  return "[" + a[0] + ", " + a[1] + "]";
};

Vec2.fromObj = function(obj, a) {
  a || (a = objVecCache);
  a[0] = obj.x;
  a[1] = obj.y;
  return a;
};

Vec2.toObj = function(a, obj) {
  obj || (obj = objCache);
  obj.x = a[0];
  obj.y = a[1];
  return obj;
};

Vec2.eq = function(a, b) {
  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
};

Vec2.add = function(a, b, result) {
  result || (result = a);
  result[0] = a[0] + b[0];
  result[1] = a[1] + b[1];
  return result;
};

Vec2.sub = function(a, b, result) {
  result || (result = a);
  result[0] = a[0] - b[0];
  result[1] = a[1] - b[1];
  return result;
};

Vec2.mul = function(a, b, result) {
  result || (result = a);
  result[0] = a[0] * b[0];
  result[1] = a[1] * b[1];
  return result;
};

Vec2.scal = function(a, scalar, result) {
  result || (result = a);
  result[0] = a[0] * scalar;
  result[1] = a[1] * scalar;
  return result;
};

Vec2.norm = function(a, result, scalar) {
  var len, x, y;
  result || (result = a);
  x = a[0];
  y = a[1];
  len = (scalar || 1) / (sqrt(x * x + y * y) || 1);
  result[0] = x * len;
  result[1] = y * len;
  return result;
};

Vec2.lenSq = function(a) {
  return a[0] * a[0] + a[1] * a[1];
};

Vec2.len = function(a) {
  return sqrt(a[0] * a[0] + a[1] * a[1]);
};

Vec2.dot = function(a, b) {
  return a[0] * b[0] + a[1] * b[1];
};

Vec2.cross = function(a, b) {
  return a[0] * b[1] - a[1] * b[0];
};

Vec2.lerp = function(a, b, scalar, result) {
  result || (result = a);
  result[0] = a[0] + scalar * (b[0] - a[0]);
  result[1] = a[1] + scalar * (b[1] - a[1]);
  return result;
};

Vec2.max = function(a, b, axis) {
  if (axis != null) {
    if (a[axis] > b[axis]) {
      return a;
    } else {
      return b;
    }
  }
  if (Vec2.lenSq(a) > Vec2.lenSq(b)) {
    return a;
  } else {
    return b;
  }
};

Vec2.perp = function(a, result) {
  var x;
  result || (result = a);
  x = a[0];
  result[0] = a[1];
  result[1] = -x;
  return result;
};

Vec2.dist = function(a, b) {
  var x, y;
  x = b[0] - a[0];
  y = b[1] - a[1];
  return sqrt(x * x + y * y);
};

Vec2.distSq = function(a, b) {
  var x, y;
  x = b[0] - a[0];
  y = b[1] - a[1];
  return x * x + y * y;
};

Vec2.limit = function(a, max, result) {
  var ratio, x, y;
  result || (result = a);
  x = a[0];
  y = a[1];
  if ((ratio = max / sqrt(x * x + y * y)) < 1) {
    result[0] = x * ratio;
    result[1] = y * ratio;
  } else if (result !== a) {
    result[0] = x;
    result[1] = y;
  }
  return result;
};

Vec2.rad = function(a, b) {
  if (!b) {
    return Mat.atan2(a[1], a[0]);
  }
  return Mat.acos(Vec2.dot(Vec2.norm(a, radCache[0]), Vec2.norm(b, radCache[1])));
};

Vec2.rot = function(a, theta, result) {
  var cosA, sinA, x, y;
  result || (result = a);
  sinA = Mat.sin(theta);
  cosA = Mat.cos(theta);
  x = a[0];
  y = a[1];
  result[0] = x * cosA - y * sinA;
  result[1] = x * sinA + y * cosA;
  return result;
};

Vec2.rotAxis = function(a, b, theta, result) {
  return Vec2.add(Vec2.rot(Vec2.sub(a, b, result || a), theta), b);
};

Vec2.lookAt = function(a, b, result) {
  var len;
  len = Vec2.len(a);
  return Vec2.norm(Vec2.rot(a, Mat.atan2(b[0] - a[0], b[1] - a[1]) - Mat.atan2(a[1], a[0]), result || a), null, len);
};

Vec2.variant = function(a, delta, result) {
  result || (result = a);
  result[0] = a[0] + Math.rand(-delta, delta);
  result[1] = a[1] + Math.rand(-delta, delta);
  return result;
};

random = Mat.random, pow = Mat.pow;

Mat.TAU = Mat.PI * 2;

Mat.UID = 1;

Mat.uid = function() {
  return Mat.UID++;
};

Mat.clamp = function(a, low, high) {
  if (a < low) {
    return low;
  }
  if (a > high) {
    return high;
  } else {
    return a;
  }
};

Mat.rand = function(low, high, ease) {
  return (ease || Mat.linear)(random()) * (high - low) + low;
};

Mat.randArray = function(array) {
  return array[random() * array.length | 0];
};

Mat.chance = function(chance) {
  return random() <= chance;
};

powIn = function(strength) {
  if (strength == null) {
    strength = 2;
  }
  return function(t) {
    return pow(t, strength);
  };
};

toOut = function(fn) {
  return function(t) {
    return 1 - fn(1 - t);
  };
};

toInOut = function(fn) {
  return function(t) {
    return (t < 0.5 ? fn(t * 2) : 2 - fn(2 * (1 - t))) / 2;
  };
};

Mat.linear = function(t) {
  return t;
};

_ref = ['quad', 'cubic', 'quart', 'quint'];
for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
  transition = _ref[i];
  Mat[transition + 'In'] = fn = powIn(i + 2);
  Mat[transition + 'Out'] = toOut(fn);
  Mat[transition + 'InOut'] = toInOut(fn);
}

module.exports.Vec2 = Vec2;

},{}],4:[function(require,module,exports){// Generated by CoffeeScript 1.5.0
var Bounds, Color, Composite, Renderer, Vec2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Composite = require('./composite');

Bounds = require('./bounds');

Vec2 = require('./math').Vec2;

Color = require('./math');

Renderer = (function(_super) {

  __extends(Renderer, _super);

  function Renderer(element, client) {
    var fullscreenChange, self;
    this.element = element;
    this.client = Vec2(client);
    this.content = Vec2(client);
    this.canvas = document.createElement('canvas');
    this.element.appendChild(this.canvas);
    this.ctx = this.canvas.getContext('2d');
    this.browser = Vec2();
    this.margin = Vec2();
    this.pos = Vec2();
    this.scale = 0;
    this.orientation = 'landscape';
    this.buffer = false;
    this.buf = document.createElement('canvas');
    this.bufctx = this.buf.getContext('2d');
    this.buf.width = this.canvas.width = this.content[0];
    this.buf.height = this.canvas.height = this.content[1];
    this.element.style.width = this.content[0] + 'px';
    this.element.style.height = this.content[1] + 'px';
    window.addEventListener('resize', this, false);
    self = this;
    fullscreenChange = function() {
      return self.fullscreenChange();
    };
    document.addEventListener('fullscreenchange', fullscreenChange(false));
    document.addEventListener('mozfullscreenchange', fullscreenChange, false);
    document.addEventListener('webkitfullscreenchange', fullscreenChange, false);
    this.reflow();
    this;
  }

  Renderer.prototype.isFullscreen = function() {
    var doc;
    doc = document;
    return doc.fullscreen || doc.mozFullScreen || doc.webkitIsFullScreen;
  };

  Renderer.prototype.requestFullscreen = function() {
    var target;
    if (!this.isFullscreen()) {
      target = this.element.parentNode;
      if ('webkitRequestFullScreen' in target) {
        target.webkitRequestFullScreen();
      } else if ('mozRequestFullScreen' in target) {
        target.mozRequestFullScreen();
      }
    }
    return this;
  };

  Renderer.prototype.fullscreenChange = function() {
    if (this.orientation) {
      this.lockOrientation(this.orientation);
    }
    return this;
  };

  Renderer.prototype.lockOrientation = function(format) {
    var target;
    if (format == null) {
      format = this.orientation;
    }
    target = window.screen;
    if ('lockOrientation' in target) {
      screen.lockOrientation(format);
    } else if ('mozLockOrientation' in target) {
      screen.mozLockOrientation(format);
    }
    return this;
  };

  Renderer.prototype.handleEvent = function() {
    this.reflow();
    return this;
  };

  Renderer.prototype.reflow = function() {
    var browser, rule, scale;
    browser = Vec2.set(this.browser, window.innerWidth, window.innerHeight);
    scale = Math.min(this.browser[0] / this.content[0], this.browser[1] / this.content[1]);
    if (scale !== this.scale) {
      this.scale = scale;
      Vec2.scal(this.content, this.scale, this.client);
    }
    Vec2.scal(Vec2.sub(browser, this.client, this.margin), 0.5);
    rule = "translate(" + this.margin[0] + "px, " + this.margin[1] + "px) scale(" + this.scale + ")";
    this.element.style.transform = rule;
    this.element.style.webkitTransform = rule;
    return this;
  };

  Renderer.prototype.save = function() {
    var ctx;
    ctx = this.buffer ? this.bufctx : this.ctx;
    ctx.clearRect(0, 0, this.content[0], this.content[1]);
    ctx.save();
    ctx.translate(this.pos[0] | 0, this.pos[1] | 0);
    return ctx;
  };

  Renderer.prototype.restore = function() {
    if (this.buffer) {
      this.bufctx.restore();
      this.ctx.clearRect(0, 0, this.content[0], this.content[1]);
      this.ctx.drawImage(this.buf, 0, 0);
    } else {
      this.ctx.restore();
    }
    return this;
  };

  Renderer.prototype.center = function(pos) {
    Vec2.set(this.pos, pos[0] - this.client[0] / 2, pos[0] - this.client[1] / 2);
    return this;
  };

  Renderer.prototype.cull = function(entity) {
    var bounds;
    if (!(bounds = entity.bounds)) {
      return false;
    }
    if (bounds.withinRect(this.pos, this.content)) {
      if (bounds.culled) {
        bounds.culled = false;
      }
      return false;
    }
    if (!bounds.culled) {
      bounds.culled = true;
    }
    return true;
  };

  return Renderer;

})(Composite);

module.exports = Renderer;

},{"./composite":5,"./bounds":13,"./math":2}],5:[function(require,module,exports){// Generated by CoffeeScript 1.5.0
var Composite, Pool;

Pool = require('./pool');

Composite = (function() {

  function Composite() {
    this.children = {};
    this.components = {};
  }

  Composite.prototype.toString = function() {
    var comps;
    comps = Object.keys(this.components).join(', ');
    return "Composite " + (this.name || '') + "#" + this.uid + " (" + comps + ") [^ " + this.parent + "]";
  };

  Composite.prototype.alloc = function(presets) {
    var child, pool, preset, type, _i, _len;
    if (this.parent) {
      this.parent.children[this.uid] = this;
    }
    if (presets) {
      for (type in presets) {
        preset = presets[type];
        switch (type) {
          case 'children':
            for (_i = 0, _len = preset.length; _i < _len; _i++) {
              child = preset[_i];
              Composite.alloc(this, child);
            }
            break;
          case 'name':
            this.name = presets[type];
            break;
          default:
            if ((pool = Pool.types[type])) {
              pool.alloc(this, preset);
            } else {
              throw new Error("Unknown preset key '" + type + "', expected component. " + this);
            }
        }
      }
    }
    return this;
  };

  Composite.prototype.free = function() {
    var key, ref, refSubs, _i, _len;
    if (refSubs = this.refSubs) {
      for (_i = 0, _len = refSubs.length; _i < _len; _i++) {
        ref = refSubs[_i];
        ref.unsub(this);
      }
    }
    this.refSubs = this.subs = null;
    for (key in this.components) {
      this.components[key].free();
    }
    for (key in this.children) {
      this.children[key].free();
    }
    if (this.parent) {
      delete this.parent.children[this.uid];
    }
    this.pool.free(this);
    return this;
  };

  Composite.prototype.enable = function(state, deep) {
    var key;
    this.enabled = state != null ? state : state = !this.state;
    this.parent.pub('on' + (state ? 'Enable' : 'Disable'), this);
    for (key in this.components) {
      this.components[key].enable(state);
    }
    if (deep) {
      for (key in this.children) {
        this.children[key].enable(state, true);
      }
    }
    return this;
  };

  Composite.prototype.sub = function(scope, topic, method) {
    var items, refs, subs;
    if (scope == null) {
      scope = this;
    }
    subs = this.subs || (this.subs = {});
    items = subs[topic] || (subs[topic] = []);
    items.push(scope, method);
    if (scope !== this) {
      refs = scope.refSubs || (scope.refSubs = []);
      if (!~refs.indexOf(this)) {
        refs.push(this);
      }
    }
    return this;
  };

  Composite.prototype.pub = function(topic, a0, a1, a2, a3) {
    var i, items, scope;
    if (this.subs && (items = this.subs[topic]) && (i = items.length)) {
      while (scope = items[i -= 2]) {
        scope[items[i + 1] || topic](a0, a1, a2, a3);
      }
    }
    return this;
  };

  Composite.prototype.pubUp = function(topic, a0, a1, a2, a3) {
    var comp;
    comp = this;
    while (comp) {
      if (comp.pub(topic, a0, a1, a2, a3) === false) {
        break;
      }
      comp = comp.parent;
    }
    return this;
  };

  Composite.prototype.pubAll = function(topic, a0, a1, a2, a3) {
    return Pool.call(topic, a0, a1, a2, a3);
  };

  Composite.prototype.unsub = function(unscope, untopic) {
    var i, items, length, scope, subs, topic;
    if (subs = this.subs) {
      for (topic in subs) {
        items = subs[topic];
        if (!((i = items.length) && (!untopic || untopic === topic))) {
          continue;
        }
        length = i / 2;
        while ((i -= 2) >= 0) {
          if (scope = items[i]) {
            if (unscope && scope !== unscope) {
              continue;
            } else {
              items[i] = null;
            }
            length--;
          }
        }
        if (!length) {
          items.length = 0;
        }
      }
    }
    return this;
  };

  return Composite;

})();

new Pool(Composite);

Composite.Prefab = (function() {

  function Prefab(presets) {
    var key;
    this.presets = presets;
    for (key in presets) {
      presets[key] = this.presets[key] || {};
    }
  }

  Prefab.prototype.alloc = function(parent, presets) {
    var defaults, key, subKey, subPresets, value;
    if ((defaults = this.presets) && presets) {
      for (key in defaults) {
        value = defaults[key];
        if (!(key in presets)) {
          presets[key] = value;
        } else {
          subPresets = presets[key];
          if (key === 'children') {
            subPresets.unshift.apply(subPresets, value);
          } else if (typeof value === 'object') {
            for (subKey in value) {
              if (!(subKey in subPresets)) {
                subPresets[subKey] = value[subKey];
              }
            }
          }
          delete presets[key];
          presets[key] = subPresets;
        }
      }
    }
    return Composite.alloc(parent, presets || defaults);
  };

  return Prefab;

})();

module.exports = Composite;

},{"./pool":7}],3:[function(require,module,exports){// Generated by CoffeeScript 1.5.0
var Composite, Engine, Pool, Vec2, engine, perf, requestAnimationFrame,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Composite = require('./composite');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
  return setTimeout(callback, 20);
};

perf = window.performance || {};

perf.now = perf.now || perf.webkitNow || perf.msNow || perf.mozNow || Date.now;

Engine = (function(_super) {

  __extends(Engine, _super);

  function Engine() {
    Engine.__super__.constructor.apply(this, arguments);
  }

  Engine.prototype.type = 'engine';

  Engine.prototype.init = function(element) {
    var Console, Input,
      _this = this;
    this.element = element;
    this.time = 0.0;
    this.lastTime = 0.0;
    this.frame = 0;
    this.tail = 0.0;
    this.debug = {
      profile: 0,
      step: false,
      time: true
    };
    this.samples = {
      dt: 0,
      lag: 0,
      tick: 0,
      update: 0,
      fixedUpdate: 0,
      render: 0
    };
    this.fdt = 1 / 60;
    this.dtCap = 0.5;
    this.fdtCap = this.fdt * 5;
    this.scale = 1;
    Input = require('./input');
    Input.alloc(this);
    Console = require('./console');
    Console.alloc(this);
    return this.tickBound = function(now) {
      return _this.tick(now);
    };
  };

  Engine.prototype.play = function(scene) {
    this.scene = scene;
    this.input.root = this.scene;
    if (!this.running) {
      return this.start();
    }
  };

  Engine.prototype.start = function() {
    this.running = true;
    requestAnimationFrame(this.tickBound);
    return this;
  };

  Engine.prototype.tick = function(time) {
    var ctx, debug, dt, fdt, lag, ping, pingTick, pong, samples, tail;
    this.time = time = (time && time < 1e12 ? time : perf.now()) / 1000;
    debug = this.debug, samples = this.samples, fdt = this.fdt;
    if (this.lastTime) {
      if ((dt = time - this.lastTime) > 0.5) {
        dt = fdt;
      } else if (dt > 0.01) {
        samples.dt = dt;
        if ((lag = time - samples.next) > 0) {
          samples.lag = lag;
        }
      }
      this.dt = (dt *= this.scale);
      this.frame++;
      if (debug.profile && !debug.profileFrom) {
        debug.profileFrom = debug.profile;
        console.profile("Frame " + debug.profileFrom);
      }
      pingTick = ping = perf.now();
      tail = Math.min(this.tail + dt, this.fdtCap * this.scale);
      while (tail > fdt) {
        tail -= fdt;
        Pool.invoke('fixedUpdate', fdt);
        Pool.invoke('simulate', fdt);
      }
      this.tail = tail;
      pong = perf.now();
      samples.fixedUpdate = pong - ping;
      ping = pong;
      Pool.invoke('update', dt);
      Pool.invoke('lateUpdate', dt);
      pong = perf.now();
      samples.update = pong - ping;
      ping = pong;
      ctx = this.renderer.save();
      Pool.invoke('render', ctx, dt);
      this.renderer.restore();
      pong = perf.now();
      samples.render = pong - ping;
      samples.tick = pong - pingTick;
      if (debug.step) {
        debugger;
      }
      if (debug.profileFrom) {
        if (!--debug.profile) {
          console.profileEnd("Frame " + debug.profileFrom);
          debug.profileFrom = 0;
        }
      }
    }
    this.lastTime = time;
    samples.next = time + 1 / 60;
    this.pub('onTimeEnd', samples);
    if (this.running) {
      requestAnimationFrame(this.tickBound);
    }
    return this;
  };

  Engine.prototype.startStats = function() {
    var el, stats;
    if (this.debug._stats || !window.Stats) {
      return;
    }
    this.debug._stats = stats = new Stats();
    el = stats.domElement;
    el.style.position = 'absolute';
    el.style.left = 0;
    el.style.top = 0;
    document.body.appendChild(el);
    return this;
  };

  return Engine;

})(Composite);

engine = new Engine();

if ('console' in window) {
  console.m = {
    pool: function() {
      Pool.dump();
      return null;
    },
    profile: function(frames) {
      if (frames == null) {
        frames = 60;
      }
      engine.debug.profile = frames;
      return null;
    },
    step: function() {
      engine.debug.step = !engine.debug.step;
      return null;
    }
  };
}

module.exports = engine;

},{"./composite":5,"./pool":7,"./math":2,"./input":14,"./console":15}],6:[function(require,module,exports){// Generated by CoffeeScript 1.5.0
var Component;

require('./math');

Component = (function() {

  function Component() {}

  Component.prototype.type = 'component';

  Component.prototype.toString = function() {
    return "Component " + this.type + "#" + this.uid + " [^ " + this.parent + "]";
  };

  Component.prototype.alloc = function(presets) {
    var component, components, type;
    this.parent.components[this.type] = this;
    this.parent[this.type] = this;
    components = this.parent.components;
    for (type in components) {
      if (!(type !== this.type)) {
        continue;
      }
      this[type] = component = components[type];
      component[this.type] = this;
    }
    if (this.reset) {
      this.reset(presets);
    }
    return this;
  };

  Component.prototype.free = function() {
    var components, type;
    delete this.parent.components[this.type];
    this.parent[this.type] = null;
    components = this.parent.components;
    for (type in components) {
      if (!(type !== this.type)) {
        continue;
      }
      this[components[type].type] = null;
      components[type][this.type] = null;
    }
    this.pool.free(this);
    return this;
  };

  Component.prototype.enable = function(state) {
    this.enabled = state != null ? state : state = !this.state;
    this.parent.pub('onComponent' + (state ? 'Enable' : 'Disable'), this);
    return this;
  };

  Component.prototype.sub = function(scope, topic, method) {
    if (scope == null) {
      scope = this;
    }
    this.parent.sub(scope, topic, method);
    return this;
  };

  return Component;

})();

module.exports = Component;

},{"./math":2}],7:[function(require,module,exports){// Generated by CoffeeScript 1.5.0
var Pool, fn, _i, _len, _ref;

require('./math');

Pool = (function() {

  Pool.typedHooks = ['fixedUpdate', 'simulate', 'update', 'lateUpdate', 'render'];

  Pool.regxHook = /^on[A-Z]/;

  Pool.regxGetter = /^get[A-Z]/;

  Pool.hooks = {};

  Pool.types = {};

  Pool.defaults = {};

  Pool.order = {
    render: false
  };

  Pool.prototype.toString = function() {
    return "Pool {@type} [" + this.roster.length + "]";
  };

  function Pool(cls) {
    var fn, key, keys, proto, types, _i, _j, _len, _len1,
      _this = this;
    this.cls = cls;
    proto = cls.prototype;
    proto.pool = this;
    cls.pool = this;
    this.roster = [];
    this.subs = [];
    this.hooks = [];
    this.enabled = false;
    this.allocd = 0;
    this.type = proto.type;
    if (this.type) {
      Pool.types[this.type] = this;
    }
    this.isComponent = this.type && this.type !== 'composite';
    this.light = (!this.isComponent) || proto.light || false;
    this.layer = proto.layer || cls.layer || 0;
    if (this.isComponent) {
      if (!this.light) {
        types = Pool.typedHooks;
        keys = Object.keys(proto).concat(Object.keys(cls));
        for (_i = 0, _len = keys.length; _i < _len; _i++) {
          fn = keys[_i];
          if (Pool.regxHook.test(fn)) {
            if (!~types.indexOf(fn)) {
              types.push(fn);
              Pool.hooks[fn] = [];
            }
            this.subs.push(fn);
          } else if (Pool.regxGetter.test(fn)) {
            key = fn.substr(3, 1).toLowerCase() + fn.substr(4);
            Pool.defineGetter(proto, key, fn);
          }
        }
        for (_j = 0, _len1 = types.length; _j < _len1; _j++) {
          fn = types[_j];
          if (fn in cls) {
            this[fn] = cls[fn];
            Pool.hooks[fn].push(this);
          } else if (fn in proto) {
            this.hooks.push(fn);
          }
        }
      }
    }
    cls.alloc = function(parent, presets) {
      return _this.alloc(parent, presets);
    };
  }

  Pool.prototype.preinstantiate = function(i) {
    while (i--) {
      this.instantiate();
    }
    return this;
  };

  Pool.prototype.instantiate = function() {
    var cls, hook, _i, _len, _ref;
    cls = new this.cls();
    this.roster.push(cls);
    _ref = this.hooks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      hook = _ref[_i];
      Pool.hooks[hook].push(cls);
    }
    return cls;
  };

  Pool.prototype.alloc = function(parent, presets) {
    var defaults, entity, hook, i, roster, topic, uid, _i, _j, _len, _len1, _ref, _ref1;
    roster = this.roster;
    i = roster.length;
    while (i--) {
      if (!roster[i].allocd) {
        entity = roster[i];
        break;
      }
    }
    if (!entity) {
      entity = this.instantiate();
    }
    this.allocd++;
    this.enabled = true;
    _ref = this.hooks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      hook = _ref[_i];
      if (hook in Pool.order) {
        Pool.order[hook] = true;
      }
    }
    entity.uid = uid = Math.uid();
    entity.enabled = true;
    entity.allocd = true;
    entity.parent = parent || null;
    entity.root = parent && parent.root || parent || entity;
    entity.layer = (parent && parent.layer || 0) + this.layer + 2 - 1 / uid;
    if (entity.root.descendants) {
      entity.root.descendants[uid] = entity;
    } else {
      entity.descendants = {};
    }
    if (this.isComponent) {
      if (defaults = entity.presets) {
        if (presets && !presets._merged) {
          presets.__proto__ = defaults;
          presets._merged = true;
        }
      }
      _ref1 = this.subs;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        topic = _ref1[_j];
        parent.sub(entity, topic);
      }
    }
    entity.alloc(presets || defaults || null);
    return entity;
  };

  Pool.prototype.free = function(entity) {
    if (entity.root === entity) {
      entity.descendants = null;
    } else if (entity.root.descendants) {
      delete entity.root.descendants[entity.uid];
    }
    entity.enabled = false;
    entity.allocd = false;
    entity.uid = null;
    entity.root = null;
    entity.parent = null;
    this.enabled = this.allocd-- > 1;
    return this;
  };

  Pool.prototype.invoke = function(fn, a0, a1, a2, a3) {
    var i, stack;
    stack = this.roster;
    i = this.roster.length;
    while (i--) {
      if (stack[i].enabled) {
        stack[i][fn](a0, a1, a2, a3);
      }
    }
    return this;
  };

  return Pool;

})();

_ref = Pool.typedHooks;
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
  fn = _ref[_i];
  Pool.hooks[fn] = [];
}

Pool.dump = function(free) {
  var pool, type, _ref1;
  _ref1 = Pool.types;
  for (type in _ref1) {
    pool = _ref1[type];
    console.log("%s: %d/%d allocd", type, pool.allocd, pool.roster.length);
  }
  if (free) {
    Pool.free();
  }
  return null;
};

Pool.defineGetter = function(proto, key, fn) {
  Object.defineProperty(proto, key, {
    get: proto[fn],
    enumerable: true,
    configurable: true
  });
  return proto;
};

Pool.free = function() {
  var freed, i, pool, roster, type, _ref1;
  _ref1 = Pool.types;
  for (type in _ref1) {
    pool = _ref1[type];
    roster = pool.roster;
    i = roster.length;
    freed = 0;
    while (i--) {
      if (!(!roster[i].allocd)) {
        continue;
      }
      roster.splice(i, 1);
      freed++;
    }
    console.log("%s: %d/%d freed", type, freed, pool.roster.length);
  }
  return this;
};

Pool.invoke = function(fn, a0, a1, a2, a3) {
  var i, stack;
  if ((stack = this.hooks[fn]) && (i = stack.length)) {
    if (Pool.order[fn]) {
      stack.sort(Pool.orderFn);
      Pool.order[fn] = false;
    }
    while (i--) {
      if (stack[i].enabled) {
        stack[i][fn](a0, a1, a2, a3);
      }
    }
  }
  return this;
};

Pool.orderFn = function(a, b) {
  return b.layer - a.layer;
};

module.exports = Pool;

},{"./math":2}],8:[function(require,module,exports){// Generated by CoffeeScript 1.5.0
var Component, Pool, SpriteAsset, SpriteSheet, SpriteTween, Vec2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Vec2 = require('./math').Vec2;

Component = require('./component');

Pool = require('./pool');

SpriteAsset = (function() {

  function SpriteAsset(srcOrRepaint, size, baseScale) {
    var img,
      _this = this;
    this.baseScale = baseScale != null ? baseScale : 1;
    this.size = Vec2(size);
    this.bufferSize = Vec2(size);
    this.defaultAlign = Vec2.center;
    this.defaultOffset = Vec2();
    this.defaultScale = Vec2(1, 1);
    this.buffer = document.createElement('canvas');
    this.bufferCtx = this.buffer.getContext('2d');
    this.scale = 1;
    switch (typeof srcOrRepaint) {
      case 'string':
        this.src = srcOrRepaint;
        this.img = img = new Image();
        img.onload = function() {
          if (!img.onload) {
            return;
          }
          img.onload = null;
          Vec2.set(_this.size, img.width, img.height);
          return _this.refresh();
        };
        img.src = srcOrRepaint;
        if (img.onload && img.width && img.height) {
          img.onload();
        }
        break;
      case 'function':
        this.repaint = srcOrRepaint;
        this.refresh();
        break;
    }
  }

  SpriteAsset.prototype.toString = function() {
    return "SpriteAsset " + (Vec2.toString(this.size)) + " " + (Vec2.toString(this.bufferSize)) + "x\n" + (this.src || this.repaint) + "\n" + (this.buffer.toDataURL());
  };

  SpriteAsset.prototype.draw = function(ctx, toPos, align, size, fromPos, scale) {
    if (toPos == null) {
      toPos = Vec2.zero;
    }
    if (align == null) {
      align = this.defaultAlign;
    }
    if (size == null) {
      size = this.bufferSize;
    }
    if (fromPos == null) {
      fromPos = this.defaultOffset;
    }
    if (scale == null) {
      scale = this.defaultScale;
    }
    if (this.ready) {
      ctx.drawImage(this.buffer, fromPos[0] | 0, fromPos[1] | 0, size[0], size[1], toPos[0] - size[0] / 2 * (align[0] + 1) | 0, toPos[1] - size[1] / 2 * (align[1] + 1) | 0, size[0] * scale[0], size[1] * scale[1]);
    }
    return this;
  };

  SpriteAsset.prototype.repaint = function() {
    var size;
    size = this.size;
    this.buffer.width = size[0];
    this.buffer.height = size[1];
    this.bufferCtx.drawImage(this.img, 0, 0, size[0], size[1]);
    this.sample();
    return this;
  };

  SpriteAsset.prototype.sample = function() {
    var bufferCtx, data, i, scale, size, x, y, _i, _j, _ref, _ref1;
    scale = this.scale, size = this.size, bufferCtx = this.bufferCtx;
    data = bufferCtx.getImageData(0, 0, size[0], size[1]).data;
    this.buffer.width = this.bufferSize[0];
    this.buffer.height = this.bufferSize[1];
    for (x = _i = 0, _ref = size[0]; _i <= _ref; x = _i += 1) {
      for (y = _j = 0, _ref1 = size[1]; _j <= _ref1; y = _j += 1) {
        i = (y * size[0] + x) * 4;
        bufferCtx.fillStyle = "rgba(" + data[i] + ", " + data[i + 1] + ", " + data[i + 2] + ", " + (data[i + 3] / 255) + ")";
        bufferCtx.fillRect(x * scale, y * scale, scale, scale);
      }
    }
    return this;
  };

  SpriteAsset.prototype.refresh = function(scale) {
    scale = (scale || 1) * this.baseScale;
    if (!this.ready || this.scale !== scale) {
      this.scale = scale;
      this.buffer.width = this.bufferSize[0] = this.size[0] * scale | 0;
      this.buffer.height = this.bufferSize[1] = this.size[1] * scale | 0;
      Vec2.scal(this.bufferSize, -0.5, this.defaultOffset);
      this.repaint(this.bufferCtx, scale);
      this.ready = true;
    }
    return this;
  };

  return SpriteAsset;

})();

SpriteSheet = (function() {

  function SpriteSheet(presets) {
    var frame, id, sequences, sprites, _base, _base1, _base2, _i, _len, _ref, _ref1, _ref2, _ref3;
    sprites = presets.sprites || [];
    this.sprites = Array.isArray(sprites) ? sprites : [sprites];
    this.frames = [];
    if (Array.isArray(presets.frames)) {
      _ref = presets.frames;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        frame = _ref[_i];
        this.frames.push(frame);
      }
    }
    this.defaults = {};
    if ((_ref1 = (_base = this.defaults).speed) == null) {
      _base.speed = presets.speed || 0.2;
    }
    if ((_ref2 = (_base1 = this.defaults).size) == null) {
      _base1.size = presets.size || Vec2(1, 1);
    }
    if ((_ref3 = (_base2 = this.defaults).align) == null) {
      _base2.align = presets.align || Vec2.center;
    }
    this.sequences = {};
    sequences = presets.sequences || {};
    for (id in sequences) {
      this.addSequence(id, sequences[id]);
    }
  }

  SpriteSheet.prototype.addSequence = function(id, sequence) {
    var frame, frames, _i, _ref, _ref1;
    if (Array.isArray(sequence)) {
      frames = [];
      for (frame = _i = _ref = sequence[0], _ref1 = sequence[1]; _i <= _ref1; frame = _i += 1) {
        frames.push(frame);
      }
      sequence = {
        frames: frames,
        next: sequence[2] || null,
        speed: sequence[3] || this.defaults.speed,
        name: id,
        sprite: sequence[4] || 0
      };
    }
    if (sequence.next === true) {
      sequence.next = id;
    }
    if (!sequence.speed) {
      sequence.speed = this.defaults.speed;
    }
    this.sequences[id] = sequence;
    if (!this.defaultSequence) {
      this.defaultSequence = id;
    }
    return this;
  };

  SpriteSheet.prototype.prepare = function() {
    var align, cols, rows, size, sprite, sprites, x, y, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2;
    sprites = this.sprites;
    for (_i = 0, _len = sprites.length; _i < _len; _i++) {
      sprite = sprites[_i];
      if (!sprite.ready) {
        return false;
      }
    }
    if (!this.frames.length) {
      _ref = this.defaults, size = _ref.size, align = _ref.align;
      for (_j = 0, _len1 = sprites.length; _j < _len1; _j++) {
        sprite = sprites[_j];
        cols = sprite.size[0] / size[0] | 0;
        rows = sprite.size[1] / size[1] | 0;
        for (y = _k = 0, _ref1 = rows - 1; _k <= _ref1; y = _k += 1) {
          for (x = _l = 0, _ref2 = cols - 1; _l <= _ref2; x = _l += 1) {
            this.frames.push({
              sprite: sprite,
              pos: Vec2(x * size[0], y * size[1]),
              size: size,
              align: align || Vec2.center
            });
          }
        }
      }
    }
    this.ready = true;
    return this;
  };

  SpriteSheet.prototype.draw = function(ctx, frame) {
    if (!this.ready && !this.prepare()) {
      return this;
    }
    frame = this.frames[frame || 0];
    frame.sprite.draw(ctx, null, frame.align, frame.size, frame.pos);
    return this;
  };

  return SpriteSheet;

})();

SpriteTween = (function(_super) {

  __extends(SpriteTween, _super);

  function SpriteTween() {
    SpriteTween.__super__.constructor.apply(this, arguments);
  }

  SpriteTween.prototype.type = 'spriteTween';

  SpriteTween.prototype.presets = {
    asset: null,
    speed: null,
    sequence: null,
    offset: 0,
    composite: null
  };

  SpriteTween.prototype.reset = function(presets) {
    var _ref;
    this.asset = presets.asset, this.composite = presets.composite;
    this.isSheet = this.asset instanceof SpriteSheet;
    if (this.isSheet) {
      this.frame = 0;
      this.sequence = presets.sequence, this.speed = presets.speed;
      if ((_ref = this.speed) == null) {
        this.speed = this.asset.defaults.speed;
      }
      this.dtime = presets.offset;
      if (!this.sequence) {
        this.sequence = this.asset.defaultSequence;
      }
    }
    return this;
  };

  SpriteTween.prototype.lateUpdate = function(dt) {
    var dtime, frame, frameCount, frames, sequence, speed;
    if (this.isSheet && !this.paused) {
      dtime = (this.dtime += dt);
      if (this.sequence) {
        sequence = this.asset.sequences[this.sequence];
        speed = sequence.speed;
        frames = sequence.frames;
        frameCount = frames.length;
        if (dtime >= frameCount * speed) {
          this.parent.pub('onSequenceEnd');
          if (sequence.next) {
            if (sequence.next !== this.sequence) {
              return this.goto(sequence.next);
            }
          } else {
            this.pause();
            return this;
          }
          dtime = dtime % (frameCount * speed);
        }
        this.frame = frames[dtime / speed | 0];
      } else {
        frames = this.asset.frames;
        frameCount = frames.length;
        speed = this.speed;
        dtime = dtime % (frameCount * speed);
        frame = dtime / speed | 0;
        if (frame < this.frame) {
          this.parent.pub('onSequenceEnd');
        }
        this.frame = dtime / speed | 0;
      }
    }
    return this;
  };

  SpriteTween.prototype.render = function(ctx, dt) {
    ctx.save();
    this.transform.applyMatrix(ctx);
    if (this.composite) {
      ctx.globalCompositeOperation = this.composite;
    }
    this.asset.draw(ctx, this.frame);
    ctx.restore();
    return this;
  };

  SpriteTween.prototype.pause = function() {
    this.paused = true;
    return this;
  };

  SpriteTween.prototype.play = function() {
    this.paused = false;
    return this;
  };

  SpriteTween.prototype.goto = function(id) {
    if (isNaN(id)) {
      if (this.sequence !== id) {
        this.dtime = 0;
        this.sequence = id;
      }
    } else {
      this.sequence = null;
      this.frameIndex = id;
    }
    return this;
  };

  return SpriteTween;

})(Component);

new Pool(SpriteTween);

module.exports.Asset = SpriteAsset;

module.exports.Tween = SpriteTween;

module.exports.Sheet = SpriteSheet;

},{"./math":2,"./component":6,"./pool":7}],9:[function(require,module,exports){// Generated by CoffeeScript 1.5.0
var Component, Pool, Transform, Vec2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

Transform = (function(_super) {

  __extends(Transform, _super);

  Transform.prototype.type = 'transform';

  Transform.prototype.presets = {
    pos: Vec2(),
    angle: 0
  };

  function Transform() {
    this.pos = Vec2();
  }

  Transform.prototype.reset = function(presets) {
    Vec2.copy(this.pos, presets.pos);
    this.worldAngle = this.angle = presets.angle;
    return this;
  };

  Transform.prototype.setTransform = function(pos, angle, silent) {
    if (pos != null) {
      Vec2.copy(this.pos, pos);
    }
    if (angle != null) {
      this.angle = angle;
    }
    this.dirty = true;
    if (!silent) {
      this.parent.pub('onTransform', this.pos, this.angle);
    }
    return this;
  };

  Transform.prototype.toWorld = function() {
    this.worldPos.copy(this.pos);
    this.worldAngle = this.angle;
    return this;
  };

  Transform.prototype.applyMatrix = function(ctx) {
    ctx.translate(this.pos[0] | 0, this.pos[1] | 0);
    if (this.angle) {
      ctx.rotate(this.angle);
    }
    return this;
  };

  return Transform;

})(Component);

new Pool(Transform);

module.exports = Transform;

},{"./component":6,"./pool":7,"./math":2}],10:[function(require,module,exports){// Generated by CoffeeScript 1.5.0
var Border, Component, Engine, Pool, Vec2, pos,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

Engine = require('./engine');

Border = (function(_super) {

  __extends(Border, _super);

  function Border() {
    Border.__super__.constructor.apply(this, arguments);
  }

  Border.prototype.type = 'border';

  Border.prototype.presets = {
    mode: 'bounce',
    restitution: 1
  };

  Border.prototype.reset = function(presets) {
    this.mode = presets.mode, this.restitution = presets.restitution;
    return this;
  };

  return Border;

})(Component);

pos = Vec2();

Border.simulate = function(dt) {
  var border, bounce, diff, hit, horizontal, kinetic, mirror, mode, parent, radius, restitution, size, vel, vertical, viewport, _i, _len, _ref;
  size = Engine.renderer.content;
  viewport = Engine.renderer.pos;
  horizontal = Vec2.set(Vec2.cache[0], viewport[0], viewport[0] + size[0]);
  vertical = Vec2.set(Vec2.cache[1], viewport[1], viewport[1] + size[1]);
  _ref = this.roster;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    border = _ref[_i];
    if (!border.enabled) {
      continue;
    }
    parent = border.parent, restitution = border.restitution, mode = border.mode, kinetic = border.kinetic;
    vel = null;
    if (kinetic) {
      if (!kinetic.enabled || kinetic.sleeping) {
        continue;
      }
      vel = kinetic.vel;
    }
    mirror = mode === 'mirror';
    bounce = mode === 'bounce' && vel;
    Vec2.copy(pos, parent.transform.pos);
    radius = parent.bounds.radius;
    if (mirror) {
      radius *= -1;
    }
    hit = 0;
    if ((diff = pos[0] - radius - horizontal[0]) < 0) {
      if (mirror) {
        pos[0] = horizontal[1] - radius;
      } else {
        pos[0] -= diff;
        if (bounce) {
          vel[0] *= -restitution;
        }
      }
      hit = -1;
    } else {
      diff = pos[0] + radius - horizontal[1];
      if (diff > 0) {
        if (mirror) {
          pos[0] = radius;
        } else {
          pos[0] -= diff;
          if (bounce) {
            vel[0] *= -restitution;
          }
        }
        hit = -1;
      }
    }
    if ((diff = pos[1] - radius - vertical[0]) < 0) {
      if (mirror) {
        pos[1] = vertical[1] - radius;
      } else {
        pos[1] -= diff;
        if (bounce) {
          vel[1] *= -restitution;
        }
      }
      hit = 1;
    } else {
      diff = pos[1] + radius - vertical[1];
      if (diff > 0) {
        if (mirror) {
          pos[1] = radius;
        } else {
          pos[1] -= diff;
          if (bounce) {
            vel[1] *= -restitution;
          }
        }
        hit = 1;
      }
    }
    if (hit != null) {
      parent.transform.setTransform(pos);
      parent.pub('onBorder', hit);
      if (border.mode === 'kill') {
        parent.free();
      }
    }
  }
  return this;
};

new Pool(Border);

module.exports = Border;

},{"./component":6,"./pool":7,"./math":2,"./engine":3}],11:[function(require,module,exports){// Generated by CoffeeScript 1.5.0
var Collider, Component, Engine, Pool, Vec2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

Engine = require('./engine');

Collider = (function(_super) {

  __extends(Collider, _super);

  function Collider() {
    Collider.__super__.constructor.apply(this, arguments);
  }

  Collider.prototype.type = 'collider';

  Collider.prototype.presets = {
    trigger: false
  };

  Collider.prototype.reset = function(presets) {
    this.trigger = presets.trigger;
    return this;
  };

  return Collider;

})(Component);

Collider.simulate = function(dt) {
  var collider1, collider2, colliders, diff, diffSq, i, j, kinetic1, kinetic2, mass1, mass2, n, p, parent1, parent2, pos1, pos2, radius1, radius2, radiusSum, vel1, vel2, vn1, vn2, vp1, vp1After, vp2, vp2After;
  colliders = this.roster;
  i = colliders.length;
  while (i--) {
    collider1 = colliders[i];
    if (!collider1.enabled) {
      continue;
    }
    j = i;
    while (j--) {
      collider2 = colliders[j];
      kinetic1 = collider1.kinetic;
      kinetic2 = collider2.kinetic;
      if (!collider2.enabled || (kinetic1.sleeping && kinetic2.sleeping)) {
        continue;
      }
      parent1 = collider1.parent;
      parent2 = collider2.parent;
      radius1 = parent1.radius || parent1.bounds.radius;
      radius2 = parent2.radius || parent2.bounds.radius;
      pos1 = parent1.transform.pos;
      pos2 = parent2.transform.pos;
      radiusSum = radius1 + radius2;
      diffSq = Vec2.distSq(pos1, pos2);
      if (diffSq > radiusSum * radiusSum) {
        continue;
      }
      p = Vec2.norm(Vec2.sub(pos1, pos2, Vec2.cache[0]));
      diff = Math.sqrt(diffSq);
      if (collider1.trigger || collider2.trigger) {
        parent1.pub('onTrigger', parent2, p, diff);
        parent2.pub('onTrigger', parent1, p, diff);
        continue;
      }
      diff -= radiusSum;
      vel1 = kinetic1.vel;
      vel2 = kinetic2.vel;
      mass1 = kinetic1.mass || 1;
      mass2 = kinetic2.mass || 1;
      if (diff < 0) {
        Vec2.add(pos1, Vec2.scal(p, -diff * 2 * radius1 / radiusSum, Vec2.cache[1]));
        Vec2.add(pos2, Vec2.scal(p, diff * 2 * radius2 / radiusSum, Vec2.cache[1]));
      }
      n = Vec2.perp(p, Vec2.cache[1]);
      vp1 = Vec2.dot(vel1, p);
      vn1 = Vec2.dot(vel1, n);
      vp2 = Vec2.dot(vel2, p);
      vn2 = Vec2.dot(vel2, n);
      vp1After = (mass1 * vp1 + mass2 * (2 * vp2 - vp1)) / (mass1 + mass2);
      vp2After = (mass1 * (2 * vp1 - vp2) + mass2 * vp2) / (mass1 + mass2);
      Vec2.add(Vec2.scal(p, vp1After, Vec2.cache[2]), Vec2.scal(n, vn1, Vec2.cache[3]), vel1);
      Vec2.add(Vec2.scal(p, vp2After, Vec2.cache[2]), Vec2.scal(n, vn2, Vec2.cache[3]), vel2);
      parent1.pub('onCollide', parent2, n);
      parent2.pub('onCollide', parent1, n);
    }
  }
  return this;
};

new Pool(Collider);

module.exports = Collider;

},{"./component":6,"./pool":7,"./math":2,"./engine":3}],12:[function(require,module,exports){// Generated by CoffeeScript 1.5.0
var Component, Force, Kinetic, Pool, Vec2, cache, copyVel,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Force = require('./force');

Vec2 = require('./math').Vec2;

cache = Vec2();

copyVel = Vec2();

Kinetic = (function(_super) {

  __extends(Kinetic, _super);

  Kinetic.prototype.type = 'kinetic';

  Kinetic.gravity = null;

  Kinetic.friction = 15;

  Kinetic.drag = 0.999;

  Kinetic.prototype.presets = {
    mass: 0,
    drag: Kinetic.drag,
    friction: Kinetic.friction,
    fixed: false,
    maxVel: 75,
    maxAcc: 2000,
    acc: Vec2(),
    vel: Vec2(),
    fast: false
  };

  function Kinetic() {
    this.vel = Vec2();
    this.acc = Vec2();
    this.sleepVelSq = 0.2;
  }

  Kinetic.prototype.reset = function(presets) {
    this.mass = presets.mass, this.drag = presets.drag, this.friction = presets.friction, this.fixed = presets.fixed, this.maxVel = presets.maxVel, this.maxAcc = presets.maxAcc, this.fast = presets.fast;
    Vec2.copy(this.vel, presets.vel);
    Vec2.copy(this.acc, presets.acc);
    this.pos = this.transform.pos;
    this.sleeping = false;
    return this;
  };

  Kinetic.prototype.applyImpulse = function(acc) {
    Vec2.add(this.acc, Vec2.scal(acc, 1 / (this.mass || 1), cache));
    return this;
  };

  Kinetic.prototype.applyForce = function(acc) {
    if (!this.force) {
      Force.alloc(this);
    }
    this.force.add(acc);
    return this;
  };

  return Kinetic;

})(Component);

Kinetic.simulate = function(dt) {
  var acc, epsilon, kinetic, vel, _i, _len, _ref;
  epsilon = Math.epsilon;
  _ref = this.roster;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    kinetic = _ref[_i];
    if (!(kinetic.enabled && !kinetic.fixed)) {
      continue;
    }
    vel = kinetic.vel;
    acc = kinetic.acc;
    if (kinetic.fast) {
      if (kinetic.maxAcc) {
        Vec2.limit(acc, kinetic.maxAcc);
      }
      Vec2.add(vel, Vec2.scal(acc, dt));
      Vec2.set(acc);
      if (kinetic.maxVel) {
        Vec2.limit(vel, kinetic.maxVel);
      }
      Vec2.add(kinetic.pos, Vec2.scal(vel, dt, cache));
      continue;
    }
    if (kinetic.root.gravity && kinetic.mass > epsilon) {
      Vec2.add(acc, Vec2.scal(kinetic.root.gravity, 1 / kinetic.mass, cache));
    }
    if (kinetic.friction) {
      Vec2.add(acc, Vec2.scal(Vec2.norm(vel, cache), -kinetic.friction));
    }
    if (kinetic.maxAcc) {
      Vec2.limit(acc, kinetic.maxAcc);
    }
    Vec2.copy(copyVel, vel);
    Vec2.add(vel, Vec2.scal(acc, dt));
    if (kinetic.maxVel) {
      Vec2.limit(vel, kinetic.maxVel);
    }
    Vec2.scal(Vec2.add(copyVel, vel), dt / 2);
    Vec2.add(kinetic.pos, copyVel);
    Vec2.add(vel, acc);
    if (kinetic.drag < 1) {
      Vec2.scal(vel, kinetic.drag);
    }
    if (kinetic.sleepVelSq) {
      if (Vec2.lenSq(vel) <= kinetic.sleepVelSq) {
        if (!kinetic.sleeping) {
          Vec2.set(vel);
          kinetic.sleeping = true;
          kinetic.parent.pubUp('onKineticSleep', kinetic);
        }
      } else {
        if (kinetic.sleeping) {
          kinetic.sleeping = false;
          kinetic.parent.pubUp('onKineticWake', kinetic);
        }
      }
    }
    Vec2.set(acc);
  }
  return this;
};

new Pool(Kinetic);

module.exports = Kinetic;

},{"./component":6,"./pool":7,"./force":16,"./math":2}],13:[function(require,module,exports){// Generated by CoffeeScript 1.5.0
var Bounds, BoundsDebug, Color, Component, Pool, Vec2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Color = require('./color');

Vec2 = require('./math').Vec2;

Bounds = (function(_super) {

  __extends(Bounds, _super);

  Bounds.prototype.type = 'bounds';

  Bounds.prototype.presets = {
    shape: 'rect',
    radius: 0,
    size: Vec2()
  };

  function Bounds() {
    this.size = Vec2();
  }

  Bounds.prototype.reset = function(presets) {
    Vec2.copy(this.size, presets.size);
    this.shape = presets.shape;
    this.radius = presets.radius;
    return this;
  };

  Bounds.prototype.getTop = function() {
    if (this.shape === 'circle') {
      return this.transform.pos[1] - this.radius;
    }
    return this.transform.pos[1];
  };

  Bounds.prototype.getBottom = function() {
    if (this.shape === 'circle') {
      return this.transform.pos[1] + this.radius;
    }
    return this.transform.pos[1] + this.size[1];
  };

  Bounds.prototype.intersectLine = function(p1, p2) {
    return null;
  };

  Bounds.prototype.intersect = function(bound) {
    return null;
  };

  Bounds.prototype.contains = function(point) {
    var pos;
    pos = this.transform.pos;
    switch (this.shape) {
      case 'circle':
        return Bounds.circPoint(pos, this.radius, point);
      case 'rect':
        return Bounds.rectPoint(pos, this.size, point);
    }
    return false;
  };

  Bounds.prototype.withinRect = function(pos, size) {
    var mypos;
    mypos = this.transform.pos;
    switch (this.shape) {
      case 'circle':
        return Bounds.rectCirc(pos, size, mypos, this.radius);
      case 'rect':
        return Bounds.rectRect(pos, size, mypos, this.size);
    }
    return false;
  };

  return Bounds;

})(Component);

Bounds.circPoint = function(center, radius, point) {
  return Vec2.distSq(point, center) <= radius * radius;
};

Bounds.rectPoint = function(pos, size, point) {
  return pos[0] - size[0] < point[0] && pos[1] < point[1] && pos[0] + size[0] > point[0] && pos[1] + size[1] > point[1];
};

Bounds.rectCirc = function(topLeft, size, center, radius) {
  var circleDistanceX, circleDistanceY, cornerDistance;
  circleDistanceX = Math.abs(center[0] - topLeft[0] - size[0] / 2);
  circleDistanceY = Math.abs(center[1] - topLeft[1] - size[1] / 2);
  if (circleDistanceX > (size[0] / 2 + radius) || circleDistanceY > (size[1] / 2 + radius)) {
    return false;
  }
  if (circleDistanceX <= size[0] / 2 || circleDistanceY <= size[1] / 2) {
    return true;
  }
  cornerDistance = Math.pow(circleDistanceX - size[0] / 2, 2) + Math.pow(circleDistanceY - size[1] / 2, 2);
  return cornerDistance <= Math.pow(radius, 2);
};

Bounds.rectRect = function(pos, size, pos2, size2) {
  return !(pos[0] > pos2[0] + size2[0] || pos[0] + size[0] < pos2[0] || pos[1] > pos2[1] + size2[1] || pos[1] + size[1] < pos2[1]);
};

Bounds.lineRect = function(point1, point2, topLeft, size) {
  var botOverlap, bottomIntersection, bottomPoint, c, m, topIntersection, topOverlap, topPoint, _ref, _ref1;
  this.topLeft = topLeft;
  this.size = size;
  m = (y2 - y1) / (x2 - x1);
  c = y1(-(m * x1));
  if (m > 0) {
    topIntersection = m * rx + c;
    bottomIntersection = m * (rx + rw) + c;
  } else {
    topIntersection = m * (rx + rw) + c;
    bottomIntersection = m * rx + c;
  }
  if (y1 < y2) {
    topPoint = y1;
    bottomPoint = y2;
  } else {
    topPoint = y2;
    bottomPoint = y1;
  }
  topOverlap = (_ref = topIntersection > topPoint) != null ? _ref : {
    topIntersection: topPoint
  };
  botOverlap = (_ref1 = bottomIntersection < bottomPoint) != null ? _ref1 : {
    bottomIntersection: bottomPoint
  };
  return (topOverlap < botOverlap) && (!((botOverlap < ry) || (topOverlap > ry + rh)));
};

Bounds.lineCirc = function(point1, point2, center, radius) {
  var a, b, bb4ac, c, dx, dy, ix1, ix2, iy1, iy2, mu, testX, testY;
  dx = x2 - x1;
  dy = y2 - y1;
  a = dx * dx + dy * dy;
  b = 2 * (dx * (x1 - cx) + dy * (y1 - cy));
  c = cx * cx + cy * cy;
  c += x1 * x1 + y1 * y1;
  c -= 2 * (cx * x1 + cy * y1);
  c -= cr * cr;
  bb4ac = b * b - 4 * a * c;
  if (bb4ac < 0) {
    return false;
  }
  mu = (-b + sqrt(b * b - 4 * a * c)) / (2 * a);
  ix1 = x1 + mu * dx;
  iy1 = y1 + mu * dy;
  mu = (-b - sqrt(b * b - 4 * a * c)) / (2 * a);
  ix2 = x1 + mu * dx;
  iy2 = y1 + mu * dy;
  if (dist(x1, y1, cx, cy) < dist(x2, y2, cx, cy)) {
    testX = x2;
    testY = y2;
  } else {
    testX = x1;
    testY = y1;
  }
  if (dist(testX, testY, ix1, iy1) < dist(x1, y1, x2, y2) || dist(testX, testY, ix2, iy2) < dist(x1, y1, x2, y2)) {
    return true;
  }
  return false;
};

new Pool(Bounds);

BoundsDebug = (function(_super) {

  __extends(BoundsDebug, _super);

  BoundsDebug.prototype.type = 'boundsDebug';

  BoundsDebug.prototype.presets = {
    color: Color.white,
    opacity: 0.5,
    fill: false
  };

  function BoundsDebug() {
    this.color = Vec2();
  }

  BoundsDebug.prototype.reset = function(presets) {
    Vec2.copy(this.color, presets.color);
    this.opacity = presets.opacity, this.fill = presets.fill;
    return this;
  };

  BoundsDebug.prototype.render = function(ctx) {
    var bounds, size;
    bounds = this.bounds;
    ctx.save();
    if (this.fill) {
      ctx.fillStyle = Color.rgba(this.color, this.opacity * 0.5);
    }
    ctx.strokeStyle = Color.rgba(this.color, this.opacity);
    ctx.lineWidth = 1;
    this.transform.applyMatrix(ctx);
    if (bounds.shape === 'circle') {
      ctx.beginPath();
      ctx.lineTo(0, bounds.radius);
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, bounds.radius | 0, 0, Math.TAU);
      if (this.fill) {
        ctx.fill();
      }
      ctx.stroke();
    } else {
      size = bounds.size;
      ctx.strokeRect(-size[0] / 2 | 0, -size[1] / 2 | 0, size[0] | 0, size[1] | 0);
      if (this.fill) {
        ctx.fillRect(-size[0] / 2 | 0, -size[1] / 2 | 0, size[0] | 0, size[1] | 0);
      }
    }
    ctx.restore();
    return this;
  };

  return BoundsDebug;

})(Component);

new Pool(BoundsDebug);

Bounds.Debug = BoundsDebug;

module.exports = Bounds;

},{"./component":6,"./pool":7,"./color":17,"./math":2}],14:[function(require,module,exports){// Generated by CoffeeScript 1.5.0
var Component, Engine, Input, Pool, Vec2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

Engine = require('./engine');

Input = (function(_super) {

  __extends(Input, _super);

  Input.prototype.type = 'input';

  Input.prototype.support = {
    touch: 'ontouchstart' in window,
    orientation: 'ondeviceorientation' in window
  };

  function Input() {
    var code, key, type, _ref;
    this.queue = [];
    this.locks = {};
    this.pos = Vec2();
    this.prevPos = Vec2();
    this.touchState = null;
    this.axis = Vec2();
    this.mouseAxis = Vec2();
    this.orientation = Vec2();
    this.prevOrientation = Vec2();
    this.baseOrientation = Vec2();
    this.map = {
      32: 'space',
      192: 'debug',
      38: 'up',
      39: 'right',
      40: 'bottom',
      37: 'left'
    };
    this.axisMap = {
      left: Vec2(0, -1),
      right: Vec2(0, 1),
      up: Vec2(1, -1),
      bottom: Vec2(1, 1)
    };
    this.keyNames = [];
    this.keys = {};
    _ref = this.map;
    for (code in _ref) {
      key = _ref[code];
      if (!~this.keyNames.indexOf(key)) {
        this.keyNames.push(key);
        this.keys[key] = null;
      }
    }
    this.throttled = {
      mousemove: true,
      deviceorientation: true
    };
    this.lastEvent = null;
    this.events = this.support.touch ? {
      touchstart: 'startTouch',
      touchmove: 'moveTouch',
      touchend: 'endTouch',
      touchcancel: 'endTouch'
    } : {
      mousedown: 'startTouch',
      mousemove: 'moveTouch',
      mouseup: 'endTouch',
      keydown: 'keyStart',
      keyup: 'keyEnd'
    };
    for (type in this.events) {
      window.addEventListener(type, this, false);
    }
  }

  Input.prototype.handleEvent = function(event) {
    var type;
    if (event.metaKey) {
      return;
    }
    event.preventDefault();
    type = event.type;
    if (this.throttled[type] && this.lastEvent === type) {
      this.queue[this.queue.length - 1] = event;
    } else {
      this.lastEvent = type;
      this.queue.push(event);
    }
    return this;
  };

  Input.prototype.keyStart = function(event) {
    var axis, key;
    if ((key = this.map[event.keyCode]) && !this.keys[key]) {
      if (!this.lock('key-' + key)) {
        return false;
      }
      this.keys[key] = 'began';
      if ((axis = this.axisMap[key])) {
        this.axis[axis[0]] += axis[1];
      }
      Engine.pub('onKeyBegan', key);
    }
    return this;
  };

  Input.prototype.keyEnd = function(event) {
    var axis, key;
    if (key = this.map[event.keyCode]) {
      if (!this.lock('key-' + key)) {
        return false;
      }
      this.keys[key] = 'ended';
      if ((axis = this.axisMap[key])) {
        this.axis[axis[0]] -= axis[1];
      }
      Engine.pub('onKeyEnded', key);
    }
    return this;
  };

  Input.prototype.startTouch = function(event) {
    if (!this.lock('touch')) {
      return false;
    }
    this.resolve(event);
    if (!this.touchState && !event.metaKey) {
      this.touchState = 'began';
      Engine.pub('onTouchBegan');
    }
    return this;
  };

  Input.prototype.moveTouch = function(event) {
    var state;
    state = this.touchState;
    if ((state === 'began' || state === 'ended') && !this.lock('touch')) {
      return false;
    }
    this.resolve(event);
    if (state && state !== 'ended' && state !== 'moved') {
      this.touchState = 'moved';
    }
    return this;
  };

  Input.prototype.endTouch = function(event) {
    if (!this.lock('touch')) {
      return false;
    }
    this.resolve(event);
    if (this.touchState && (!this.support.touch || !event.targetTouches.length)) {
      Engine.pub('onTouchEnded');
      this.touchState = 'ended';
    }
    return this;
  };

  Input.prototype.calibrateOrientation = function() {
    this.baseOrientationTime = this.orientationTime;
    Vec2.copy(this.baseOrientation, this.orientation);
    Vec2.set(this.orientation);
    return this;
  };

  Input.prototype.deviceOrientation = function(event) {
    Vec2.copy(this.prevOrientation, this.orientation);
    Vec2.sub(Vec2.set(this.orientation, event.gamma | 0, event.beta | 0), this.baseOrientation);
    this.orientationTime = event.timeStamp / 1000;
    if (!this.baseOrientationTime) {
      this.calibrateOrientation();
    }
    return this;
  };

  Input.prototype.resolve = function(event) {
    var coords, renderer;
    coords = this.support.touch ? event.targetTouches[0] : event;
    if (coords) {
      this.prevTime = this.time;
      this.time = event.timeStamp / 1000;
      Vec2.copy(this.prevPos, this.pos);
      renderer = Engine.renderer;
      Vec2.set(this.pos, (coords.pageX - renderer.margin[0]) / renderer.scale | 0, (coords.pageY - renderer.margin[1]) / renderer.scale | 0);
    }
    return this;
  };

  Input.prototype.lock = function(key) {
    if (this.locks[key] === this.frame) {
      console.log('LOCKED: ' + key);
      return false;
    }
    this.locks[key] = this.frame;
    return true;
  };

  Input.prototype.lateUpdate = function(dt, scene) {
    var event, key, keys, queue, type, _i, _len, _ref;
    switch (this.touchState) {
      case 'began':
        this.touchState = 'stationary';
        break;
      case 'ended':
        this.touchState = null;
        break;
    }
    keys = this.keys;
    _ref = this.keyNames;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      switch (keys[key]) {
        case 'began':
          keys[key] = 'pressed';
          break;
        case 'ended':
          keys[key] = null;
          break;
      }
    }
    this.frame = Engine.frame;
    queue = this.queue;
    while ((event = queue[0])) {
      type = event.type;
      if (!this[this.events[type]](event)) {
        break;
      }
      queue.shift();
    }
    if (!queue.length) {
      this.lastEvent = null;
    }
    return this;
  };

  return Input;

})(Component);

new Pool(Input);

module.exports = Input;

},{"./component":6,"./pool":7,"./math":2,"./engine":3}],15:[function(require,module,exports){// Generated by CoffeeScript 1.5.0
var Component, Console, Engine, Pool, Vec2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

Engine = require('./engine');

Console = (function(_super) {

  __extends(Console, _super);

  Console.prototype.type = 'console';

  function Console() {
    this.colors = ['#eee', '#ff6', '#ffc266', '#f66'];
  }

  Console.prototype.presets = {
    css: '',
    container: null
  };

  Console.prototype.reset = function(presets) {
    var wrap;
    this.css = presets.css, this.container = presets.container;
    this.wrap = wrap = document.createElement('div');
    wrap.id = 'console';
    wrap.style.cssText = '\
			position: absolute;\
			left: 0;\
			top: 0;\
			overflow: hidden;\
			padding: 0;\
			opacity: 0.75;\
			width: 120px;\
			color: #fff;\
			background-color: #111;\
			font: 700 11px/15px Helvetica,Arial,sans-serif;\
		' + this.css;
    this.fpsSpan = document.createElement('span');
    this.tickSpan = document.createElement('span');
    this.fpsSpan.style.cssText = this.tickSpan.style.cssText = '\
			width: 50%;\
			padding: 0 3px;\
			display: inline-block;\
			-moz-box-sizing: border-box;\
			-webkit-box-sizing: border-box;\
		';
    wrap.appendChild(this.tickSpan);
    wrap.appendChild(this.fpsSpan);
    (this.container || document.body).appendChild(wrap);
    this.nullify();
    return this;
  };

  Console.prototype.free = function() {
    (this.container || document.body).removeChild(this.wrap);
    return Console.__super__.free.call(this);
  };

  Console.prototype.onTimeEnd = function(samples) {
    var color, colors, dt, fps, fpsMean, fpsSD, lag, tick, tickMean, tickSD, txt;
    this.dtSum += (dt = samples.dt);
    this.fpsSum += (fps = 1 / dt);
    this.fpsSq += fps * fps;
    this.lagSum += (lag = samples.lag);
    this.lagSq += lag * lag;
    this.tickSum += (tick = samples.tick);
    this.tickSq += tick * tick;
    this.updateSum += samples.update;
    this.fixedUpdateSum += samples.fixedUpdate;
    this.renderSum += samples.render;
    this.frames++;
    if (this.dtSum < 0.33) {
      return;
    }
    colors = this.colors;
    tickMean = this.tickSum / this.frames;
    tickSD = Math.sqrt((this.tickSq - (this.tickSum * this.tickSum / this.frames)) / (this.frames - 1));
    txt = "" + (Math.round(tickMean * 10) / 10) + " ±" + (Math.round(tickSD * 10) / 10);
    if (tickMean > 33) {
      color = colors[3];
    } else if (tickMean > 16) {
      color = colors[2];
    } else if (tickMean > 8) {
      color = colors[1];
    } else {
      color = colors[0];
    }
    this.tickSpan.textContent = txt;
    this.tickSpan.style.color = color;
    fpsMean = this.fpsSum / this.frames;
    debugger;
    fpsSD = Math.sqrt((this.fpsSq - (this.fpsSum * this.fpsSum / this.frames)) / (this.frames - 1));
    txt = "" + (Math.round(fpsMean || 0)) + " ±" + (Math.round(fpsSD || 0));
    if (fpsMean < 30) {
      color = colors[3];
    } else if (fpsMean < 40) {
      color = colors[2];
    } else if (fpsMean < 55) {
      color = colors[1];
    } else {
      color = colors[0];
    }
    this.fpsSpan.textContent = txt;
    this.fpsSpan.style.color = color;
    this.nullify();
    return this;
  };

  Console.prototype.nullify = function() {
    this.dtSum = 0;
    this.fpsSum = this.fpsSq = 0;
    this.tickSum = this.tickSq = 0;
    this.lagSum = this.lagSq = 0;
    this.fixedUpdateSum = 0;
    this.updateSum = 0;
    this.renderSum = 0;
    this.frames = 0;
    return this;
  };

  return Console;

})(Component);

new Pool(Console);

module.exports = Console;

},{"./component":6,"./pool":7,"./math":2,"./engine":3}],16:[function(require,module,exports){// Generated by CoffeeScript 1.5.0
var Component, Force, Pool, Vec2, cache,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

cache = Vec2();

Force = (function(_super) {

  __extends(Force, _super);

  Force.prototype.type = 'force';

  Force.prototype.presets = {
    acc: Vec2(),
    torque: 0
  };

  function Force() {
    this.acc = Vec2();
  }

  Force.prototype.reset = function(presets) {
    Vec2.copy(this.acc, presets.acc);
    this.torque = presets.torque;
    this.age = 0;
    return this;
  };

  Force.prototype.add = function(acc) {
    Vec2.add(this.acc, acc);
    return this;
  };

  Force.prototype.simulate = function(dt) {
    Vec2.add(this.kinetic.acc, this.acc);
    return this;
  };

  return Force;

})(Component);

new Pool(Force);

module.exports = Force;

},{"./component":6,"./pool":7,"./math":2}],17:[function(require,module,exports){// Generated by CoffeeScript 1.5.0
var Color, typedArray;

require('./math');

typedArray = Math.TypedArray;

Color = function(fromOrR, g, b, a) {
  var _ref;
  if (g != null) {
    return new typedArray([fromOrR, g, b, a != null ? a : 1]);
  }
  if (fromOrR != null) {
    return new typedArray([fromOrR[0], fromOrR[1], fromOrR[2], (_ref = fromOrR[3]) != null ? _ref : 1]);
  }
  return new typedArray(Color.black);
};

Color.white = Color(255, 255, 255);

Color.black = Color(0, 0, 0);

Color.cache = [Color(), Color(), Color(), Color()];

Color.set = function(result, r, g, b, a) {
  result[0] = r || 0;
  result[1] = g || 0;
  result[2] = b || 0;
  result[3] = a || 0;
  return result;
};

Color.copy = function(result, b) {
  result[0] = b[0];
  result[1] = b[1];
  result[2] = b[2];
  result[3] = b[3];
  return result;
};

Color.lerp = function(a, b, t, alpha, result) {
  result || (result = a);
  result[0] = (1 - t) * a[0] + t * b[0];
  result[1] = (1 - t) * a[1] + t * b[1];
  result[2] = (1 - t) * a[2] + t * b[2];
  if (alpha > 0.05) {
    result[3] = (1 - t) * a[3] + t * b[3];
  } else {
    result[3] = a[3];
  }
  return result;
};

Color.lerpList = function(result, list, t) {
  var last, start, sub;
  last = list.length - 1;
  t = Math.clamp(t * last, 0, last);
  start = t | 0;
  sub = t - start;
  if (sub < 0.02) {
    return Color.copy(result, list[start]);
  }
  if (sub > 0.98) {
    return Color.copy(result, list[start + 1]);
  }
  return Color.lerp(list[start], list[start + 1], sub, null, result);
};

Color.variant = function(a, t, result) {
  t = Math.rand(-t, t);
  return Color.lerp(a, (t > 0 ? Color.white : Color.black), t, false, result);
};

Color.rgba = function(a, alpha) {
  alpha || (alpha = a[3]);
  if (alpha > 0.98) {
    return "rgb(" + (a[0] | 0) + ", " + (a[1] | 0) + ", " + (a[2] | 0) + ")";
  } else {
    return "rgba(" + (a[0] | 0) + ", " + (a[1] | 0) + ", " + (a[2] | 0) + ", " + alpha + ")";
  }
};

module.exports = Color;

},{"./math":2}]},{},[1]);