(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process','global'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/lib/core/renderer.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.4.0\nvar Bounds, Composite, Renderer, Vec2,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComposite = require('./composite');\n\nBounds = require('./bounds');\n\nVec2 = require('./math').Vec2;\n\nRenderer = (function(_super) {\n\n  __extends(Renderer, _super);\n\n  function Renderer(element, client) {\n    var fullscreenChange, self;\n    this.element = element;\n    this.client = Vec2(client);\n    this.content = Vec2(client);\n    this.canvas = document.createElement('canvas');\n    this.element.appendChild(this.canvas);\n    this.ctx = this.canvas.getContext('2d');\n    this.browser = Vec2();\n    this.margin = Vec2();\n    this.pos = Vec2();\n    this.scale = 0;\n    this.orientation = 'landscape';\n    this.buf = document.createElement('canvas');\n    this.bufctx = this.buf.getContext('2d');\n    window.addEventListener('resize', this, false);\n    window.addEventListener('orientationchange', this, false);\n    self = this;\n    fullscreenChange = function() {\n      return self.fullscreenChange();\n    };\n    document.addEventListener('fullscreenchange', fullscreenChange(false));\n    document.addEventListener('mozfullscreenchange', fullscreenChange, false);\n    document.addEventListener('webkitfullscreenchange', fullscreenChange, false);\n    this.reflow();\n    this;\n\n  }\n\n  Renderer.prototype.isFullscreen = function() {\n    var doc;\n    doc = document;\n    return doc.fullscreen || doc.mozFullScreen || doc.webkitIsFullScreen;\n  };\n\n  Renderer.prototype.requestFullscreen = function() {\n    var target;\n    if (!this.isFullscreen()) {\n      target = this.element.parentNode;\n      if ('webkitRequestFullScreen' in target) {\n        target.webkitRequestFullScreen();\n      } else if ('mozRequestFullScreen' in target) {\n        target.mozRequestFullScreen();\n      }\n    }\n    return this;\n  };\n\n  Renderer.prototype.fullscreenChange = function() {\n    if (this.orientation) {\n      this.lockOrientation(this.orientation);\n    }\n    return this;\n  };\n\n  Renderer.prototype.lockOrientation = function(format) {\n    var target;\n    if (format == null) {\n      format = this.orientation;\n    }\n    target = window.screen;\n    if ('lockOrientation' in target) {\n      screen.lockOrientation(format);\n    } else if ('mozLockOrientation' in target) {\n      screen.mozLockOrientation(format);\n    }\n    return this;\n  };\n\n  Renderer.prototype.handleEvent = function() {\n    return this.reflow();\n  };\n\n  Renderer.prototype.reflow = function() {\n    var scale;\n    Vec2.set(this.browser, window.innerWidth, window.innerHeight);\n    scale = Math.min(this.browser[0] / this.content[0], this.browser[1] / this.content[1]);\n    scale = Math.clamp((scale * 2 | 0) / 2, 0.5, 3);\n    if (scale !== this.scale) {\n      this.scale = scale;\n      Vec2.scal(this.content, this.scale, this.client);\n      this.buf.width = this.canvas.width = this.client[0];\n      this.buf.height = this.canvas.height = this.client[1];\n    }\n    return this.alignContainer();\n  };\n\n  Renderer.prototype.alignContainer = function() {\n    Vec2.scal(Vec2.sub(this.browser, this.client, this.margin), 0.5);\n    this.element.style.left = this.margin[0] + 'px';\n    this.element.style.top = this.margin[1] + 'px';\n    this.element.style.width = this.client[0] + 'px';\n    this.element.style.height = this.client[1] + 'px';\n    return this;\n  };\n\n  Renderer.prototype.save = function() {\n    this.bufctx.save();\n    this.bufctx.translate(this.pos[0] | 0, this.pos[1] | 0);\n    this.bufctx.clearRect(0, 0, this.client[0], this.client[1]);\n    this.bufctx.scale(this.scale, this.scale);\n    return this.bufctx;\n  };\n\n  Renderer.prototype.restore = function() {\n    this.bufctx.restore();\n    this.ctx.clearRect(0, 0, this.client[0], this.client[1]);\n    this.ctx.drawImage(this.buf, 0, 0);\n    return this;\n  };\n\n  Renderer.prototype.center = function(pos) {\n    Vec2.set(this.pos, pos[0] - this.client[0] / 2, pos[0] - this.client[1] / 2);\n    return this;\n  };\n\n  Renderer.prototype.cull = function(entity) {\n    var bounds;\n    if (!(bounds = entity.bounds)) {\n      return false;\n    }\n    if (bounds.withinRect(this.pos, this.content)) {\n      if (bounds.culled) {\n        bounds.culled = false;\n      }\n      return false;\n    }\n    if (!bounds.culled) {\n      bounds.culled = true;\n    }\n    return true;\n  };\n\n  return Renderer;\n\n})(Composite);\n\nmodule.exports = Renderer;\n\n//@ sourceURL=/lib/core/renderer.js"
));

require.define("/lib/core/border.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.4.0\nvar Border, Component, Engine, Pool, Vec2,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComponent = require('./component');\n\nPool = require('./pool');\n\nVec2 = require('./math').Vec2;\n\nEngine = require('./engine');\n\nBorder = (function(_super) {\n\n  __extends(Border, _super);\n\n  function Border() {\n    return Border.__super__.constructor.apply(this, arguments);\n  }\n\n  Border.prototype.type = 'border';\n\n  Border.prototype.reset = function() {\n    this.kill = null;\n    return this.bounciness = 1;\n  };\n\n  return Border;\n\n})(Component);\n\nBorder.simulate = function(dt) {\n  var border, bounciness, diff, hit, horizontal, parent, pos, radius, size, vel, vertical, viewport, _i, _len, _ref, _ref1;\n  size = Engine.renderer.content;\n  viewport = Engine.renderer.pos;\n  horizontal = Vec2.set(Vec2.cache[0], viewport[0], viewport[0] + size[0]);\n  vertical = Vec2.set(Vec2.cache[1], viewport[1], viewport[1] + size[1]);\n  _ref = this.roster;\n  for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n    border = _ref[_i];\n    if (!border.enabled) {\n      continue;\n    }\n    parent = border.parent;\n    bounciness = border.bounciness;\n    pos = parent.transform.pos;\n    vel = (_ref1 = parent.kinetic) != null ? _ref1.vel : void 0;\n    radius = parent.bounds.radius;\n    if (border.kill) {\n      radius *= -1;\n    }\n    hit = null;\n    diff = pos[0] - radius - horizontal[0];\n    if (diff < 0) {\n      pos[0] -= diff;\n      if (vel) {\n        vel[0] *= -bounciness;\n      }\n      hit = 0;\n    } else {\n      diff = pos[0] + radius - horizontal[1];\n      if (diff > 0) {\n        pos[0] -= diff;\n        if (vel) {\n          vel[0] *= -bounciness;\n        }\n        hit = 0;\n      }\n    }\n    diff = pos[1] - radius - vertical[0];\n    if (diff < 0) {\n      pos[1] -= diff;\n      if (vel) {\n        vel[1] *= -bounciness;\n      }\n      hit = 1;\n    } else {\n      diff = pos[1] + radius - vertical[1];\n      if (diff > 0) {\n        pos[1] -= diff;\n        if (vel) {\n          vel[1] *= -bounciness;\n        }\n        hit = 1;\n      }\n    }\n    if (hit != null) {\n      parent.pub('onBorder', hit);\n      if (border.kill) {\n        parent.free();\n      }\n    }\n  }\n  return this;\n};\n\nnew Pool(Border);\n\nmodule.exports = Border;\n\n//@ sourceURL=/lib/core/border.js"
));

require.define("/lib/core/bounds.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.4.0\nvar Bounds, Component, Pool, Vec2,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComponent = require('./component');\n\nPool = require('./pool');\n\nVec2 = require('./math').Vec2;\n\nBounds = (function(_super) {\n\n  __extends(Bounds, _super);\n\n  Bounds.prototype.type = 'bounds';\n\n  Bounds.prototype.presets = {\n    shape: 'rect',\n    radius: 0,\n    size: Vec2()\n  };\n\n  function Bounds() {\n    this.size = Vec2();\n  }\n\n  Bounds.prototype.reset = function(presets) {\n    Vec2.copy(this.size, presets.size);\n    this.shape = presets.shape;\n    this.radius = presets.radius;\n    return this;\n  };\n\n  Bounds.prototype.intersectLine = function(p1, p2) {\n    return null;\n  };\n\n  Bounds.prototype.intersect = function(bound) {\n    return null;\n  };\n\n  Bounds.prototype.contains = function(point) {\n    var pos;\n    pos = this.parent.transform.pos;\n    switch (this.shape) {\n      case 'circle':\n        return Bounds.circPoint(pos, this.radius, point);\n      case 'rect':\n        return Bounds.rectPoint(pos, this.size, point);\n    }\n    return false;\n  };\n\n  Bounds.prototype.withinRect = function(pos, size) {\n    var mypos;\n    mypos = this.parent.transform.pos;\n    switch (this.shape) {\n      case 'circle':\n        return Bounds.rectCirc(pos, size, mypos, this.radius);\n      case 'rect':\n        return Bounds.rectRect(pos, size, mypos, this.size);\n    }\n    return false;\n  };\n\n  return Bounds;\n\n})(Component);\n\nBounds.circPoint = function(center, radius, point) {\n  return Vec2.distSq(point, center) <= radius * radius;\n};\n\nBounds.rectPoint = function(pos, size, point) {\n  return pos[0] < point[0] && pos[1] < point[1] && pos[0] + size[0] > point[0] && pos[1] + size[1] > point[1];\n};\n\nBounds.rectCirc = function(topLeft, size, center, radius) {\n  var circleDistanceX, circleDistanceY, cornerDistance;\n  circleDistanceX = Math.abs(center[0] - topLeft[0] - size[0] / 2);\n  circleDistanceY = Math.abs(center[1] - topLeft[1] - size[1] / 2);\n  if (circleDistanceX > (size[0] / 2 + radius) || circleDistanceY > (size[1] / 2 + radius)) {\n    return false;\n  }\n  if (circleDistanceX <= size[0] / 2 || circleDistanceY <= size[1] / 2) {\n    return true;\n  }\n  cornerDistance = Math.pow(circleDistanceX - size[0] / 2, 2) + Math.pow(circleDistanceY - size[1] / 2, 2);\n  return cornerDistance <= Math.pow(radius, 2);\n};\n\nBounds.rectRect = function(pos, size, pos2, size2) {\n  return !(pos[0] > pos2[0] + size2[0] || pos[0] + size[0] < pos2[0] || pos[1] > pos2[1] + size2[1] || pos[1] + size[1] < pos2[1]);\n};\n\nBounds.lineRect = function(point1, point2, topLeft, size) {\n  var botOverlap, bottomIntersection, bottomPoint, c, m, topIntersection, topOverlap, topPoint, _ref, _ref1;\n  this.topLeft = topLeft;\n  this.size = size;\n  m = (y2 - y1) / (x2 - x1);\n  c = y1(-(m * x1));\n  if (m > 0) {\n    topIntersection = m * rx + c;\n    bottomIntersection = m * (rx + rw) + c;\n  } else {\n    topIntersection = m * (rx + rw) + c;\n    bottomIntersection = m * rx + c;\n  }\n  if (y1 < y2) {\n    topPoint = y1;\n    bottomPoint = y2;\n  } else {\n    topPoint = y2;\n    bottomPoint = y1;\n  }\n  topOverlap = (_ref = topIntersection > topPoint) != null ? _ref : {\n    topIntersection: topPoint\n  };\n  botOverlap = (_ref1 = bottomIntersection < bottomPoint) != null ? _ref1 : {\n    bottomIntersection: bottomPoint\n  };\n  return (topOverlap < botOverlap) && (!((botOverlap < ry) || (topOverlap > ry + rh)));\n};\n\nBounds.lineCirc = function(point1, point2, center, radius) {\n  var a, b, bb4ac, c, dx, dy, ix1, ix2, iy1, iy2, mu, testX, testY;\n  dx = x2 - x1;\n  dy = y2 - y1;\n  a = dx * dx + dy * dy;\n  b = 2 * (dx * (x1 - cx) + dy * (y1 - cy));\n  c = cx * cx + cy * cy;\n  c += x1 * x1 + y1 * y1;\n  c -= 2 * (cx * x1 + cy * y1);\n  c -= cr * cr;\n  bb4ac = b * b - 4 * a * c;\n  if (bb4ac < 0) {\n    return false;\n  }\n  mu = (-b + sqrt(b * b - 4 * a * c)) / (2 * a);\n  ix1 = x1 + mu * dx;\n  iy1 = y1 + mu * dy;\n  mu = (-b - sqrt(b * b - 4 * a * c)) / (2 * a);\n  ix2 = x1 + mu * dx;\n  iy2 = y1 + mu * dy;\n  if (dist(x1, y1, cx, cy) < dist(x2, y2, cx, cy)) {\n    testX = x2;\n    testY = y2;\n  } else {\n    testX = x1;\n    testY = y1;\n  }\n  if (dist(testX, testY, ix1, iy1) < dist(x1, y1, x2, y2) || dist(testX, testY, ix2, iy2) < dist(x1, y1, x2, y2)) {\n    return true;\n  }\n  return false;\n};\n\nnew Pool(Bounds);\n\nmodule.exports = Bounds;\n\n//@ sourceURL=/lib/core/bounds.js"
));

require.define("/lib/core/collider.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.4.0\nvar Collider, Component, Engine, Pool, Vec2,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComponent = require('./component');\n\nPool = require('./pool');\n\nVec2 = require('./math').Vec2;\n\nEngine = require('./engine');\n\nCollider = (function(_super) {\n\n  __extends(Collider, _super);\n\n  function Collider() {\n    return Collider.__super__.constructor.apply(this, arguments);\n  }\n\n  Collider.prototype.type = 'collider';\n\n  Collider.prototype.presets = {\n    trigger: false\n  };\n\n  Collider.prototype.reset = function(presets) {\n    this.trigger = presets.trigger;\n    return this;\n  };\n\n  return Collider;\n\n})(Component);\n\nCollider.simulate = function(dt) {\n  var collider1, collider2, colliders, diff, diffSq, i, j, kinetic1, kinetic2, mass1, mass2, n, p, parent1, parent2, pos1, pos2, radius1, radius2, radiusSum, vel1, vel2, vn1, vn2, vp1, vp1After, vp2, vp2After;\n  colliders = this.roster;\n  i = colliders.length;\n  while (i--) {\n    collider1 = colliders[i];\n    if (!collider1.enabled) {\n      continue;\n    }\n    j = i;\n    while (j--) {\n      collider2 = colliders[j];\n      kinetic1 = collider1.kinetic;\n      kinetic2 = collider2.kinetic;\n      if (!collider2.enabled || (kinetic1.sleeping && kinetic2.sleeping)) {\n        continue;\n      }\n      parent1 = collider1.parent;\n      parent2 = collider2.parent;\n      radius1 = parent1.radius || parent1.bounds.radius;\n      radius2 = parent2.radius || parent2.bounds.radius;\n      pos1 = parent1.transform.pos;\n      pos2 = parent2.transform.pos;\n      radiusSum = radius1 + radius2;\n      diffSq = Vec2.distSq(pos1, pos2);\n      if (diffSq > radiusSum * radiusSum) {\n        continue;\n      }\n      p = Vec2.norm(Vec2.sub(pos1, pos2, Vec2.cache[0]));\n      diff = Math.sqrt(diffSq);\n      if (collider1.trigger || collider2.trigger) {\n        parent1.pub('onTrigger', parent2, p, diff);\n        parent2.pub('onTrigger', parent1, p, diff);\n        continue;\n      }\n      diff -= radiusSum;\n      vel1 = kinetic1.vel;\n      vel2 = kinetic2.vel;\n      mass1 = kinetic1.mass || 1;\n      mass2 = kinetic2.mass || 1;\n      if (diff < 0) {\n        Vec2.add(pos1, Vec2.scal(p, -diff * 2 * radius1 / radiusSum, Vec2.cache[1]));\n        Vec2.add(pos2, Vec2.scal(p, diff * 2 * radius2 / radiusSum, Vec2.cache[1]));\n      }\n      n = Vec2.perp(p, Vec2.cache[1]);\n      vp1 = Vec2.dot(vel1, p);\n      vn1 = Vec2.dot(vel1, n);\n      vp2 = Vec2.dot(vel2, p);\n      vn2 = Vec2.dot(vel2, n);\n      vp1After = (mass1 * vp1 + mass2 * (2 * vp2 - vp1)) / (mass1 + mass2);\n      vp2After = (mass1 * (2 * vp1 - vp2) + mass2 * vp2) / (mass1 + mass2);\n      Vec2.add(Vec2.scal(p, vp1After, Vec2.cache[2]), Vec2.scal(n, vn1, Vec2.cache[3]), vel1);\n      Vec2.add(Vec2.scal(p, vp2After, Vec2.cache[2]), Vec2.scal(n, vn2, Vec2.cache[3]), vel2);\n      parent1.pub('onCollide', parent2, n);\n      parent2.pub('onCollide', parent1, n);\n    }\n  }\n  return this;\n};\n\nnew Pool(Collider);\n\nmodule.exports = Collider;\n\n//@ sourceURL=/lib/core/collider.js"
));

require.define("/lib/core/component.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.4.0\nvar Component;\n\nrequire('./math');\n\nComponent = (function() {\n\n  function Component() {}\n\n  Component.prototype.type = 'component';\n\n  Component.prototype.toString = function() {\n    return \"Component \" + this.type + \"#\" + this.uid + \" [\" + this.parent + \"]\";\n  };\n\n  Component.prototype.alloc = function(presets) {\n    var component, components, type;\n    this.parent.components[this.type] = this;\n    this.parent[this.type] = this;\n    components = this.parent.components;\n    for (type in components) {\n      if (!(type !== this.type)) {\n        continue;\n      }\n      this[type] = component = components[type];\n      component[this.type] = this;\n    }\n    if (this.reset) {\n      this.reset(presets);\n    }\n    return this;\n  };\n\n  Component.prototype.free = function() {\n    var components, type;\n    delete this.parent.components[this.type];\n    this.parent[this.type] = null;\n    components = this.parent.components;\n    for (type in components) {\n      if (!(type !== this.type)) {\n        continue;\n      }\n      this[components[type].type] = null;\n      components[type][this.type] = null;\n    }\n    this.pool.free(this);\n    return this;\n  };\n\n  Component.prototype.enable = function(state) {\n    this.enabled = state != null ? state : state = !this.state;\n    this.parent.pub('onComponent' + (state ? 'Enable' : 'Disable'), this);\n    return this;\n  };\n\n  Component.prototype.sub = function(scope, topic, method) {\n    if (scope == null) {\n      scope = this;\n    }\n    this.parent.sub(scope, topic, method);\n    return this;\n  };\n\n  return Component;\n\n})();\n\nmodule.exports = Component;\n\n//@ sourceURL=/lib/core/component.js"
));

require.define("/lib/core/composite.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.4.0\nvar Composite, Pool;\n\nPool = require('./pool');\n\nComposite = (function() {\n\n  function Composite() {\n    this.children = {};\n    this.components = {};\n  }\n\n  Composite.prototype.toString = function() {\n    return \"Composite \" + (this.name || this.type) + \"#\" + this.uid;\n  };\n\n  Composite.prototype.alloc = function(presets) {\n    var child, pool, preset, type, _i, _len;\n    if (this.parent) {\n      this.parent.children[this.uid] = this;\n    }\n    if (presets) {\n      for (type in presets) {\n        preset = presets[type];\n        switch (type) {\n          case 'children':\n            for (_i = 0, _len = preset.length; _i < _len; _i++) {\n              child = preset[_i];\n              Composite.alloc(this, child);\n            }\n            break;\n          case 'name':\n            this.name = presets[type];\n            break;\n          default:\n            if ((pool = Pool.types[type])) {\n              pool.alloc(this, preset);\n            }\n        }\n      }\n    }\n    return this;\n  };\n\n  Composite.prototype.free = function() {\n    var key, ref, refSubs, _i, _len;\n    if (refSubs = this.refSubs) {\n      for (_i = 0, _len = refSubs.length; _i < _len; _i++) {\n        ref = refSubs[_i];\n        ref.unsub(this);\n      }\n    }\n    this.refSubs = this.subs = null;\n    for (key in this.components) {\n      this.components[key].free();\n    }\n    for (key in this.children) {\n      this.children[key].free();\n    }\n    if (this.parent) {\n      delete this.parent.children[this.uid];\n    }\n    this.pool.free(this);\n    return this;\n  };\n\n  Composite.prototype.enable = function(state, deep) {\n    var key;\n    this.enabled = state != null ? state : state = !this.state;\n    this.parent.pub('on' + (state ? 'Enable' : 'Disable'), this);\n    for (key in this.components) {\n      this.components[key].enable(state);\n    }\n    if (deep) {\n      for (key in this.children) {\n        this.children[key].enable(state, true);\n      }\n    }\n    return this;\n  };\n\n  Composite.prototype.sub = function(scope, topic, method) {\n    var items, refs, subs;\n    if (scope == null) {\n      scope = this;\n    }\n    subs = this.subs || (this.subs = {});\n    items = subs[topic] || (subs[topic] = []);\n    items.push(scope, method);\n    if (scope !== this) {\n      refs = scope.refSubs || (scope.refSubs = []);\n      if (!~refs.indexOf(this)) {\n        refs.push(this);\n      }\n    }\n    return this;\n  };\n\n  Composite.prototype.pub = function(topic, a0, a1, a2, a3) {\n    var i, items, scope;\n    if (this.subs && (items = this.subs[topic]) && (i = items.length)) {\n      while (scope = items[i -= 2]) {\n        scope[items[i + 1] || topic](a0, a1, a2, a3);\n      }\n    }\n    return this;\n  };\n\n  Composite.prototype.pubUp = function(topic, a0, a1, a2, a3) {\n    var comp;\n    comp = this;\n    while (comp) {\n      if (comp.pub(topic, a0, a1, a2, a3) === false) {\n        break;\n      }\n      comp = comp.parent;\n    }\n    return this;\n  };\n\n  Composite.prototype.pubAll = function(topic, a0, a1, a2, a3) {\n    return Pool.call(topic, a0, a1, a2, a3);\n  };\n\n  Composite.prototype.unsub = function(unscope, untopic) {\n    var i, items, length, scope, subs, topic;\n    if (subs = this.subs) {\n      for (topic in subs) {\n        items = subs[topic];\n        if (!((i = items.length) && (!untopic || untopic === topic))) {\n          continue;\n        }\n        length = i / 2;\n        while ((i -= 2) >= 0) {\n          if (scope = items[i]) {\n            if (unscope && scope !== unscope) {\n              continue;\n            } else {\n              items[i] = null;\n            }\n            length--;\n          }\n        }\n        if (!length) {\n          items.length = 0;\n        }\n      }\n    }\n    return this;\n  };\n\n  return Composite;\n\n})();\n\nnew Pool(Composite);\n\nComposite.Prefab = (function() {\n\n  function Prefab(presets) {\n    var key;\n    this.presets = presets;\n    for (key in presets) {\n      presets[key] = this.presets[key] || {};\n    }\n  }\n\n  Prefab.prototype.alloc = function(parent, presets) {\n    var defaults, key, subKey, subPresets, value;\n    if ((defaults = this.presets) && presets) {\n      for (key in defaults) {\n        value = defaults[key];\n        if (!(key in presets)) {\n          presets[key] = value;\n        } else {\n          subPresets = presets[key];\n          if (key === 'children') {\n            subPresets.unshift.apply(subPresets, value);\n          } else if (typeof value === 'object') {\n            for (subKey in value) {\n              if (!(subKey in subPresets)) {\n                subPresets[subKey] = value[subKey];\n              }\n            }\n          }\n          delete presets[key];\n          presets[key] = subPresets;\n        }\n      }\n    }\n    return Composite.alloc(parent, presets || defaults);\n  };\n\n  return Prefab;\n\n})();\n\nmodule.exports = Composite;\n\n//@ sourceURL=/lib/core/composite.js"
));

require.define("/lib/core/engine.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.4.0\nvar Composite, Engine, Pool, Vec2, requestAnimationFrame,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComposite = require('./composite');\n\nPool = require('./pool');\n\nVec2 = require('./math').Vec2;\n\nEngine = (function(_super) {\n\n  __extends(Engine, _super);\n\n  function Engine() {\n    return Engine.__super__.constructor.apply(this, arguments);\n  }\n\n  Engine.prototype.type = 'engine';\n\n  Engine.prototype.init = function(element) {\n    var Input,\n      _this = this;\n    this.element = element;\n    this.time = 0.0;\n    this.frame = 0;\n    this.tail = 0.0;\n    this.debug = {\n      step: false,\n      fps: false,\n      fpsLength: 0,\n      fpsSum: 0,\n      fpsNext: 0,\n      stats: true\n    };\n    this.fdt = 1 / 60;\n    this.dtCap = 0.5;\n    this.fdtCap = this.fdt * 5;\n    this.scale = 1;\n    this.fps = 0;\n    Input = require('./input');\n    Input.alloc(this);\n    return this.tickBound = function(now) {\n      return _this.tick(now);\n    };\n  };\n\n  Engine.prototype.play = function(scene) {\n    this.scene = scene;\n    this.input.root = this.scene;\n    if (this.debug.stats) {\n      this.startStats();\n    }\n    if (!this.running) {\n      return this.start();\n    }\n  };\n\n  Engine.prototype.start = function() {\n    this.running = true;\n    requestAnimationFrame(this.tickBound);\n    return this;\n  };\n\n  Engine.prototype.tick = function(now) {\n    var debug, dt;\n    now = (now && now > 1e12 ? now : Date.now()) / 1000;\n    debug = this.debug;\n    if (this.lastTime) {\n      if ((dt = now - this.lastTime) > 0.5) {\n        dt = this.fdt;\n      } else if (dt > 0.01) {\n        if (debug.fpsSum > 0.333) {\n          this.fps = debug.fpsLength / debug.fpsSum;\n          debug.fpsLength = 1;\n          debug.fpsSum = dt;\n        } else {\n          debug.fpsSum += dt;\n          debug.fpsLength++;\n        }\n      }\n      this.dt = (dt *= this.scale);\n      this.time += dt;\n      this.frame++;\n      if (debug._stats) {\n        debug._stats.begin();\n      }\n      this.update(dt);\n      if (debug._stats) {\n        debug._stats.end();\n      }\n      if (debug.step) {\n        debugger;\n      }\n    } else {\n      this.time = now;\n    }\n    this.lastTime = now;\n    if (this.running) {\n      requestAnimationFrame(this.tickBound);\n    }\n    return this;\n  };\n\n  Engine.prototype.update = function(dt) {\n    var ctx, fdt, fps, tail;\n    ctx = this.renderer.save();\n    tail = Math.min(this.tail + dt, this.fdtCap * this.scale);\n    fdt = this.fdt;\n    while (tail > fdt) {\n      tail -= fdt;\n      Pool.invoke('fixedUpdate', fdt);\n      Pool.invoke('simulate', fdt);\n    }\n    this.tail = tail;\n    Pool.invoke('update', dt);\n    Pool.invoke('lateUpdate', dt);\n    Pool.invoke('render', ctx, dt);\n    if (this.debug.fps) {\n      fps = Math.round(this.fps);\n      ctx.fillStyle = 'black';\n      ctx.strokeStyle = 'white';\n      ctx.font = 'bold 11px sans-serif';\n      ctx.lineWidth = 2;\n      ctx.strokeText(fps | 0, 1, 11);\n      ctx.fillText(fps | 0, 1, 11);\n    }\n    if (this.debug.warn) {\n      ctx.fillStyle = 'red';\n      ctx.strokeStyle = 'white';\n      ctx.font = 'bold 11px sans-serif';\n      ctx.lineWidth = 2;\n      ctx.strokeText(fps | 0, 1, 11);\n      ctx.fillText(fps | 0, 1, 11);\n    }\n    return this.renderer.restore();\n  };\n\n  Engine.prototype.startStats = function() {\n    var el, stats;\n    if (this.debug._stats || !window.Stats) {\n      return;\n    }\n    this.debug._stats = stats = new Stats();\n    el = stats.domElement;\n    el.style.position = 'absolute';\n    el.style.left = 0;\n    el.style.top = 0;\n    document.body.appendChild(el);\n    return this;\n  };\n\n  return Engine;\n\n})(Composite);\n\nrequestAnimationFrame = (function() {\n  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {\n    return setTimeout(callback, 20);\n  };\n})();\n\nmodule.exports = new Engine();\n\n//@ sourceURL=/lib/core/engine.js"
));

require.define("/lib/core/force.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.4.0\nvar Component, Force, Pool, Vec2,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComponent = require('./component');\n\nPool = require('./pool');\n\nVec2 = require('./math').Vec2;\n\nForce = (function(_super) {\n\n  __extends(Force, _super);\n\n  Force.prototype.type = 'force';\n\n  Force.prototype.presets = {\n    force: Vec2(),\n    torque: 0\n  };\n\n  function Force() {\n    this.force = Vec2();\n  }\n\n  Force.prototype.reset = function(presets) {\n    Vec2.copy(this.force, presets.force);\n    this.torque = presets.torque;\n    this.age = 0;\n    return this;\n  };\n\n  Force.prototype.simulate = function(dt) {\n    Vec2.add(this.kinetic.acc, this.force);\n    return this;\n  };\n\n  return Force;\n\n})(Component);\n\nnew Pool(Force);\n\nmodule.exports = Force;\n\n//@ sourceURL=/lib/core/force.js"
));

require.define("/lib/core/input.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.4.0\nvar Component, Engine, Input, Pool, Vec2, pool,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComponent = require('./component');\n\nPool = require('./pool');\n\nVec2 = require('./math').Vec2;\n\nEngine = require('./engine');\n\nInput = (function(_super) {\n\n  __extends(Input, _super);\n\n  Input.prototype.type = 'input';\n\n  Input.prototype.support = {\n    touch: 'ontouchstart' in window,\n    orientation: 'ondeviceorientation' in window\n  };\n\n  function Input() {\n    var code, key, type, _ref;\n    this.queue = [];\n    this.locks = {};\n    this.pos = Vec2();\n    this.prevPos = Vec2();\n    this.touchState = null;\n    this.axis = Vec2();\n    this.mouseAxis = Vec2();\n    this.orientation = Vec2();\n    this.prevOrientation = Vec2();\n    this.baseOrientation = Vec2();\n    this.map = {\n      32: 'space',\n      192: 'debug',\n      38: 'up',\n      39: 'right',\n      40: 'bottom',\n      37: 'left'\n    };\n    this.axisMap = {\n      left: Vec2(0, -1),\n      right: Vec2(0, 1),\n      up: Vec2(1, -1),\n      bottom: Vec2(1, 1)\n    };\n    this.keyNames = [];\n    this.keys = {};\n    _ref = this.map;\n    for (code in _ref) {\n      key = _ref[code];\n      if (!~this.keyNames.indexOf(key)) {\n        this.keyNames.push(key);\n        this.keys[key] = null;\n      }\n    }\n    this.throttled = {\n      mousemove: true,\n      deviceorientation: true\n    };\n    this.lastEvent = null;\n    this.events = this.support.touch ? {\n      touchstart: 'startTouch',\n      touchmove: 'moveTouch',\n      touchend: 'endTouch',\n      touchcancel: 'endTouch'\n    } : {\n      mousedown: 'startTouch',\n      mousemove: 'moveTouch',\n      mouseup: 'endTouch',\n      keydown: 'keyStart',\n      keyup: 'keyEnd'\n    };\n    for (type in this.events) {\n      document.addEventListener(type, this, false);\n    }\n  }\n\n  Input.prototype.handleEvent = function(event) {\n    var type;\n    if (event.metaKey) {\n      return;\n    }\n    type = event.type;\n    if (this.throttled[type] && this.lastEvent === type) {\n      this.queue[this.queue.length - 1] = event;\n    } else {\n      this.lastEvent = type;\n      this.queue.push(event);\n    }\n    return false;\n  };\n\n  Input.prototype.keyStart = function(event) {\n    var axis, key;\n    if ((key = this.map[event.keyCode]) && !this.keys[key]) {\n      if (!this.lock('key-' + key)) {\n        return false;\n      }\n      this.keys[key] = 'began';\n      if ((axis = this.axisMap[key])) {\n        this.axis[axis[0]] += axis[1];\n      }\n      Engine.pub('onKeyBegan', key);\n    }\n    return this;\n  };\n\n  Input.prototype.keyEnd = function(event) {\n    var axis, key;\n    if (key = this.map[event.keyCode]) {\n      if (!this.lock('key-' + key)) {\n        return false;\n      }\n      this.keys[key] = 'ended';\n      if ((axis = this.axisMap[key])) {\n        this.axis[axis[0]] -= axis[1];\n      }\n      Engine.pub('onKeyEnded', key);\n    }\n    return this;\n  };\n\n  Input.prototype.startTouch = function(event) {\n    if (!this.lock('touch')) {\n      return false;\n    }\n    this.resolve(event);\n    if (!this.touchState && !event.metaKey) {\n      this.touchState = 'began';\n      Engine.pub('onTouchBegan');\n    }\n    return this;\n  };\n\n  Input.prototype.moveTouch = function(event) {\n    var state;\n    state = this.touchState;\n    if ((state === 'began' || state === 'ended') && !this.lock('touch')) {\n      return false;\n    }\n    this.resolve(event);\n    if (state && state !== 'ended' && state !== 'moved') {\n      this.touchState = 'moved';\n    }\n    return this;\n  };\n\n  Input.prototype.endTouch = function(event) {\n    if (!this.lock('touch')) {\n      return false;\n    }\n    this.resolve(event);\n    if (this.touchState && (!this.support.touch || !event.targetTouches.length)) {\n      Engine.pub('onTouchEnded');\n      this.touchState = 'ended';\n    }\n    return this;\n  };\n\n  Input.prototype.calibrateOrientation = function() {\n    this.baseOrientationTime = this.orientationTime;\n    Vec2.copy(this.baseOrientation, this.orientation);\n    Vec2.set(this.orientation);\n    return this;\n  };\n\n  Input.prototype.deviceOrientation = function(event) {\n    Vec2.copy(this.prevOrientation, this.orientation);\n    Vec2.sub(Vec2.set(this.orientation, event.gamma | 0, event.beta | 0), this.baseOrientation);\n    this.orientationTime = event.timeStamp / 1000;\n    if (!this.baseOrientationTime) {\n      this.calibrateOrientation();\n    }\n    return this;\n  };\n\n  Input.prototype.resolve = function(event) {\n    var coords, renderer;\n    coords = this.support.touch ? event.targetTouches[0] : event;\n    if (coords) {\n      this.prevTime = this.time;\n      this.time = event.timeStamp / 1000;\n      Vec2.copy(this.prevPos, this.pos);\n      renderer = Engine.renderer;\n      Vec2.set(this.pos, (coords.pageX - renderer.margin[0]) / renderer.scale | 0, (coords.pageY - renderer.margin[1]) / renderer.scale | 0);\n    }\n    return this;\n  };\n\n  Input.prototype.lock = function(key) {\n    if (this.locks[key] === this.frame) {\n      console.log('LOCKED: ' + key);\n      return false;\n    }\n    this.locks[key] = this.frame;\n    return true;\n  };\n\n  Input.prototype.lateUpdate = function(dt, scene) {\n    var event, key, keys, queue, type, _i, _len, _ref;\n    switch (this.touchState) {\n      case 'began':\n        this.touchState = 'stationary';\n        break;\n      case 'ended':\n        this.touchState = null;\n        break;\n    }\n    keys = this.keys;\n    _ref = this.keyNames;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      key = _ref[_i];\n      switch (keys[key]) {\n        case 'began':\n          keys[key] = 'pressed';\n          break;\n        case 'ended':\n          keys[key] = null;\n          break;\n      }\n    }\n    this.frame = Engine.frame;\n    queue = this.queue;\n    while ((event = queue[0])) {\n      type = event.type;\n      if (!this[this.events[type]](event)) {\n        break;\n      }\n      queue.shift();\n    }\n    if (!queue.length) {\n      this.lastEvent = null;\n    }\n    return this;\n  };\n\n  return Input;\n\n})(Component);\n\npool = new Pool(Input);\n\nmodule.exports = Input;\n\n//@ sourceURL=/lib/core/input.js"
));

require.define("/lib/core/kinetic.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.4.0\nvar Component, Force, Kinetic, Pool, Vec2, addForce,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComponent = require('./component');\n\nPool = require('./pool');\n\nForce = require('./force');\n\nVec2 = require('./math').Vec2;\n\naddForce = Vec2();\n\nKinetic = (function(_super) {\n\n  __extends(Kinetic, _super);\n\n  Kinetic.prototype.type = 'kinetic';\n\n  Kinetic.gravity = null;\n\n  Kinetic.friction = 15;\n\n  Kinetic.drag = 0.999;\n\n  Kinetic.prototype.presets = {\n    mass: 0,\n    drag: Kinetic.drag,\n    friction: Kinetic.friction,\n    fixed: false,\n    maxVel: 75,\n    maxAcc: 2000,\n    acc: Vec2(),\n    vel: Vec2()\n  };\n\n  function Kinetic() {\n    this.vel = Vec2();\n    this.acc = Vec2();\n    this.sleepVelSq = 0.2;\n  }\n\n  Kinetic.prototype.reset = function(presets) {\n    this.mass = presets.mass, this.drag = presets.drag, this.friction = presets.friction, this.fixed = presets.fixed, this.maxVel = presets.maxVel, this.maxAcc = presets.maxAcc;\n    Vec2.copy(this.vel, presets.vel);\n    Vec2.copy(this.acc, presets.acc);\n    this.pos = this.transform.pos;\n    this.sleeping = false;\n    return this;\n  };\n\n  Kinetic.prototype.applyForce = function(acc, ignoreMass, constant) {\n    if (!ignoreMass && this.mass) {\n      Vec2.scal(acc, 1 / this.mass, addForce);\n    } else {\n      Vec2.copy(addForce, acc);\n    }\n    if (constant && !this.force) {\n      Force.alloc(this);\n    }\n    Vec2.add((constant ? this.force.force : this.acc), addForce);\n    return this;\n  };\n\n  return Kinetic;\n\n})(Component);\n\nKinetic.simulate = function(dt) {\n  var acc, cache, copyVel, epsilon, kinetic, vel, _i, _len, _ref;\n  copyVel = Vec2.cache[0];\n  cache = Vec2.cache[1];\n  epsilon = Math.epsilon;\n  _ref = this.roster;\n  for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n    kinetic = _ref[_i];\n    if (!(kinetic.enabled && !kinetic.fixed)) {\n      continue;\n    }\n    vel = kinetic.vel;\n    acc = kinetic.acc;\n    if (kinetic.root.gravity && kinetic.mass > epsilon) {\n      Vec2.add(acc, Vec2.scal(kinetic.root.gravity, 1 / kinetic.mass, cache));\n    }\n    if (kinetic.friction) {\n      Vec2.add(acc, Vec2.scal(Vec2.norm(vel, cache), -kinetic.friction));\n    }\n    if (kinetic.maxAcc) {\n      Vec2.limit(acc, kinetic.maxAcc);\n    }\n    Vec2.copy(copyVel, vel);\n    Vec2.add(vel, Vec2.scal(acc, dt, cache));\n    if (kinetic.maxVel) {\n      Vec2.limit(vel, kinetic.maxVel);\n    }\n    Vec2.scal(Vec2.add(copyVel, vel), dt / 2);\n    Vec2.add(kinetic.pos, copyVel);\n    Vec2.add(vel, Vec2.scal(acc, dt));\n    if (kinetic.drag < 1) {\n      Vec2.scal(vel, kinetic.drag);\n    }\n    if (kinetic.sleepVelSq) {\n      if (Vec2.lenSq(vel) <= kinetic.sleepVelSq) {\n        if (!kinetic.sleeping) {\n          Vec2.set(vel);\n          kinetic.sleeping = true;\n          kinetic.parent.pubUp('onKineticSleep', kinetic);\n        }\n      } else {\n        if (kinetic.sleeping) {\n          kinetic.sleeping = false;\n          kinetic.parent.pubUp('onKineticWake', kinetic);\n        }\n      }\n    }\n    Vec2.set(acc);\n  }\n  return this;\n};\n\nnew Pool(Kinetic);\n\nmodule.exports = Kinetic;\n\n//@ sourceURL=/lib/core/kinetic.js"
));

require.define("/lib/core/math.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.4.0\nvar Mat, Vec2, abs, epsilon, fn, i, pow, powIn, radCache, random, sqrt, toInOut, toOut, transition, typedArray, _i, _len, _ref;\n\nMat = Math;\n\nMat.epsilon = 0.001;\n\nsqrt = Mat.sqrt, pow = Mat.pow, abs = Mat.abs, random = Mat.random, epsilon = Mat.epsilon;\n\nMat.TypedArray = typedArray = Float64Array || Float32Array || function(arr) {\n  return arr;\n};\n\nVec2 = function(fromOrX, y) {\n  if (y != null) {\n    return new typedArray([fromOrX, y]);\n  }\n  if (fromOrX != null) {\n    return new typedArray(fromOrX);\n  }\n  return new typedArray(Vec2.zero);\n};\n\nVec2.zero = Vec2.center = Vec2(0, 0);\n\nVec2.cache = [Vec2(), Vec2(), Vec2(), Vec2(), Vec2()];\n\nVec2.topLeft = Vec2(1, -1);\n\nVec2.topCenter = Vec2(0, -1);\n\nVec2.topRight = Vec2(-1, -1);\n\nVec2.centerLeft = Vec2(1, 0);\n\nVec2.centerRight = Vec2(-1, 0);\n\nVec2.bottomLeft = Vec2(1, 1);\n\nVec2.bottomCenter = Vec2(0, 1);\n\nVec2.bottomRight = Vec2(-1, 1);\n\nradCache = [Vec2(), Vec2()];\n\nVec2.set = function(result, x, y) {\n  result[0] = x || 0;\n  result[1] = y || 0;\n  return result;\n};\n\nVec2.copy = function(result, b) {\n  result[0] = b[0];\n  result[1] = b[1];\n  return result;\n};\n\nVec2.valid = function(a) {\n  return !(isNaN(a[0]) || isNaN(a[0]));\n};\n\nVec2.eq = function(a, b) {\n  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;\n};\n\nVec2.add = function(a, b, result) {\n  result || (result = a);\n  result[0] = a[0] + b[0];\n  result[1] = a[1] + b[1];\n  return result;\n};\n\nVec2.sub = function(a, b, result) {\n  result || (result = a);\n  result[0] = a[0] - b[0];\n  result[1] = a[1] - b[1];\n  return result;\n};\n\nVec2.mul = function(a, b, result) {\n  result || (result = a);\n  result[0] = a[0] * b[0];\n  result[1] = a[1] * b[1];\n  return result;\n};\n\nVec2.scal = function(a, scalar, result) {\n  result || (result = a);\n  result[0] = a[0] * scalar;\n  result[1] = a[1] * scalar;\n  return result;\n};\n\nVec2.norm = function(a, result, scalar) {\n  var len, x, y;\n  if (scalar == null) {\n    scalar = 1;\n  }\n  result || (result = a);\n  x = a[0];\n  y = a[1];\n  len = scalar / (sqrt(x * x + y * y) || 1);\n  result[0] = x * len;\n  result[1] = y * len;\n  return result;\n};\n\nVec2.lenSq = function(a) {\n  return a[0] * a[0] + a[1] * a[1];\n};\n\nVec2.len = function(a) {\n  return sqrt(a[0] * a[0] + a[1] * a[1]);\n};\n\nVec2.dot = function(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n};\n\nVec2.cross = function(a, b) {\n  return a[0] * b[1] - a[1] * b[0];\n};\n\nVec2.lerp = function(a, b, scalar, result) {\n  result || (result = a);\n  result[0] = a[0] + scalar * (b[0] - a[0]);\n  result[1] = a[1] + scalar * (b[1] - a[1]);\n  return result;\n};\n\nVec2.perp = function(a, result) {\n  var x;\n  result || (result = a);\n  x = a[0];\n  result[0] = a[1];\n  result[1] = -x;\n  return result;\n};\n\nVec2.dist = function(a, b) {\n  var x, y;\n  x = b[0] - a[0];\n  y = b[1] - a[1];\n  return sqrt(x * x + y * y);\n};\n\nVec2.distSq = function(a, b) {\n  var x, y;\n  x = b[0] - a[0];\n  y = b[1] - a[1];\n  return x * x + y * y;\n};\n\nVec2.limit = function(a, max, result) {\n  var ratio, x, y;\n  result || (result = a);\n  x = a[0];\n  y = a[1];\n  if ((ratio = max / sqrt(x * x + y * y)) < 1) {\n    result[0] = x * ratio;\n    result[1] = y * ratio;\n  } else if (result !== a) {\n    result[0] = x;\n    result[1] = y;\n  }\n  return result;\n};\n\nVec2.rad = function(a, b) {\n  if (!b) {\n    return Mat.atan2(a[1], a[0]);\n  }\n  return Mat.acos(Vec2.dot(Vec2.norm(a, radCache[0]), Vec2.norm(b, radCache[1])));\n};\n\nVec2.rot = function(a, theta, result) {\n  var cosA, sinA, x, y;\n  result || (result = a);\n  sinA = Mat.sin(theta);\n  cosA = Mat.cos(theta);\n  x = a[0];\n  y = a[1];\n  result[0] = x * cosA - y * sinA;\n  result[1] = x * sinA + y * cosA;\n  return result;\n};\n\nVec2.rotAxis = function(a, b, theta, result) {\n  return Vec2.add(Vec2.rot(Vec2.sub(a, b, result || a), theta), b);\n};\n\nVec2.lookAt = function(a, b, result) {\n  var len;\n  len = Vec2.len(a);\n  return Vec2.norm(Vec2.rot(a, Mat.atan2(b[0] - a[0], b[1] - a[1]) - Mat.atan2(a[1], a[0]), result || a), null, len);\n};\n\nrandom = Mat.random, pow = Mat.pow;\n\nMat.TAU = Mat.PI * 2;\n\nMat.UID = 1;\n\nMat.uid = function() {\n  return Mat.UID++;\n};\n\nMat.clamp = function(a, low, high) {\n  if (a < low) {\n    return low;\n  }\n  if (a > high) {\n    return high;\n  } else {\n    return a;\n  }\n};\n\nMat.rand = function(low, high, ease) {\n  return low + (ease || Mat.linear)(random()) * (high - low + 1);\n};\n\nMat.randArray = function(array) {\n  return array[Math.floor(random() * array.length)];\n};\n\nMat.chance = function(chance) {\n  return random() <= chance;\n};\n\npowIn = function(strength) {\n  if (strength == null) {\n    strength = 2;\n  }\n  return function(t) {\n    return pow(t, strength);\n  };\n};\n\ntoOut = function(fn) {\n  return function(t) {\n    return 1 - fn(1 - t);\n  };\n};\n\ntoInOut = function(fn) {\n  return function(t) {\n    return (t < 0.5 ? fn(t * 2) : 2 - fn(2 * (1 - t))) / 2;\n  };\n};\n\nMat.linear = function(t) {\n  return t;\n};\n\n_ref = ['quad', 'cubic', 'quart', 'quint'];\nfor (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n  transition = _ref[i];\n  Mat[transition + 'In'] = fn = powIn(i + 2);\n  Mat[transition + 'Out'] = toOut(fn);\n  Mat[transition + 'InOut'] = toInOut(fn);\n}\n\nmodule.exports.Vec2 = Vec2;\n\n//@ sourceURL=/lib/core/math.js"
));

require.define("/lib/core/pool.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.4.0\nvar Pool, fn, _i, _len, _ref;\n\nrequire('./math');\n\nPool = (function() {\n\n  Pool.typedHooks = ['fixedUpdate', 'simulate', 'update', 'lateUpdate', 'render'];\n\n  Pool.hookRegx = /^on[A-Z]/;\n\n  Pool.hooks = {};\n\n  Pool.types = {};\n\n  Pool.defaults = {};\n\n  Pool.order = {\n    render: false\n  };\n\n  Pool.prototype.toString = function() {\n    return \"Pool {@type} [\" + this.roster.length + \"]\";\n  };\n\n  function Pool(cls) {\n    var fn, keys, proto, types, _i, _j, _len, _len1,\n      _this = this;\n    this.cls = cls;\n    proto = cls.prototype;\n    this.type = proto.type;\n    this.isComponent = this.type && this.type !== 'composite';\n    this.light = (!this.isComponent) || proto.light || false;\n    if (this.type) {\n      Pool.types[this.type] = this;\n    }\n    proto.pool = this;\n    cls.pool = this;\n    this.roster = [];\n    this.subs = [];\n    this.hooks = [];\n    this.enabled = false;\n    this.allocd = 0;\n    this.layer = proto.layer || cls.layer || 0;\n    if (this.isComponent && !this.light) {\n      types = Pool.typedHooks;\n      keys = Object.keys(proto).concat(Object.keys(cls));\n      for (_i = 0, _len = keys.length; _i < _len; _i++) {\n        fn = keys[_i];\n        if (Pool.hookRegx.test(fn)) {\n          if (!~types.indexOf(fn)) {\n            types.push(fn);\n            Pool.hooks[fn] = [];\n          }\n          this.subs.push(fn);\n        }\n      }\n      for (_j = 0, _len1 = types.length; _j < _len1; _j++) {\n        fn = types[_j];\n        if (fn in cls) {\n          this[fn] = cls[fn];\n          Pool.hooks[fn].push(this);\n        } else if (fn in proto) {\n          this.hooks.push(fn);\n        }\n      }\n    }\n    cls.alloc = function(parent, presets) {\n      return _this.alloc(parent, presets);\n    };\n  }\n\n  Pool.prototype.preinstantiate = function(i) {\n    while (i--) {\n      this.instantiate();\n    }\n    return this;\n  };\n\n  Pool.prototype.instantiate = function() {\n    var cls, hook, _i, _len, _ref;\n    cls = new this.cls();\n    this.roster.push(cls);\n    _ref = this.hooks;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      hook = _ref[_i];\n      Pool.hooks[hook].push(cls);\n    }\n    return cls;\n  };\n\n  Pool.prototype.alloc = function(parent, presets) {\n    var defaults, entity, hook, i, roster, topic, uid, _i, _j, _len, _len1, _ref, _ref1;\n    roster = this.roster;\n    i = roster.length;\n    while (i--) {\n      if (!roster[i].allocd) {\n        entity = roster[i];\n        break;\n      }\n    }\n    if (!entity) {\n      entity = this.instantiate();\n    }\n    this.allocd++;\n    this.enabled = true;\n    _ref = this.hooks;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      hook = _ref[_i];\n      if (hook in Pool.order) {\n        Pool.order[hook] = true;\n      }\n    }\n    entity.uid = uid = Math.uid();\n    entity.enabled = true;\n    entity.allocd = true;\n    entity.parent = parent || null;\n    entity.root = parent && parent.root || parent || entity;\n    entity.layer = (parent && parent.layer || 0) + this.layer + 2 - 1 / uid;\n    if (entity.root.descendants) {\n      entity.root.descendants[uid] = entity;\n    } else {\n      entity.descendants = {};\n    }\n    if (this.isComponent) {\n      if (defaults = entity.presets) {\n        if (presets && !presets._merged) {\n          presets.__proto__ = defaults;\n          presets._merged = true;\n        }\n      }\n      _ref1 = this.subs;\n      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n        topic = _ref1[_j];\n        parent.sub(entity, topic);\n      }\n    }\n    entity.alloc(presets || defaults || null);\n    return entity;\n  };\n\n  Pool.prototype.free = function(entity) {\n    if (entity.root === entity) {\n      entity.descendants = null;\n    } else if (entity.root.descendants) {\n      delete entity.root.descendants[entity.uid];\n    }\n    entity.enabled = false;\n    entity.allocd = false;\n    entity.uid = null;\n    entity.root = null;\n    entity.parent = null;\n    this.enabled = this.allocd-- > 1;\n    return this;\n  };\n\n  return Pool;\n\n})();\n\n_ref = Pool.typedHooks;\nfor (_i = 0, _len = _ref.length; _i < _len; _i++) {\n  fn = _ref[_i];\n  Pool.hooks[fn] = [];\n}\n\nPool.dump = function(free) {\n  var pool, type, _ref1;\n  _ref1 = Pool.types;\n  for (type in _ref1) {\n    pool = _ref1[type];\n    console.log(\"%s: %d/%d allocd\", type, pool.allocd, pool.roster.length);\n  }\n  if (free) {\n    Pool.free();\n  }\n  return null;\n};\n\nif ('console' in window) {\n  console.pool = Pool.dump;\n}\n\nPool.free = function() {\n  var freed, i, pool, roster, type, _ref1;\n  _ref1 = Pool.types;\n  for (type in _ref1) {\n    pool = _ref1[type];\n    roster = pool.roster;\n    i = roster.length;\n    freed = 0;\n    while (i--) {\n      if (!(!roster[i].allocd)) {\n        continue;\n      }\n      roster.splice(i, 1);\n      freed++;\n    }\n    console.log(\"%s: %d/%d freed\", type, freed, pool.roster.length);\n  }\n  return this;\n};\n\nPool.invoke = function(fn, a0, a1, a2, a3) {\n  var i, stack;\n  if ((stack = this.hooks[fn]) && (i = stack.length)) {\n    if (fn in Pool.order && Pool.order[fn]) {\n      stack.sort(Pool.orderFn);\n      Pool.order[fn] = false;\n    }\n    while (i--) {\n      if (stack[i].enabled) {\n        stack[i][fn](a0, a1, a2, a3);\n      }\n    }\n  }\n  return this;\n};\n\nPool.orderFn = function(a, b) {\n  return b.layer - a.layer;\n};\n\nmodule.exports = Pool;\n\n//@ sourceURL=/lib/core/pool.js"
));

require.define("/lib/core/sprite.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.4.0\nvar Component, Pool, SpriteAsset, SpriteSheet, SpriteTween, Vec2,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nVec2 = require('./math').Vec2;\n\nComponent = require('./component');\n\nPool = require('./pool');\n\nSpriteAsset = (function() {\n\n  function SpriteAsset(srcOrRepaint, size, baseScale) {\n    var img,\n      _this = this;\n    this.baseScale = baseScale != null ? baseScale : 1;\n    this.size = Vec2(size);\n    this.bufferSize = Vec2(size);\n    this.defaultAlign = Vec2.center;\n    this.defaultOffset = Vec2();\n    this.defaultScale = Vec2(1, 1);\n    this.buffer = document.createElement('canvas');\n    this.bufferCtx = this.buffer.getContext('2d');\n    this.scale = 1;\n    switch (typeof srcOrRepaint) {\n      case 'string':\n        this.img = img = new Image();\n        img.onload = function() {\n          if (!img.onload) {\n            return;\n          }\n          img.onload = null;\n          Vec2.set(_this.size, img.width, img.height);\n          return _this.refresh();\n        };\n        img.src = srcOrRepaint;\n        if (img.onload && img.width && img.height) {\n          img.onload();\n        }\n        break;\n      case 'function':\n        this.repaint = srcOrRepaint;\n        this.refresh();\n        break;\n    }\n  }\n\n  SpriteAsset.prototype.draw = function(ctx, align, size, fromPos, scale) {\n    if (align == null) {\n      align = this.defaultAlign;\n    }\n    if (size == null) {\n      size = this.bufferSize;\n    }\n    if (fromPos == null) {\n      fromPos = this.defaultOffset;\n    }\n    if (scale == null) {\n      scale = this.defaultScale;\n    }\n    if (this.ready) {\n      ctx.drawImage(this.buffer, fromPos[0] | 0, fromPos[1] | 0, size[0], size[1], -size[0] / 2 * (align[0] + 1) | 0, -size[1] / 2 * (align[1] + 1) | 0, size[0] * scale[0], size[1] * scale[1]);\n    }\n    return this;\n  };\n\n  SpriteAsset.prototype.repaint = function() {\n    var size;\n    size = this.size;\n    this.buffer.width = size[0];\n    this.buffer.height = size[1];\n    this.bufferCtx.drawImage(this.img, 0, 0, size[0], size[1]);\n    this.sample();\n    return this;\n  };\n\n  SpriteAsset.prototype.sample = function() {\n    var bufferCtx, data, i, scale, size, x, y, _i, _j, _ref, _ref1;\n    scale = this.scale, size = this.size, bufferCtx = this.bufferCtx;\n    data = bufferCtx.getImageData(0, 0, size[0], size[1]).data;\n    this.buffer.width = this.bufferSize[0];\n    this.buffer.height = this.bufferSize[1];\n    for (x = _i = 0, _ref = size[0]; _i <= _ref; x = _i += 1) {\n      for (y = _j = 0, _ref1 = size[1]; _j <= _ref1; y = _j += 1) {\n        i = (y * size[0] + x) * 4;\n        bufferCtx.fillStyle = \"rgba(\" + data[i] + \", \" + data[i + 1] + \", \" + data[i + 2] + \", \" + (data[i + 3] / 255) + \")\";\n        bufferCtx.fillRect(x * scale, y * scale, scale, scale);\n      }\n    }\n    return this;\n  };\n\n  SpriteAsset.prototype.refresh = function(scale) {\n    scale = (scale || 1) * this.baseScale;\n    if (!this.ready || this.scale !== scale) {\n      this.scale = scale;\n      this.buffer.width = this.bufferSize[0] = this.size[0] * scale | 0;\n      this.buffer.height = this.bufferSize[1] = this.size[1] * scale | 0;\n      Vec2.scal(this.bufferSize, -0.5, this.defaultOffset);\n      this.repaint(this.bufferCtx, scale);\n      this.ready = true;\n    }\n    return this;\n  };\n\n  return SpriteAsset;\n\n})();\n\nSpriteSheet = (function() {\n\n  function SpriteSheet(presets) {\n    var frame, id, sequences, sprites, _base, _base1, _base2, _i, _len, _ref, _ref1, _ref2, _ref3;\n    sprites = presets.sprites || [];\n    this.sprites = Array.isArray(sprites) ? sprites : [sprites];\n    this.frames = [];\n    if (Array.isArray(presets.frames)) {\n      _ref = presets.frames;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        frame = _ref[_i];\n        this.frames.push(frame);\n      }\n    }\n    this.defaults = {};\n    if ((_ref1 = (_base = this.defaults).speed) == null) {\n      _base.speed = presets.speed || 0.2;\n    }\n    if ((_ref2 = (_base1 = this.defaults).size) == null) {\n      _base1.size = presets.size || Vec2(1, 1);\n    }\n    if ((_ref3 = (_base2 = this.defaults).align) == null) {\n      _base2.align = presets.align || Vec2.center;\n    }\n    this.sequences = {};\n    sequences = presets.sequences || {};\n    for (id in sequences) {\n      this.addSequence(id, sequences[id]);\n    }\n  }\n\n  SpriteSheet.prototype.addSequence = function(id, sequence) {\n    var frame, frames, _i, _ref, _ref1;\n    if (Array.isArray(sequence)) {\n      frames = [];\n      for (frame = _i = _ref = sequence[0], _ref1 = sequence[1]; _i <= _ref1; frame = _i += 1) {\n        frames.push(frame);\n      }\n      sequence = {\n        frames: frames,\n        next: sequence[2] || null,\n        speed: sequence[3] || this.defaults.speed,\n        name: id,\n        sprite: sequence[4] || 0\n      };\n    }\n    if (sequence.next === true) {\n      sequence.next = id;\n    }\n    if (!sequence.speed) {\n      sequence.speed = this.defaults.speed;\n    }\n    this.sequences[id] = sequence;\n    if (!this.defaultSequence) {\n      this.defaultSequence = id;\n    }\n    return this;\n  };\n\n  SpriteSheet.prototype.prepare = function() {\n    var align, cols, rows, size, sprite, sprites, x, y, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2;\n    sprites = this.sprites;\n    for (_i = 0, _len = sprites.length; _i < _len; _i++) {\n      sprite = sprites[_i];\n      if (!sprite.ready) {\n        return false;\n      }\n    }\n    if (!this.frames.length) {\n      _ref = this.defaults, size = _ref.size, align = _ref.align;\n      for (_j = 0, _len1 = sprites.length; _j < _len1; _j++) {\n        sprite = sprites[_j];\n        cols = sprite.size[0] / size[0] | 0;\n        rows = sprite.size[1] / size[1] | 0;\n        for (y = _k = 0, _ref1 = rows - 1; _k <= _ref1; y = _k += 1) {\n          for (x = _l = 0, _ref2 = cols - 1; _l <= _ref2; x = _l += 1) {\n            this.frames.push({\n              sprite: sprite,\n              pos: Vec2(x * size[0], y * size[1]),\n              size: size,\n              align: align || Vec2.center\n            });\n          }\n        }\n      }\n    }\n    this.ready = true;\n    return this;\n  };\n\n  SpriteSheet.prototype.draw = function(ctx, frame) {\n    if (!this.ready && !this.prepare()) {\n      return this;\n    }\n    frame = this.frames[frame || 0];\n    frame.sprite.draw(ctx, frame.align, frame.size, frame.pos);\n    return this;\n  };\n\n  return SpriteSheet;\n\n})();\n\nSpriteTween = (function(_super) {\n\n  __extends(SpriteTween, _super);\n\n  function SpriteTween() {\n    return SpriteTween.__super__.constructor.apply(this, arguments);\n  }\n\n  SpriteTween.prototype.type = 'spriteTween';\n\n  SpriteTween.prototype.presets = {\n    asset: null,\n    speed: null,\n    sequence: null,\n    offset: 0,\n    composite: null\n  };\n\n  SpriteTween.prototype.reset = function(presets) {\n    var _ref;\n    this.asset = presets.asset, this.composite = presets.composite;\n    this.isSheet = this.asset instanceof SpriteSheet;\n    if (this.isSheet) {\n      this.frame = 0;\n      this.sequence = presets.sequence, this.speed = presets.speed;\n      if ((_ref = this.speed) == null) {\n        this.speed = this.asset.defaults.speed;\n      }\n      this.dtime = presets.offset;\n      if (!this.sequence) {\n        this.sequence = this.asset.defaultSequence;\n      }\n    }\n    return this;\n  };\n\n  SpriteTween.prototype.lateUpdate = function(dt) {\n    var dtime, frame, frameCount, frames, sequence, speed;\n    if (this.isSheet && !this.paused) {\n      dtime = (this.dtime += dt);\n      if (this.sequence) {\n        sequence = this.asset.sequences[this.sequence];\n        speed = sequence.speed;\n        frames = sequence.frames;\n        frameCount = frames.length;\n        if (dtime >= frameCount * speed) {\n          this.parent.pub('onSequenceEnd');\n          if (sequence.next) {\n            if (sequence.next !== this.sequence) {\n              return this.goto(sequence.next);\n            }\n          } else {\n            this.pause();\n            return this;\n          }\n          dtime = dtime % (frameCount * speed);\n        }\n        this.frame = frames[dtime / speed | 0];\n      } else {\n        frames = this.asset.frames;\n        frameCount = frames.length;\n        speed = this.speed;\n        dtime = dtime % (frameCount * speed);\n        frame = dtime / speed | 0;\n        if (frame < this.frame) {\n          this.parent.pub('onSequenceEnd');\n        }\n        this.frame = dtime / speed | 0;\n      }\n    }\n    return this;\n  };\n\n  SpriteTween.prototype.render = function(ctx, dt) {\n    ctx.save();\n    this.parent.transform.transform(ctx);\n    if (this.composite) {\n      ctx.globalCompositeOperation = this.composite;\n    }\n    this.asset.draw(ctx, this.frame);\n    ctx.restore();\n    return this;\n  };\n\n  SpriteTween.prototype.pause = function() {\n    this.paused = true;\n    return this;\n  };\n\n  SpriteTween.prototype.play = function() {\n    this.paused = false;\n    return this;\n  };\n\n  SpriteTween.prototype.goto = function(id) {\n    if (isNaN(id)) {\n      if (this.sequence !== id) {\n        this.dtime = 0;\n        this.sequence = id;\n      }\n    } else {\n      this.sequence = null;\n      this.frameIndex = id;\n    }\n    return this;\n  };\n\n  return SpriteTween;\n\n})(Component);\n\nnew Pool(SpriteTween);\n\nmodule.exports.Asset = SpriteAsset;\n\nmodule.exports.Tween = SpriteTween;\n\nmodule.exports.Sheet = SpriteSheet;\n\n//@ sourceURL=/lib/core/sprite.js"
));

require.define("/lib/core/transform.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.4.0\nvar Component, Pool, Transform, Vec2,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComponent = require('./component');\n\nPool = require('./pool');\n\nVec2 = require('./math').Vec2;\n\nTransform = (function(_super) {\n\n  __extends(Transform, _super);\n\n  Transform.prototype.type = 'transform';\n\n  Transform.prototype.presets = {\n    pos: Vec2(),\n    angle: 0\n  };\n\n  function Transform() {\n    this.pos = Vec2();\n  }\n\n  Transform.prototype.reset = function(presets) {\n    Vec2.copy(this.pos, presets.pos);\n    this.worldAngle = this.angle = presets.angle;\n    return this;\n  };\n\n  Transform.prototype.toWorld = function() {\n    this.worldPos.copy(this.pos);\n    this.worldAngle = this.angle;\n    return this;\n  };\n\n  Transform.prototype.transform = function(ctx) {\n    ctx.translate(this.pos[0] | 0, this.pos[1] | 0);\n    if (this.angle) {\n      ctx.rotate(this.angle);\n    }\n    return this;\n  };\n\n  return Transform;\n\n})(Component);\n\nnew Pool(Transform);\n\nmodule.exports = Transform;\n\n//@ sourceURL=/lib/core/transform.js"
));

require.define("/examples/sprites/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.4.0\n'use strict';\n\nvar AgentPrefab, Border, Collider, Component, Composite, Engine, Explosion, GameController, Kinetic, Pool, Renderer, Sprite, Transform, Vec2, agentSheet, explisionSheet,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nVec2 = require('../../lib/core/math').Vec2;\n\nEngine = require('../../lib/core/engine');\n\nEngine.init(document.getElementById('game-1'));\n\nRenderer = require('../../lib/core/renderer');\n\nEngine.renderer = new Renderer(Engine.element.getElementsByClassName('game-canvas')[0], Vec2(480, 320));\n\nComposite = require('../../lib/core/composite');\n\nComponent = require('../../lib/core/component');\n\nPool = require('../../lib/core/pool');\n\nSprite = require('../../lib/core/sprite');\n\nTransform = require('../../lib/core/transform');\n\nBorder = require('../../lib/core/border');\n\nCollider = require('../../lib/core/collider');\n\nKinetic = require('../../lib/core/kinetic');\n\nGameController = (function(_super) {\n\n  __extends(GameController, _super);\n\n  function GameController() {\n    return GameController.__super__.constructor.apply(this, arguments);\n  }\n\n  GameController.prototype.type = 'gameController';\n\n  GameController.prototype.reset = function() {\n    AgentPrefab.alloc(this.root, {\n      transform: {\n        pos: Vec2(240, 200)\n      }\n    });\n    return this;\n  };\n\n  GameController.prototype.update = function() {\n    var input;\n    input = Engine.input;\n    if (input.keys.space) {\n      Explosion.Prefab.alloc(this.root, {\n        transform: {\n          pos: input.pos\n        },\n        spriteTween: {\n          offset: Math.rand(0, 1)\n        }\n      });\n      return this;\n    }\n  };\n\n  GameController.prototype.spawnExplosion = function() {\n    Explosion.Prefab.alloc(this.root, {\n      transform: {\n        pos: Vec2(Math.rand(25, 450), Math.rand(25, 295))\n      },\n      spriteTween: {\n        offset: Math.rand(0, 1)\n      }\n    });\n    return this;\n  };\n\n  return GameController;\n\n})(Component);\n\nnew Pool(GameController);\n\nexplisionSheet = new Sprite.Sheet({\n  sprites: new Sprite.Asset('../shared/mini-explosion.png'),\n  size: Vec2(20, 20),\n  speed: 0.05\n});\n\nExplosion = (function(_super) {\n\n  __extends(Explosion, _super);\n\n  function Explosion() {\n    return Explosion.__super__.constructor.apply(this, arguments);\n  }\n\n  Explosion.prototype.type = 'explosion';\n\n  Explosion.prototype.onSequenceEnd = function() {\n    return this.parent.free();\n  };\n\n  return Explosion;\n\n})(Component);\n\nnew Pool(Explosion);\n\nExplosion.Prefab = new Composite.Prefab({\n  transform: null,\n  spriteTween: {\n    asset: explisionSheet\n  },\n  bounds: {\n    shape: 'circle',\n    radius: 15\n  },\n  explosion: null\n});\n\nagentSheet = new Sprite.Sheet({\n  sprites: [new Sprite.Asset('../shared/char_walk.png'), new Sprite.Asset('../shared/char_shoot.png'), new Sprite.Asset('../shared/char_hurt.png')],\n  size: Vec2(64, 64),\n  speed: 0.09,\n  align: Vec2.bottomCenter,\n  sequences: {\n    walkN: [1, 8, 'walkW', null],\n    walkW: [10, 17, 'walkS', null],\n    walkS: [19, 26, 'walkE', null],\n    walkE: [28, 35, 'shootW', null],\n    shootW: [36, 37, 'shootS', 0.3],\n    shootS: [39, 40, 'shootN', 0.3],\n    shootN: [42, 43, 'hurt', 0.3],\n    hurt: [45, 50, null, 0.15]\n  }\n});\n\nAgentPrefab = new Composite.Prefab({\n  transform: null,\n  spriteTween: {\n    asset: agentSheet,\n    sequence: 'walkN'\n  }\n});\n\nEngine.gameScene = Composite.alloc(null, {\n  gameController: null\n});\n\nEngine.debug.stats = true;\n\nEngine.play(Engine.gameScene);\n\n//@ sourceURL=/examples/sprites/index.js"
));
require("/examples/sprites/index.js");
})();
