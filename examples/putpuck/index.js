// Generated by CoffeeScript 1.3.3
'use strict';

var Border, Bounds, Collider, Color, Component, Composite, Engine, Field, Kinetic, Particle, Pool, Puck, Renderer, Scene, Sprite, Transform, Vec2, apps, request, url,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Vec2 = require('../../lib/core/math').Vec2;

Engine = require('../../lib/core/engine');

Engine.init(document.getElementById('game-1'));

Renderer = require('../../lib/core/renderer');

Engine.renderer = new Renderer(Engine.element.getElementsByClassName('game-canvas')[0], Vec2(320, 480));

if ((apps = navigator.mozApps)) {
  url = 'http://testno.de/sputflik/examples/putpuck/manifest.webapp';
  request = apps.getSelf();
  request.onsuccess = function() {
    if (this.result) {
      return this.result.launch();
    } else {
      return apps.install(url);
    }
  };
  request.onerror = function() {
    return apps.install(url);
  };
}

Composite = require('../../lib/core/composite');

Component = require('../../lib/core/component');

Pool = require('../../lib/core/pool');

Color = require('../../lib/core/color');

Sprite = require('../../lib/core/sprite');

Transform = require('../../lib/core/transform');

Bounds = require('../../lib/core/bounds');

Border = require('../../lib/core/border');

Particle = require('../../lib/core/particle');

Collider = require('../../lib/core/collider');

Kinetic = require('../../lib/core/kinetic');

Scene = (function(_super) {

  __extends(Scene, _super);

  Scene.prototype.type = 'scene';

  function Scene() {
    Scene.__super__.constructor.call(this);
    this.player = 0;
    this.colors = {
      0: {
        high: Color(78, 205, 196)
      },
      1: {
        high: Color(255, 107, 107)
      }
    };
    this.colors[0].low = Color.lerp(this.colors[0].high, Color.white, 0.15, false, Color());
    this.colors[1].low = Color.lerp(this.colors[1].high, Color.white, 0.15, false, Color());
    this.inField1 = Field.Prefab.alloc(this, {
      transform: {
        pos: Vec2(0, 80)
      },
      bounds: {
        size: Vec2(320, 160)
      },
      field: {
        color: this.colors[0].low
      }
    });
    this.inField2 = Field.Prefab.alloc(this, {
      transform: {
        pos: Vec2(0, 240)
      },
      bounds: {
        size: Vec2(320, 160)
      },
      field: {
        color: this.colors[1].low
      }
    });
    this.outField1 = Field.Prefab.alloc(this, {
      transform: {
        pos: Vec2(0, 0)
      },
      bounds: {
        size: Vec2(320, 80)
      },
      field: {
        out: true
      }
    });
    this.outField2 = Field.Prefab.alloc(this, {
      transform: {
        pos: Vec2(0, 400)
      },
      bounds: {
        size: Vec2(320, 80)
      },
      field: {
        out: true
      }
    });
    this.setupPuck();
    this;

  }

  Scene.prototype.setupPuck = function() {
    var puck1, radius;
    this.player = this.player ? 0 : 1;
    radius = Math.rand(12, 25) | 0;
    puck1 = Puck.Prefab.alloc(this, {
      transform: {
        pos: Vec2(160, this.player ? 40 : 440)
      },
      bounds: {
        radius: radius
      },
      kinetic: {
        mass: radius
      },
      puck: {
        player: this.player,
        color: this.colors[this.player].high
      }
    });
    puck1.player = this.player;
    puck1.sub(this, 'onFlip', 'setupPuck');
    return this;
  };

  return Scene;

})(Composite);

Puck = (function(_super) {

  __extends(Puck, _super);

  Puck.prototype.type = 'puck';

  Puck.prototype.layer = 1;

  Puck.prototype.presets = {
    player: 0,
    color: Color()
  };

  function Puck() {
    this.color = Color();
    this.outlineColor = Color();
  }

  Puck.prototype.reset = function(presets) {
    this.player = presets.player;
    Color.copy(this.color, presets.color);
    Color.lerp(this.color, Color.black, 0.8, false, this.outlineColor);
    this.outlineColor[3] = 0.3;
    this.kinetic.enable(false);
    this.collider.enable(false);
    this.state = 'ready';
    this.treshold = 1;
    return this;
  };

  Puck.prototype.update = function(dt) {
    var delta, i, input, particle, pointer, pos, speed, vel;
    pos = this.transform.pos;
    input = Engine.input;
    switch (this.state) {
      case 'ready':
        if (input.touchState !== 'began' || !this.bounds.contains(input.pos)) {
          break;
        }
        this.state = 'dragging';
        break;
      case 'dragging':
        if (input.touchState === 'moved') {
          delta = input.time - input.prevTime;
          speed = Vec2.scal(Vec2.sub(input.pos, input.prevPos, Vec2.cache[0]), delta * 1000);
          if (this.avgSpeed) {
            Vec2.lerp(this.avgSpeed, speed, 0.5);
          } else {
            this.avgSpeed = Vec2(speed);
          }
          Vec2.copy(this.transform.pos, input.pos);
          break;
        }
        if (input.touchState === 'ended') {
          if (!this.avgSpeed || Vec2.len(this.avgSpeed) < this.treshold) {
            this.state = 'ready';
            break;
          }
          this.state = 'flipped';
          this.kinetic.enable(true);
          this.collider.enable(true);
          Vec2.copy(this.kinetic.vel, this.avgSpeed);
          this.parent.pub('onFlip', this);
          this.avgSpeed = null;
        }
        break;
      case 'flipped':
        break;
        vel = Vec2.len(this.kinetic.vel);
        i = vel / 40 | 0;
        while (i--) {
          pos = Vec2.set(Vec2.cache[0], Math.rand(-1, 1), Math.rand(-1, 1));
          Vec2.norm(pos, null, this.bounds.radius);
          pointer = Vec2.copy(Vec2.cache[1], pos);
          Vec2.add(Vec2.norm(pos, null, this.bounds.radius), this.transform.pos);
          Vec2.scal(pointer, Math.rand(0, vel / 8));
          particle = Particle.alloc(this.root, pos, pointer, Math.rand(0.01, 0.05), Math.rand(1, 3));
          particle.sprite = Puck.particleFlipSprite;
        }
        break;
    }
    return this;
  };

  Puck.prototype.onKineticSleep = function() {
    return this;
  };

  Puck.prototype.render = function(ctx) {
    var pos;
    ctx.save();
    pos = this.transform.pos;
    ctx.beginPath();
    ctx.arc(pos[0] | 0, pos[1] | 0, this.bounds.radius | 0, 0, Math.TAU);
    ctx.closePath();
    ctx.fillStyle = Color.rgba(this.color);
    ctx.fill();
    if (this.state === 'ready' || this.kinetic.sleeping) {
      ctx.lineWidth = 4;
      ctx.strokeStyle = Color.rgba(this.outlineColor);
      ctx.stroke();
    }
    ctx.restore();
    return this;
  };

  return Puck;

})(Component);

new Pool(Puck);

Particle.defaultComposite = null;

Puck.particleFlipSprite = Particle.generateSprite(Color(199, 244, 100));

Puck.particleSmokeSprite = Particle.generateSprite(Color(128, 128, 128), 0.5);

Puck.Prefab = new Composite.Prefab({
  transform: null,
  bounds: {
    shape: 'circle',
    radius: 15
  },
  kinetic: {
    mass: 1,
    drag: 0.994,
    maxVel: 450
  },
  collider: null,
  border: {
    bounciness: 0.6
  },
  puck: null
});

Field = (function(_super) {

  __extends(Field, _super);

  Field.prototype.type = 'field';

  Field.prototype.presets = {
    color: Color.white,
    out: false,
    player: 0
  };

  function Field() {
    this.color = Color();
  }

  Field.prototype.reset = function(presets) {
    var targets;
    this.out = presets.out;
    this.player = presets.player;
    Color.copy(this.color, presets.color);
    targets = Puck.pool.roster;
    this.root.sub(this, 'onKineticSleep');
    return this;
  };

  Field.prototype.onKineticSleep = function(kinetic) {
    if (this.bounds.contains(kinetic.pos) && this.out) {
      kinetic.parent.free();
    }
    return this;
  };

  Field.prototype.render = function(ctx) {
    if (this.out) {
      return this;
    }
    ctx.fillStyle = Color.rgba(this.color);
    ctx.fillRect(this.transform.pos[0], this.transform.pos[1], this.bounds.size[0], this.bounds.size[1]);
    return this;
  };

  return Field;

})(Component);

new Pool(Field);

Field.Prefab = new Composite.Prefab({
  transform: null,
  bounds: {
    shape: 'rect'
  },
  field: null
});

Engine.play(new Scene());
