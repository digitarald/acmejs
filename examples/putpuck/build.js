;(function(e,t,n,r){function i(r){if(!n[r]){if(!t[r]){if(e)return e(r);throw new Error("Cannot find module '"+r+"'")}var s=n[r]={exports:{}};t[r][0](function(e){var n=t[r][1][e];return i(n?n:e)},s,s.exports)}return n[r].exports}for(var s=0;s<r.length;s++)i(r[s]);return i})(typeof require!=="undefined"&&require,{1:[function(require,module,exports){// Generated by CoffeeScript 1.6.1
'use strict';
var Border, Bounds, Collider, Color, Component, Engine, Entity, Field, GameController, Kinetic, Particle, Pool, Puck, Renderer, Sprite, Transform, Vec2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Vec2 = require('../../lib/core/math').Vec2;

Engine = require('../../lib/core/engine');

Engine.init(document.getElementById('game-1'));

Renderer = require('../../lib/core/renderer');

Engine.renderer = new Renderer(Engine.element.getElementsByClassName('game-canvas')[0], Vec2(320, 480));

Entity = require('../../lib/core/entity');

Component = require('../../lib/core/component');

Pool = require('../../lib/core/pool');

Color = require('../../lib/core/color');

Sprite = require('../../lib/core/sprite');

Transform = require('../../lib/core/transform');

Bounds = require('../../lib/core/bounds');

Border = require('../../lib/core/border');

Particle = require('../../lib/core/particle');

Collider = require('../../lib/core/collider');

Kinetic = require('../../lib/core/kinetic');

GameController = (function(_super) {

  __extends(GameController, _super);

  function GameController() {
    return GameController.__super__.constructor.apply(this, arguments);
  }

  GameController.prototype.tag = 'gameController';

  GameController.prototype.instantiate = function() {
    this.player = 0;
    this.colors = {
      0: {
        high: Color(78, 205, 196)
      },
      1: {
        high: Color(255, 107, 107)
      }
    };
    this.colors[0].low = Color.lerp(this.colors[0].high, Color.white, 0.85, false, Color());
    this.colors[1].low = Color.lerp(this.colors[1].high, Color.white, 0.85, false, Color());
    this.inField1 = Field.Prefab.alloc(this.entity, {
      transform: {
        pos: Vec2(0, 80)
      },
      bounds: {
        size: Vec2(320, 160)
      },
      field: {
        color: this.colors[0].low,
        player: 0
      }
    });
    this.inField2 = Field.Prefab.alloc(this.entity, {
      transform: {
        pos: Vec2(0, 240)
      },
      bounds: {
        size: Vec2(320, 160)
      },
      field: {
        color: this.colors[1].low,
        player: 1
      }
    });
    this.outField1 = Field.Prefab.alloc(this.entity, {
      transform: {
        pos: Vec2(0, 0)
      },
      bounds: {
        size: Vec2(320, 80)
      },
      field: {
        out: true,
        player: 0
      }
    });
    this.outField2 = Field.Prefab.alloc(this.entity, {
      transform: {
        pos: Vec2(0, 400)
      },
      bounds: {
        size: Vec2(320, 80)
      },
      field: {
        out: true,
        player: 1
      }
    });
    this.setupPuck();
    return this;
  };

  GameController.prototype.setupPuck = function() {
    var puck1, radius;
    this.player = this.player ? 0 : 1;
    radius = Math.rand(12, 25) | 0;
    puck1 = Puck.Prefab.alloc(this.entity, {
      transform: {
        pos: Vec2(160, this.player ? 40 : 440)
      },
      bounds: {
        radius: radius
      },
      kinetic: {
        mass: radius
      },
      puck: {
        player: this.player,
        color: this.colors[this.player].high,
        field: this.player ? this.outField1 : this.outField2
      }
    });
    puck1.player = this.player;
    puck1.sub(this, 'onFlip', 'setupPuck');
    return this;
  };

  return GameController;

})(Component);

new Pool(GameController);

Puck = (function(_super) {
  var particlePos, speed;

  __extends(Puck, _super);

  Puck.prototype.tag = 'puck';

  Puck.prototype.layer = 1;

  Puck.prototype.attributes = {
    player: 0,
    color: Color(),
    field: null
  };

  function Puck() {
    this.color = Color();
    this.outlineColor = Color();
  }

  Puck.prototype.instantiate = function(attributes) {
    this.player = attributes.player, this.field = attributes.field;
    Color.copy(this.color, attributes.color);
    Color.lerp(this.color, Color.black, 0.2, false, this.outlineColor);
    this.outlineColor[3] = 0.3;
    this.kinetic.enable(false);
    this.collider.enable(false);
    this.state = 'ready';
    this.treshold = 1;
    return this;
  };

  Puck.prototype.update = function(dt) {
    var delta, i, input, particle, pointer, pos, speed, vel;
    pos = this.transform.pos;
    input = Engine.input;
    switch (this.state) {
      case 'ready':
        if (input.touchState !== 'began' || !this.bounds.contains(input.pos)) {
          break;
        }
        this.state = 'dragging';
        break;
      case 'dragging':
        if (input.touchState === 'moved') {
          if (this.player) {
            if (input.pos[1] > this.field.bounds.bottom) {
              this.state = 'draggingEnd';
            }
          } else {
            if (input.pos[1] < this.field.bounds.top) {
              this.state = 'draggingEnd';
            }
          }
          delta = input.time - input.prevTime;
          speed = Vec2.scal(Vec2.sub(input.pos, input.prevPos, Vec2.cache[0]), delta * 1000);
          if (this.avgSpeed) {
            Vec2.lerp(this.avgSpeed, speed, 0.5);
          } else {
            this.avgSpeed = Vec2(speed);
          }
          Vec2.copy(this.transform.pos, input.pos);
          break;
        }
        if (input.touchState === 'ended') {
          this.state = 'draggingEnd';
          break;
        }
        break;
      case 'draggingEnd':
        if (!this.avgSpeed || Vec2.len(this.avgSpeed) < this.treshold) {
          this.state = 'ready';
          break;
        }
        console.log(Vec2.len(this.avgSpeed));
        this.state = 'flipped';
        this.kinetic.enable(true);
        this.collider.enable(true);
        Vec2.copy(this.kinetic.velocity, this.avgSpeed);
        this.entity.pub('onFlip', this);
        this.avgSpeed = null;
        break;
      case 'flipped':
        break;
        vel = Vec2.len(this.kinetic.velocity);
        i = vel / 40 | 0;
        while (i--) {
          pos = Vec2.set(Vec2.cache[0], Math.rand(-1, 1), Math.rand(-1, 1));
          Vec2.norm(pos, null, this.bounds.radius);
          pointer = Vec2.copy(Vec2.cache[1], pos);
          Vec2.add(Vec2.norm(pos, null, this.bounds.radius), this.transform.pos);
          Vec2.scal(pointer, Math.rand(0, vel / 8));
          particle = Particle.Prefab.alloc(this.root, {
            particle: {
              lifetime: Math.rand(0.1, 0.5),
              radius: Math.rand(2, 10),
              color: this.color,
              sprite: Puck.particleSmokeSprite
            },
            kinetic: {
              velocity: pointer
            },
            transform: {
              pos: pos
            }
          });
        }
        break;
    }
    return this;
  };

  particlePos = Vec2();

  speed = Vec2();

  Puck.prototype.onCollide = function() {
    var i, particle, pointer, pos;
    i = this.bounds.radius;
    while (i--) {
      pos = Vec2.set(particlePos, Math.rand(-1, 1), Math.rand(-1, 1));
      Vec2.norm(pos, null, this.bounds.radius);
      pointer = Vec2.copy(speed, pos);
      Vec2.add(Vec2.norm(pos, null, this.bounds.radius), this.transform.pos);
      Vec2.scal(pointer, Math.rand(0, Vec2.len(this.kinetic.velocity) / 8));
      particle = Particle.Prefab.alloc(this.root, {
        particle: {
          lifetime: Math.rand(0.1, 0.5),
          radius: Math.rand(1, 3),
          color: this.color
        },
        kinetic: {
          velocity: pointer
        },
        transform: {
          pos: pos
        }
      });
    }
    return this;
  };

  Puck.prototype.render = function(ctx) {
    var pos;
    ctx.save();
    pos = this.transform.pos;
    ctx.beginPath();
    ctx.arc(pos[0] | 0, pos[1] | 0, this.bounds.radius | 0, 0, Math.TAU);
    ctx.closePath();
    ctx.fillStyle = Color.rgba(this.color);
    ctx.fill();
    if (this.state === 'ready' || this.kinetic.sleeping) {
      ctx.lineWidth = 4;
      ctx.strokeStyle = Color.rgba(this.outlineColor);
      ctx.stroke();
    }
    ctx.restore();
    return this;
  };

  return Puck;

})(Component);

new Pool(Puck);

Particle.defaultEntity = null;

Puck.particleFlipSprite = Particle.generateSprite(Color(199, 244, 100));

Puck.particleSmokeSprite = Particle.generateSprite(Color(128, 128, 128), 0.5);

console.log(Puck.particleSmokeSprite.toString());

Puck.Prefab = new Entity.Prefab({
  transform: null,
  bounds: {
    shape: 'circle',
    radius: 15
  },
  kinetic: {
    mass: 1,
    drag: 0.995,
    maxVelocity: 900
  },
  collider: null,
  border: {
    bounce: true,
    restitution: 0.6
  },
  puck: null
});

Field = (function(_super) {

  __extends(Field, _super);

  Field.prototype.tag = 'field';

  Field.prototype.attributes = {
    color: Color.white,
    out: false,
    player: 0
  };

  function Field() {
    this.color = Color();
  }

  Field.prototype.instantiate = function(attributes) {
    this.out = attributes.out, this.player = attributes.player;
    Color.copy(this.color, attributes.color);
    this.root.sub(this, 'onKineticSleep');
    return this;
  };

  Field.prototype.onKineticSleep = function(kinetic) {
    if (this.bounds.contains(kinetic.pos) && this.out) {
      kinetic.entity.destroy();
    }
    return this;
  };

  Field.prototype.render = function(ctx) {
    if (this.out) {
      return this;
    }
    ctx.fillStyle = Color.rgba(this.color);
    ctx.fillRect(this.transform.pos[0], this.transform.pos[1], this.bounds.size[0], this.bounds.size[1]);
    return this;
  };

  return Field;

})(Component);

new Pool(Field);

Field.Prefab = new Entity.Prefab({
  transform: null,
  bounds: {
    shape: 'rect'
  },
  field: null
});

Engine.gameScene = Entity.alloc(null, {
  gameController: null
});

Engine.play(Engine.gameScene);

},{"../../lib/core/math":2,"../../lib/core/engine":3,"../../lib/core/renderer":4,"../../lib/core/entity":5,"../../lib/core/component":6,"../../lib/core/pool":7,"../../lib/core/color":8,"../../lib/core/sprite":9,"../../lib/core/transform":10,"../../lib/core/bounds":11,"../../lib/core/border":12,"../../lib/core/particle":13,"../../lib/core/collider":14,"../../lib/core/kinetic":15}],2:[function(require,module,exports){// Generated by CoffeeScript 1.6.1
var EPSILON, Mat2, Mth, Vec2, abs, fn, i, objCache, objVecCache, pow, powIn, radCache, random, sqrt, toInOut, toOut, transition, typedArray, _i, _len, _ref;

Mth = Math;

sqrt = Mth.sqrt, pow = Mth.pow, abs = Mth.abs, random = Mth.random, random = Mth.random, pow = Mth.pow;

Mth.EPSILON = EPSILON = 0.001;

Mth.TAU = Mth.PI * 2;

Mth.PIRAD = 0.0174532925;

Mth.UID = 1;

Mth.uid = function() {
  return Mth.UID++;
};

Mth.clamp = function(a, low, high) {
  if (a < low) {
    return low;
  }
  if (a > high) {
    return high;
  } else {
    return a;
  }
};

Mth.rand = function(low, high, ease) {
  return (ease || Mth.linear)(random()) * (high - low) + low;
};

Mth.randArray = function(array) {
  return array[random() * array.length | 0];
};

Mth.chance = function(chance) {
  return random() <= chance;
};

powIn = function(strength) {
  if (strength == null) {
    strength = 2;
  }
  return function(t) {
    return pow(t, strength);
  };
};

toOut = function(fn) {
  return function(t) {
    return 1 - fn(1 - t);
  };
};

toInOut = function(fn) {
  return function(t) {
    return (t < 0.5 ? fn(t * 2) : 2 - fn(2 * (1 - t))) / 2;
  };
};

Mth.linear = function(t) {
  return t;
};

_ref = ['quad', 'cubic', 'quart', 'quint'];
for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
  transition = _ref[i];
  Mth[transition + 'In'] = fn = powIn(i + 2);
  Mth[transition + 'Out'] = toOut(fn);
  Mth[transition + 'InOut'] = toInOut(fn);
}

Mth.TypedArray = typedArray = Float64Array || Float32Array || function(arr) {
  return arr;
};

Mth.Vec2 = Vec2 = function(fromOrX, y) {
  if (y != null) {
    return new typedArray([fromOrX, y]);
  }
  if (fromOrX != null) {
    return new typedArray(fromOrX);
  }
  return new typedArray(Vec2.zero);
};

Vec2.zero = Vec2.center = Vec2(0, 0);

Vec2.cache = [Vec2(), Vec2(), Vec2(), Vec2(), Vec2()];

Vec2.topLeft = Vec2(-1, -1);

Vec2.topCenter = Vec2(0, -1);

Vec2.topRight = Vec2(1, -1);

Vec2.centerLeft = Vec2(-1, 0);

Vec2.centerRight = Vec2(1, 0);

Vec2.bottomLeft = Vec2(-1, 1);

Vec2.bottomCenter = Vec2(0, 1);

Vec2.bottomRight = Vec2(1, 1);

radCache = [Vec2(), Vec2()];

objCache = {
  x: 0,
  y: 0
};

objVecCache = Vec2();

Vec2.set = function(result, x, y) {
  result[0] = x || 0;
  result[1] = y || 0;
  return result;
};

Vec2.copy = function(result, b) {
  result[0] = b[0];
  result[1] = b[1];
  return result;
};

Vec2.valid = function(a) {
  return !(isNaN(a[0]) || isNaN(a[1]));
};

Vec2.toString = function(a) {
  return "[" + a[0] + ", " + a[1] + "]";
};

Vec2.fromObj = function(obj, a) {
  a || (a = objVecCache);
  a[0] = obj.x;
  a[1] = obj.y;
  return a;
};

Vec2.toObj = function(a, obj) {
  obj || (obj = objCache);
  obj.x = a[0];
  obj.y = a[1];
  return obj;
};

Vec2.eq = function(a, b) {
  return abs(a[0] - b[0]) < EPSILON && abs(a[1] - b[1]) < EPSILON;
};

Vec2.add = function(a, b, result) {
  result || (result = a);
  result[0] = a[0] + b[0];
  result[1] = a[1] + b[1];
  return result;
};

Vec2.sub = function(a, b, result) {
  result || (result = a);
  result[0] = a[0] - b[0];
  result[1] = a[1] - b[1];
  return result;
};

Vec2.mul = function(a, b, result) {
  result || (result = a);
  result[0] = a[0] * b[0];
  result[1] = a[1] * b[1];
  return result;
};

Vec2.scal = function(a, scalar, result) {
  result || (result = a);
  result[0] = a[0] * scalar;
  result[1] = a[1] * scalar;
  return result;
};

Vec2.norm = function(a, result, scalar) {
  var len, x, y;
  result || (result = a);
  x = a[0];
  y = a[1];
  len = (scalar || 1) / (sqrt(x * x + y * y) || 1);
  result[0] = x * len;
  result[1] = y * len;
  return result;
};

Vec2.lenSq = function(a) {
  return a[0] * a[0] + a[1] * a[1];
};

Vec2.len = function(a) {
  return sqrt(a[0] * a[0] + a[1] * a[1]);
};

Vec2.dot = function(a, b) {
  return a[0] * b[0] + a[1] * b[1];
};

Vec2.cross = function(a, b) {
  return a[0] * b[1] - a[1] * b[0];
};

Vec2.lerp = function(a, b, scalar, result) {
  result || (result = a);
  result[0] = a[0] + scalar * (b[0] - a[0]);
  result[1] = a[1] + scalar * (b[1] - a[1]);
  return result;
};

Vec2.max = function(a, b, axis) {
  if (axis != null) {
    if (a[axis] > b[axis]) {
      return a;
    } else {
      return b;
    }
  }
  if (Vec2.lenSq(a) > Vec2.lenSq(b)) {
    return a;
  } else {
    return b;
  }
};

Vec2.perp = function(a, result) {
  var x;
  result || (result = a);
  x = a[0];
  result[0] = a[1];
  result[1] = -x;
  return result;
};

Vec2.dist = function(a, b) {
  var x, y;
  x = b[0] - a[0];
  y = b[1] - a[1];
  return sqrt(x * x + y * y);
};

Vec2.distSq = function(a, b) {
  var x, y;
  x = b[0] - a[0];
  y = b[1] - a[1];
  return x * x + y * y;
};

Vec2.limit = function(a, max, result) {
  var ratio, x, y;
  result || (result = a);
  x = a[0];
  y = a[1];
  if ((ratio = max / sqrt(x * x + y * y)) < 1) {
    result[0] = x * ratio;
    result[1] = y * ratio;
  } else if (result !== a) {
    result[0] = x;
    result[1] = y;
  }
  return result;
};

Vec2.rad = function(a, b) {
  if (!b) {
    return Mth.atan2(a[1], a[0]);
  }
  return Mth.acos(Vec2.dot(Vec2.norm(a, radCache[0]), Vec2.norm(b, radCache[1])));
};

Vec2.rot = function(a, theta, result) {
  var cosA, sinA, x, y;
  result || (result = a);
  sinA = Mth.sin(theta);
  cosA = Mth.cos(theta);
  x = a[0];
  y = a[1];
  result[0] = x * cosA - y * sinA;
  result[1] = x * sinA + y * cosA;
  return result;
};

Vec2.rotAxis = function(a, b, theta, result) {
  return Vec2.add(Vec2.rot(Vec2.sub(a, b, result || a), theta), b);
};

Vec2.lookAt = function(a, b, result) {
  var len;
  len = Vec2.len(a);
  return Vec2.norm(Vec2.rot(a, Mth.atan2(b[0] - a[0], b[1] - a[1]) - Mth.atan2(a[1], a[0]), result || a), null, len);
};

Vec2.variant = function(a, delta, result) {
  result || (result = a);
  result[0] = a[0] + Math.rand(-delta, delta);
  result[1] = a[1] + Math.rand(-delta, delta);
  return result;
};

module.exports.Vec2 = Vec2;

Mth.Mat2 = Mat2 = function(fromOrA, b, c, d, tx, ty) {
  if (b != null) {
    return new typedArray([fromOrA, b, c, d, tx, ty]);
  }
  if (fromOrA != null) {
    return new typedArray(fromOrA);
  }
  return new typedArray(Mat2.identity);
};

Mat2.identity = Mat2(1, 0, 0, 1, 0, 0);

Mat2.set = function(result, a, b, c, d, tx, ty) {
  result[0] = a || 0;
  result[1] = b || 0;
  result[2] = c || 0;
  result[3] = d || 0;
  result[4] = tx || 0;
  result[5] = ty || 0;
  return result;
};

Mat2.copy = function(result, b) {
  result[0] = b[0];
  result[1] = b[1];
  result[2] = b[2];
  result[3] = b[3];
  result[4] = b[4];
  result[5] = b[5];
  return result;
};

Mat2.valid = function(a) {
  return !(isNaN(a[0]) || isNaN(a[1]) || isNaN(a[2]) || isNaN(a[3]) || isNaN(a[4]) || isNaN(a[5]));
};

Mat2.toString = function(a) {
  return "[" + a[0] + ", " + a[1] + " | " + a[2] + ", " + a[3] + " | " + a[4] + ", " + a[5] + "]";
};

Mat2.mul = function(a, b, result) {
  var aa, ab, ac, ad, atx, aty, ba, bb, bc, bd, btx, bty;
  result || (result = a);
  aa = a[0];
  ab = a[1];
  ac = a[2];
  ad = a[3];
  atx = a[4];
  aty = a[5];
  ba = b[0];
  bb = b[1];
  bc = b[2];
  bd = b[3];
  btx = b[4];
  bty = b[5];
  result[0] = aa * ba + ab * bc;
  result[1] = aa * bb + ab * bd;
  result[2] = ac * ba + ad * bc;
  result[3] = ac * bb + ad * bd;
  result[4] = ba * atx + bc * aty + btx;
  result[5] = bb * atx + bd * aty + bty;
  return result;
};

Mat2.rot = function(a, rad, result) {
  var aa, ab, ac, ad, atx, aty, ct, st;
  result || (result = a);
  aa = a[0];
  ab = a[1];
  ac = a[2];
  ad = a[3];
  atx = a[4];
  aty = a[5];
  st = Mth.sin(rad);
  ct = Mth.cos(rad);
  result[0] = aa * ct + ab * st;
  result[1] = -aa * st + ab * ct;
  result[2] = ac * ct + ad * st;
  result[3] = -ac * st + ct * ad;
  result[4] = ct * atx + st * aty;
  result[5] = ct * aty - st * atx;
  return result;
};

Mat2.scal = function(a, v, result) {
  var vx, vy;
  result || (result = a);
  vx = v[0];
  vy = v[1];
  result[0] = a[0] * vx;
  result[1] = a[1] * vy;
  result[2] = a[2] * vx;
  result[3] = a[3] * vy;
  result[4] = a[4] * vx;
  result[5] = a[5] * vy;
  return result;
};

Mat2.trans = function(a, v, result) {
  result || (result = a);
  result[0] = a[0];
  result[1] = a[1];
  result[2] = a[2];
  result[3] = a[3];
  result[4] = a[4] + v[0];
  result[5] = a[5] + v[1];
  return result;
};

module.exports.Mat2 = Mat2;

},{}],3:[function(require,module,exports){// Generated by CoffeeScript 1.6.1
var Engine, Entity, Pool, Vec2, engine, perf, requestAnimationFrame,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Entity = require('./entity');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
  return setTimeout(callback, 20);
};

perf = window.performance || {};

perf.now = perf.now || perf.webkitNow || perf.msNow || perf.mozNow || Date.now;

Engine = (function(_super) {

  __extends(Engine, _super);

  function Engine() {
    return Engine.__super__.constructor.apply(this, arguments);
  }

  Engine.prototype.tag = 'engine';

  Engine.prototype.init = function(element) {
    var Console, Input,
      _this = this;
    this.element = element;
    this.time = 0.0;
    this.lastTime = 0.0;
    this.frame = 0;
    this.tail = 0.0;
    this.debug = {
      profile: 0,
      step: false,
      time: true
    };
    this.samples = {
      dt: 0,
      lag: 0,
      tick: 0,
      fixedUpdate: 0,
      update: 0,
      render: 0
    };
    this.fdt = 1 / 30;
    this.dtMin = 1 / 60;
    this.dtCap = 0.5;
    this.fdtCap = this.fdt * 5;
    this.scale = 1;
    Console = require('./console');
    Console.alloc(this);
    Input = require('./input');
    Input.alloc(this);
    return this.tickBound = function(now) {
      return _this.tick(now);
    };
  };

  Engine.prototype.play = function(scene) {
    this.scene = scene;
    return this.start();
  };

  Engine.prototype.start = function() {
    if (!this.running) {
      this.running = true;
      requestAnimationFrame(this.tickBound);
    }
    return this;
  };

  Engine.prototype.tick = function(time) {
    var ctx, debug, dt, fdt, lag, ping, pingTick, pong, samples, tail;
    this.time = time = (time && time < 1e12 ? time : perf.now()) / 1000;
    debug = this.debug, samples = this.samples, fdt = this.fdt;
    if (this.lastTime) {
      if ((dt = time - this.lastTime) > this.dtCap) {
        dt = this.dtMin;
      } else if (dt > 0.01) {
        samples.dt = dt;
        if ((lag = time - samples.next) > 0) {
          samples.lag = lag * 1000;
        }
      }
      this.dt = (dt *= this.scale);
      this.frame++;
      if (debug.profile && !debug.profileFrom) {
        debug.profileFrom = debug.profile;
        console.profile("Frame " + debug.profileFrom);
      }
      pingTick = ping = perf.now();
      tail = Math.min(this.tail + dt, this.fdtCap * this.scale);
      while (tail > fdt) {
        tail -= fdt;
        Pool.invoke('fixedUpdate', fdt);
        Pool.invoke('simulate', fdt);
      }
      this.tail = tail;
      pong = perf.now();
      samples.fixedUpdate = pong - ping;
      ping = pong;
      Pool.invoke('update', dt);
      Pool.free();
      Pool.invoke('postUpdate', dt);
      pong = perf.now();
      samples.update = pong - ping;
      ping = pong;
      Pool.invoke('preRender', dt);
      ctx = this.renderer.save();
      Pool.invoke('render', ctx, dt);
      this.renderer.restore();
      pong = perf.now();
      samples.render = pong - ping;
      samples.tick = pong - pingTick;
      if (debug.step) {
        debugger;
      }
      if (debug.profileFrom) {
        if (!--debug.profile) {
          console.profileEnd("Frame " + debug.profileFrom);
          debug.profileFrom = 0;
        }
      }
    }
    this.lastTime = time;
    samples.next = Math.max(time + 1 / 60, perf.now() / 1000);
    this.pub('onTimeEnd', samples);
    if (this.pauseNext) {
      this.pub('onPause');
      this.paused = true;
      this.tickBound(samples.next * 1000);
    } else if (this.running) {
      requestAnimationFrame(this.tickBound);
    }
    return this;
  };

  return Engine;

})(Entity);

engine = new Engine();

if ('console' in window) {
  console.m = {
    pool: function(flush) {
      Pool.dump(flush);
      return null;
    },
    profile: function(frames) {
      if (frames == null) {
        frames = 60;
      }
      engine.debug.profile = frames;
      return null;
    },
    step: function() {
      engine.debug.step = !engine.debug.step;
      return null;
    }
  };
}

module.exports = engine;

},{"./entity":5,"./pool":7,"./math":2,"./console":16,"./input":17}],4:[function(require,module,exports){// Generated by CoffeeScript 1.6.1
var Bounds, Color, Entity, Renderer, Vec2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Entity = require('./entity');

Bounds = require('./bounds');

Vec2 = require('./math').Vec2;

Color = require('./color');

Renderer = (function(_super) {

  __extends(Renderer, _super);

  function Renderer(element, size) {
    this.element = element;
    this.size = Vec2(size);
    this.content = Vec2(size);
    this.canvas = document.createElement('canvas');
    this.element.appendChild(this.canvas);
    this.ctx = this.canvas.getContext('2d');
    this.browser = Vec2();
    this.margin = Vec2();
    this.pos = Vec2();
    this.scale = 0;
    this.orientation = 'landscape';
    this.buffer = false;
    if (this.buffer) {
      this.buf = document.createElement('canvas');
      this.bufctx = this.buf.getContext('2d');
      this.buf.width = this.content[0];
      this.buf.height = this.content[1];
    }
    this.canvas.width = this.content[0];
    this.canvas.height = this.content[1];
    this.element.style.width = this.content[0] + 'px';
    this.element.style.height = this.content[1] + 'px';
    window.addEventListener('resize', this, false);
    document.addEventListener('fullscreenchange', this, false);
    document.addEventListener('mozfullscreenchange', this, false);
    document.addEventListener('webkitfullscreenchange', this, false);
    this.reflow();
    this;
  }

  Renderer.prototype.handleEvent = function(evt) {
    if (~evt.type.indexOf('fullscreenchange')) {
      this.fullscreenChange();
    } else {
      this.reflow();
    }
    return this;
  };

  Renderer.prototype.reflow = function() {
    var browser, rule, scale;
    browser = Vec2.set(this.browser, window.innerWidth, window.innerHeight);
    scale = Math.min(this.browser[0] / this.content[0], this.browser[1] / this.content[1]);
    if (scale !== this.scale) {
      this.scale = scale;
      Vec2.scal(this.content, this.scale, this.size);
    }
    Vec2.scal(Vec2.sub(browser, this.size, this.margin), 0.5);
    rule = "translate(" + this.margin[0] + "px, " + this.margin[1] + "px) scale(" + this.scale + ")";
    this.element.style.transform = rule;
    this.element.style.webkitTransform = rule;
    return this;
  };

  Renderer.prototype.save = function() {
    var ctx;
    ctx = this.buffer ? this.bufctx : this.ctx;
    if (this.color) {
      ctx.fillStyle = Color.rgba(this.color);
      ctx.fillRect(0, 0, this.content[0], this.content[1]);
    } else {
      ctx.clearRect(0, 0, this.content[0], this.content[1]);
    }
    return ctx;
  };

  Renderer.prototype.restore = function() {
    if (this.buffer) {
      this.ctx.clearRect(0, 0, this.content[0], this.content[1]);
      this.ctx.drawImage(this.buf, 0, 0);
    }
    return this;
  };

  Renderer.prototype.center = function(pos) {
    Vec2.set(this.pos, pos[0] - this.size[0] / 2, pos[0] - this.size[1] / 2);
    return this;
  };

  Renderer.prototype.cull = function(entity) {
    var bounds;
    if (!(bounds = entity.bounds)) {
      return false;
    }
    if (bounds.withinRect(this.pos, this.content)) {
      if (bounds.culled) {
        bounds.culled = false;
      }
      return false;
    }
    if (!bounds.culled) {
      bounds.culled = true;
    }
    return true;
  };

  Renderer.prototype.isFullscreen = function() {
    var doc;
    doc = document;
    return doc.fullscreen || doc.mozFullScreen || doc.webkitIsFullScreen;
  };

  Renderer.prototype.requestFullscreen = function() {
    var target;
    if (!this.isFullscreen()) {
      target = this.element.parentNode;
      if ('webkitRequestFullScreen' in target) {
        target.webkitRequestFullScreen();
      } else if ('mozRequestFullScreen' in target) {
        target.mozRequestFullScreen();
      }
    }
    return this;
  };

  Renderer.prototype.fullscreenChange = function() {
    if (this.orientation) {
      this.lockOrientation(this.orientation);
    }
    return this;
  };

  Renderer.prototype.lockOrientation = function(format) {
    var target;
    if (format == null) {
      format = this.orientation;
    }
    target = window.screen;
    if ('lockOrientation' in target) {
      screen.lockOrientation(format);
    } else if ('mozLockOrientation' in target) {
      screen.mozLockOrientation(format);
    }
    return this;
  };

  return Renderer;

})(Entity);

module.exports = Renderer;

},{"./entity":5,"./bounds":11,"./math":2,"./color":8}],5:[function(require,module,exports){// Generated by CoffeeScript 1.6.1
var Entity, Pool;

Pool = require('./pool');

Entity = (function() {

  function Entity() {
    this.children = {};
    this.components = {};
  }

  Entity.prototype.toString = function() {
    var comps;
    comps = Object.keys(this.components).join(', ');
    return "Entity " + (this.id || '') + "#" + this.uid + " (" + comps + ") [^ " + this.parent + "]";
  };

  Entity.prototype.alloc = function(attributes) {
    var attribute, child, key, pool, _i, _len;
    if (this.parent) {
      this.parent.children[this.uid] = this;
    }
    if (attributes) {
      for (key in attributes) {
        attribute = attributes[key];
        switch (key) {
          case 'children':
            for (_i = 0, _len = attribute.length; _i < _len; _i++) {
              child = attribute[_i];
              Entity.alloc(this, child);
            }
            break;
          case 'id':
            this.id = attribute;
            break;
          default:
            if ((pool = Pool.byTag[key])) {
              pool.alloc(this, attribute);
            } else {
              throw new Error("Unknown attribute key '" + key + "', expected component. " + this);
            }
        }
      }
    }
    return this;
  };

  Entity.prototype.destroy = function() {
    var key;
    this.pool.destroy(this);
    for (key in this.components) {
      this.components[key].destroy();
    }
    for (key in this.children) {
      this.children[key].destroy();
    }
    return this;
  };

  Entity.prototype.free = function() {
    var ref, refSubs, subs, topic, _i, _len;
    if ((refSubs = this.refSubs)) {
      for (_i = 0, _len = refSubs.length; _i < _len; _i++) {
        ref = refSubs[_i];
        ref.unsub(this);
      }
      refSubs.length = 0;
    }
    if ((subs = this.subs)) {
      for (topic in subs) {
        subs[topic].length = 0;
      }
    }
    if (this.parent) {
      delete this.parent.children[this.uid];
    }
    this.pool.free(this);
    return this;
  };

  Entity.prototype.match = function(selector) {
    var components, tag, _i, _len;
    components = this.components;
    if (Array.isArray(selector)) {
      for (_i = 0, _len = selector.length; _i < _len; _i++) {
        tag = selector[_i];
        if (components[tag]) {
          return true;
        }
      }
    } else if (components[selector]) {
      return true;
    }
    return false;
  };

  Entity.prototype.enable = function(state, deep) {
    var key;
    this.enabled = state != null ? state : state = !this.state;
    this.parent.pub((state ? 'onEnable' : 'onDisable'), this);
    for (key in this.components) {
      this.components[key].enable(state, true);
    }
    if (deep) {
      for (key in this.children) {
        this.children[key].enable(state, true);
      }
    }
    return this;
  };

  Entity.prototype.sub = function(scope, topic, method) {
    var items, refs, subs;
    if (scope == null) {
      scope = this;
    }
    subs = (this.subs || (this.subs = {}));
    items = (subs[topic] || (subs[topic] = []));
    items.push(scope, method);
    if (scope !== this) {
      refs = (scope.refSubs || (scope.refSubs = []));
      refs.push(this);
    }
    return this;
  };

  Entity.prototype.pub = function(topic, a0, a1, a2, a3) {
    var i, items, scope;
    if (this.subs && (items = this.subs[topic]) && (i = items.length)) {
      while ((scope = items[i -= 2])) {
        if (scope.enabled) {
          if (scope[items[i + 1] || topic](a0, a1, a2, a3) === false) {
            return false;
          }
        }
      }
    }
    return this;
  };

  Entity.prototype.pubUp = function(topic, a0, a1, a2, a3) {
    var entity;
    entity = this;
    while (entity) {
      if (!entity.enabled) {
        continue;
      }
      if (entity.pub(topic, a0, a1, a2, a3) === false) {
        return false;
      }
      entity = entity.entity;
    }
    return this;
  };

  Entity.prototype.pubAll = function(topic, a0, a1, a2, a3) {
    return Pool.call(topic, a0, a1, a2, a3);
  };

  Entity.prototype.unsub = function(unscope, untopic) {
    var i, items, length, scope, subs, topic;
    if (subs = this.subs) {
      for (topic in subs) {
        items = subs[topic];
        if (!((i = items.length) && (!untopic || untopic === topic))) {
          continue;
        }
        length = i / 2;
        while ((i -= 2) >= 0) {
          if (scope = items[i]) {
            if (unscope && scope !== unscope) {
              continue;
            } else {
              items[i] = null;
            }
            length--;
          }
        }
        if (length === 0) {
          items.length = 0;
        }
      }
    }
    return this;
  };

  return Entity;

})();

new Pool(Entity);

Entity.Prefab = (function() {

  function Prefab(attributes) {
    var key;
    this.attributes = attributes;
    this.keys = Object.keys(attributes);
    for (key in attributes) {
      if (!attributes[key]) {
        attributes[key] = {};
      }
    }
  }

  Prefab.prototype.alloc = function(parent, attributes) {
    var defaults, key, subKey, subPresets, value, _i, _len, _ref;
    defaults = this.attributes;
    if (attributes) {
      _ref = this.keys;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        value = defaults[key];
        if (!attributes[key]) {
          attributes[key] = value;
        } else {
          subPresets = attributes[key];
          if (key === 'children') {
            subPresets.unshift.apply(subPresets, value);
          } else if (typeof value === 'object') {
            for (subKey in value) {
              if (!(subKey in subPresets)) {
                subPresets[subKey] = value[subKey];
              }
            }
          }
          delete attributes[key];
          attributes[key] = subPresets;
        }
      }
    }
    return Entity.alloc(parent, attributes || defaults);
  };

  return Prefab;

})();

module.exports = Entity;

},{"./pool":7}],6:[function(require,module,exports){// Generated by CoffeeScript 1.6.1
var Component;

require('./math');

Component = (function() {

  function Component() {}

  Component.prototype.tag = 'component';

  Component.prototype.toString = function() {
    return "Component " + this.tag + "#" + this.uid + " [^ " + this.entity + "]";
  };

  Component.prototype.alloc = function(attributes) {
    var component, components, entity, tag;
    this.entity = entity = this.parent;
    entity.components[this.tag] = this;
    entity[this.tag] = this;
    components = entity.components;
    for (tag in components) {
      if (!(tag !== this.tag)) {
        continue;
      }
      this[tag] = component = components[tag];
      component[this.tag] = this;
    }
    if (this.instantiate) {
      this.instantiate(attributes);
    }
    return this;
  };

  Component.prototype.destroy = function() {
    this.pool.destroy(this);
    return this;
  };

  Component.prototype.free = function() {
    var components, tag;
    delete this.entity.components[this.tag];
    this.entity[this.tag] = null;
    components = this.entity.components;
    for (tag in components) {
      if (!(tag !== this.tag)) {
        continue;
      }
      this[components[tag].tag] = null;
      components[tag][this.tag] = null;
    }
    this.entity = null;
    this.pool.free(this);
    return this;
  };

  Component.prototype.enable = function(state, silent) {
    this.enabled = (state != null ? state : state = !this.state);
    if (silent) {
      this.entity.pub('onComponent' + (state ? 'Enable' : 'Disable'), this);
    }
    return this;
  };

  Component.prototype.sub = function(scope, topic, method) {
    if (scope == null) {
      scope = this;
    }
    this.entity.sub(scope, topic, method);
    return this;
  };

  return Component;

})();

module.exports = Component;

},{"./math":2}],7:[function(require,module,exports){// Generated by CoffeeScript 1.6.1
var Pool, fn, _i, _len, _ref;

require('./math');

Pool = (function() {

  Pool.typedHooks = ['fixedUpdate', 'simulate', 'update', 'postUpdate', 'preRender', 'render'];

  Pool.regxHook = /^on[A-Z]/;

  Pool.regxGetter = /^get[A-Z]/;

  Pool.hooks = {};

  Pool.byTag = {};

  Pool.defaults = {};

  Pool.order = {
    render: false
  };

  Pool.prototype.toString = function() {
    return "Pool {@tag} [" + this.allocd + " / " + this.register.length + "]";
  };

  function Pool(cls) {
    var fn, key, keys, proto, types, _i, _j, _len, _len1,
      _this = this;
    this.cls = cls;
    proto = cls.prototype;
    proto.pool = this;
    cls.pool = this;
    this.register = [];
    this.subs = [];
    this.hooks = [];
    this.enabled = false;
    this.allocd = 0;
    this.tag = proto.tag;
    if (this.tag) {
      Pool.byTag[this.tag] = this;
    }
    this.isComponent = this.tag && this.tag !== 'entity';
    this.light = (!this.isComponent) || proto.light || false;
    this.layer = proto.layer || cls.layer || 0;
    if (this.isComponent) {
      if (!this.light) {
        types = Pool.typedHooks;
        keys = Object.keys(proto).concat(Object.keys(cls));
        for (_i = 0, _len = keys.length; _i < _len; _i++) {
          fn = keys[_i];
          if (Pool.regxHook.test(fn)) {
            if (!~types.indexOf(fn)) {
              types.push(fn);
              Pool.hooks[fn] = [];
            }
            this.subs.push(fn);
          } else if (Pool.regxGetter.test(fn)) {
            key = fn.substr(3, 1).toLowerCase() + fn.substr(4);
            Pool.defineGetter(proto, key, fn);
          }
        }
        for (_j = 0, _len1 = types.length; _j < _len1; _j++) {
          fn = types[_j];
          if (fn in cls) {
            this[fn] = cls[fn];
            Pool.hooks[fn].push(this);
          } else if (fn in proto) {
            this.hooks.push(fn);
          }
        }
      }
    }
    cls.alloc = function(parent, attributes) {
      return _this.alloc(parent, attributes);
    };
  }

  Pool.prototype.preinstantiate = function(i) {
    while (i--) {
      this.instantiate();
    }
    return this;
  };

  Pool.prototype.instantiate = function() {
    var cls, hook, _i, _len, _ref;
    cls = new this.cls();
    this.register.push(cls);
    _ref = this.hooks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      hook = _ref[_i];
      Pool.hooks[hook].push(cls);
    }
    return cls;
  };

  Pool.prototype.alloc = function(parent, attributes) {
    var defaults, entity, hook, i, key, register, topic, uid, _i, _j, _len, _len1, _ref, _ref1;
    register = this.register;
    i = register.length;
    while (i--) {
      if (!register[i].allocd) {
        entity = register[i];
        break;
      }
    }
    if (!entity) {
      entity = this.instantiate();
    }
    this.allocd++;
    this.enabled = true;
    entity.uid = uid = Math.uid();
    entity.enabled = true;
    entity.allocd = true;
    entity.parent = parent || null;
    entity.root = parent && parent.root || parent || entity;
    if (this.isComponent) {
      _ref = this.hooks;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        hook = _ref[_i];
        if (Pool.order[hook] != null) {
          Pool.order[hook] = true;
        }
      }
      entity.layer = (parent && parent.layer || 0) + this.layer + 2 - 1 / uid;
      if ((defaults = entity.attributes)) {
        if (attributes && !attributes._merged) {
          if (attributes.__proto__) {
            attributes.__proto__ = defaults;
          } else {
            for (key in defaults) {
              if (!key in attributes) {
                attributes[key] = defaults[key];
              }
            }
          }
          attributes._merged = true;
        }
      }
      _ref1 = this.subs;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        topic = _ref1[_j];
        parent.sub(entity, topic);
      }
    }
    entity.alloc(attributes || defaults || null);
    return entity;
  };

  Pool.prototype.destroy = function(entity) {
    entity.enabled = false;
    Pool.hooks.free.push(entity);
    return this;
  };

  Pool.prototype.free = function(entity) {
    entity.allocd = false;
    entity.uid = null;
    entity.root = null;
    entity.parent = null;
    this.enabled = this.allocd-- > 1;
    return this;
  };

  Pool.prototype.invoke = function(fn, a0, a1, a2, a3) {
    var i, stack;
    stack = this.register;
    i = this.register.length;
    while (i--) {
      if (stack[i].enabled) {
        stack[i][fn](a0, a1, a2, a3);
      }
    }
    return this;
  };

  return Pool;

})();

Pool.hooks.free = [];

_ref = Pool.typedHooks;
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
  fn = _ref[_i];
  Pool.hooks[fn] = [];
}

Pool.dump = function(flush) {
  var pool, tag, _ref1;
  _ref1 = Pool.byTag;
  for (tag in _ref1) {
    pool = _ref1[tag];
    console.log("%s: %d/%d allocd", tag, pool.allocd, pool.register.length);
  }
  if (flush) {
    Pool.flush();
  }
  return null;
};

Pool.defineGetter = function(proto, key, fn) {
  Object.defineProperty(proto, key, {
    get: proto[fn],
    enumerable: true,
    configurable: true
  });
  return proto;
};

Pool.free = function() {
  var item, stack, _j, _len1;
  stack = this.hooks.free;
  for (_j = 0, _len1 = stack.length; _j < _len1; _j++) {
    item = stack[_j];
    item.free();
  }
  stack.length = 0;
  return this;
};

Pool.flush = function() {
  var freed, i, pool, register, tag, _ref1;
  _ref1 = Pool.byTag;
  for (tag in _ref1) {
    pool = _ref1[tag];
    register = pool.register;
    i = register.length;
    freed = 0;
    while (i--) {
      if (!(!register[i].allocd)) {
        continue;
      }
      register.splice(i, 1);
      freed++;
    }
    console.log("%s: %d/%d flushed", tag, freed, pool.register.length);
  }
  return this;
};

Pool.invoke = function(fn, a0, a1, a2, a3) {
  var i = 0, stack;
  if ((stack = this.hooks[fn]) && (i = stack.length)) {
    if (Pool.order[fn]) {
      stack.sort(Pool.orderFn);
      Pool.order[fn] = false;
    }
    while (i-- > 0) {
      if (stack[i].enabled) {
        stack[i][fn](a0, a1, a2, a3);
      }
    }
  }
  return this;
};

Pool.orderFn = function(a, b) {
  return b.layer - a.layer;
};

module.exports = Pool;

},{"./math":2}],9:[function(require,module,exports){// Generated by CoffeeScript 1.6.1
var Component, Pool, SpriteAsset, SpriteSheet, SpriteTween, Vec2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Vec2 = require('./math').Vec2;

Component = require('./component');

Pool = require('./pool');

SpriteAsset = (function() {

  function SpriteAsset(srcOrRepaint, size, baseScale) {
    var img,
      _this = this;
    this.baseScale = baseScale != null ? baseScale : 1;
    this.size = Vec2(size);
    this.bufferSize = Vec2(size);
    this.defaultAlign = Vec2.center;
    this.defaultOffset = Vec2();
    this.defaultScale = Vec2(1, 1);
    this.buffer = document.createElement('canvas');
    this.bufferCtx = this.buffer.getContext('2d');
    this.scale = 1;
    switch (typeof srcOrRepaint) {
      case 'string':
        this.src = srcOrRepaint;
        this.img = img = new Image();
        img.onload = function() {
          if (!img.onload) {
            return;
          }
          img.onload = null;
          Vec2.set(_this.size, img.width, img.height);
          return _this.refresh();
        };
        img.src = srcOrRepaint;
        if (img.onload && img.width && img.height) {
          img.onload();
        }
        break;
      case 'function':
        this.repaint = srcOrRepaint;
        this.refresh();
        break;
    }
  }

  SpriteAsset.prototype.toString = function() {
    return "SpriteAsset " + (Vec2.toString(this.size)) + " " + (Vec2.toString(this.bufferSize)) + "x\n" + (this.src || this.repaint) + "\n" + (this.buffer.toDataURL());
  };

  SpriteAsset.prototype.draw = function(ctx, toPos, align, size, fromPos, scale) {
    if (toPos == null) {
      toPos = Vec2.zero;
    }
    if (align == null) {
      align = this.defaultAlign;
    }
    if (size == null) {
      size = this.bufferSize;
    }
    if (fromPos == null) {
      fromPos = this.defaultOffset;
    }
    if (scale == null) {
      scale = this.defaultScale;
    }
    if (this.ready) {
      ctx.drawImage(this.buffer, fromPos[0] | 0, fromPos[1] | 0, size[0], size[1], toPos[0] - size[0] / 2 * (align[0] + 1) | 0, toPos[1] - size[1] / 2 * (align[1] + 1) | 0, size[0] * scale[0], size[1] * scale[1]);
    }
    return this;
  };

  SpriteAsset.prototype.repaint = function() {
    var size;
    size = this.size;
    this.buffer.width = size[0];
    this.buffer.height = size[1];
    this.bufferCtx.drawImage(this.img, 0, 0, size[0], size[1]);
    this.sample();
    return this;
  };

  SpriteAsset.prototype.sample = function() {
    var bufferCtx, data, i, scale, size, x, y, _i, _j, _ref, _ref1;
    scale = this.scale, size = this.size, bufferCtx = this.bufferCtx;
    data = bufferCtx.getImageData(0, 0, size[0], size[1]).data;
    this.buffer.width = this.bufferSize[0];
    this.buffer.height = this.bufferSize[1];
    for (x = _i = 0, _ref = size[0]; _i <= _ref; x = _i += 1) {
      for (y = _j = 0, _ref1 = size[1]; _j <= _ref1; y = _j += 1) {
        i = (y * size[0] + x) * 4;
        bufferCtx.fillStyle = "rgba(" + data[i] + ", " + data[i + 1] + ", " + data[i + 2] + ", " + (data[i + 3] / 255) + ")";
        bufferCtx.fillRect(x * scale, y * scale, scale, scale);
      }
    }
    return this;
  };

  SpriteAsset.prototype.refresh = function(scale) {
    scale = (scale || 1) * this.baseScale;
    if (!this.ready || this.scale !== scale) {
      this.scale = scale;
      this.buffer.width = this.bufferSize[0] = this.size[0] * scale | 0;
      this.buffer.height = this.bufferSize[1] = this.size[1] * scale | 0;
      Vec2.scal(this.bufferSize, -0.5, this.defaultOffset);
      this.repaint(this.bufferCtx, scale);
      this.ready = true;
    }
    return this;
  };

  return SpriteAsset;

})();

SpriteSheet = (function() {

  function SpriteSheet(attributes) {
    var frame, id, sequences, sprites, _base, _base1, _base2, _i, _len, _ref, _ref1, _ref2, _ref3;
    sprites = attributes.sprites || [];
    this.sprites = Array.isArray(sprites) ? sprites : [sprites];
    this.frames = [];
    if (Array.isArray(attributes.frames)) {
      _ref = attributes.frames;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        frame = _ref[_i];
        this.frames.push(frame);
      }
    }
    this.defaults = {};
    if ((_ref1 = (_base = this.defaults).speed) == null) {
      _base.speed = attributes.speed || 0.2;
    }
    if ((_ref2 = (_base1 = this.defaults).size) == null) {
      _base1.size = attributes.size || Vec2(1, 1);
    }
    if ((_ref3 = (_base2 = this.defaults).align) == null) {
      _base2.align = attributes.align || Vec2.center;
    }
    this.sequences = {};
    sequences = attributes.sequences || {};
    for (id in sequences) {
      this.addSequence(id, sequences[id]);
    }
  }

  SpriteSheet.prototype.addSequence = function(id, sequence) {
    var frame, frames, _i, _ref, _ref1;
    if (Array.isArray(sequence)) {
      frames = [];
      for (frame = _i = _ref = sequence[0], _ref1 = sequence[1]; _i <= _ref1; frame = _i += 1) {
        frames.push(frame);
      }
      sequence = {
        frames: frames,
        next: sequence[2] || null,
        speed: sequence[3] || this.defaults.speed,
        name: id,
        sprite: sequence[4] || 0
      };
    }
    if (sequence.next === true) {
      sequence.next = id;
    }
    if (!sequence.speed) {
      sequence.speed = this.defaults.speed;
    }
    this.sequences[id] = sequence;
    if (!this.defaultSequence) {
      this.defaultSequence = id;
    }
    return this;
  };

  SpriteSheet.prototype.prepare = function() {
    var align, cols, rows, size, sprite, sprites, x, y, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2;
    sprites = this.sprites;
    for (_i = 0, _len = sprites.length; _i < _len; _i++) {
      sprite = sprites[_i];
      if (!sprite.ready) {
        return false;
      }
    }
    if (!this.frames.length) {
      _ref = this.defaults, size = _ref.size, align = _ref.align;
      for (_j = 0, _len1 = sprites.length; _j < _len1; _j++) {
        sprite = sprites[_j];
        cols = sprite.size[0] / size[0] | 0;
        rows = sprite.size[1] / size[1] | 0;
        for (y = _k = 0, _ref1 = rows - 1; _k <= _ref1; y = _k += 1) {
          for (x = _l = 0, _ref2 = cols - 1; _l <= _ref2; x = _l += 1) {
            this.frames.push({
              sprite: sprite,
              pos: Vec2(x * size[0], y * size[1]),
              size: size,
              align: align || Vec2.center
            });
          }
        }
      }
    }
    this.ready = true;
    return this;
  };

  SpriteSheet.prototype.draw = function(ctx, frame) {
    if (!this.ready && !this.prepare()) {
      return this;
    }
    frame = this.frames[frame || 0];
    frame.sprite.draw(ctx, null, frame.align, frame.size, frame.pos);
    return this;
  };

  return SpriteSheet;

})();

SpriteTween = (function(_super) {

  __extends(SpriteTween, _super);

  function SpriteTween() {
    return SpriteTween.__super__.constructor.apply(this, arguments);
  }

  SpriteTween.prototype.tag = 'spriteTween';

  SpriteTween.prototype.attributes = {
    asset: null,
    speed: null,
    sequence: null,
    offset: 0,
    composite: null
  };

  SpriteTween.prototype.instantiate = function(attributes) {
    var _ref;
    this.asset = attributes.asset, this.composite = attributes.composite, this.sequence = attributes.sequence, this.speed = attributes.speed;
    this.isSheet = this.asset instanceof SpriteSheet;
    if (this.isSheet) {
      this.frame = 0;
      if ((_ref = this.speed) == null) {
        this.speed = this.asset.defaults.speed;
      }
      this.dtime = attributes.offset;
      if (!this.sequence) {
        this.sequence = this.asset.defaultSequence;
      }
    }
    return this;
  };

  SpriteTween.prototype.preRender = function(dt) {
    var dtime, frame, frameCount, frames, sequence, speed;
    if (this.isSheet && !this.paused) {
      dtime = (this.dtime += dt);
      if (this.sequence) {
        sequence = this.asset.sequences[this.sequence];
        speed = sequence.speed;
        frames = sequence.frames;
        frameCount = frames.length;
        if (dtime >= frameCount * speed) {
          this.entity.pub('onSequenceEnd');
          if (sequence.next) {
            if (sequence.next !== this.sequence) {
              return this.goto(sequence.next);
            }
          } else {
            this.pause();
            return this;
          }
          dtime = dtime % (frameCount * speed);
        }
        this.frame = frames[dtime / speed | 0];
      } else {
        frames = this.asset.frames;
        frameCount = frames.length;
        speed = this.speed;
        dtime = dtime % (frameCount * speed);
        frame = dtime / speed | 0;
        if (frame < this.frame) {
          this.entity.pub('onSequenceEnd');
        }
        this.frame = dtime / speed | 0;
      }
    }
    return this;
  };

  SpriteTween.prototype.render = function(ctx) {
    ctx.save();
    this.transform.applyMatrix(ctx);
    if (this.composite) {
      ctx.globalCompositeOperation = this.composite;
    }
    this.asset.draw(ctx, this.frame);
    ctx.restore();
    return this;
  };

  SpriteTween.prototype.pause = function() {
    this.paused = true;
    return this;
  };

  SpriteTween.prototype.play = function() {
    this.paused = false;
    return this;
  };

  SpriteTween.prototype.goto = function(id) {
    if (isNaN(id)) {
      if (this.sequence !== id) {
        this.dtime = 0;
        this.sequence = id;
        if (this.paused) {
          this.paused = false;
          this.preRender(0);
          this.paused = true;
        }
      }
    } else {
      this.sequence = null;
      this.frameIndex = id;
    }
    return this;
  };

  return SpriteTween;

})(Component);

new Pool(SpriteTween);

module.exports.Asset = SpriteAsset;

module.exports.Tween = SpriteTween;

module.exports.Sheet = SpriteSheet;

},{"./math":2,"./component":6,"./pool":7}],8:[function(require,module,exports){// Generated by CoffeeScript 1.6.1
var Color, typedArray;

require('./math');

typedArray = Math.TypedArray;

Color = function(fromOrR, g, b, a) {
  var _ref;
  if (g != null) {
    return new typedArray([fromOrR, g, b, a != null ? a : 1]);
  }
  if (fromOrR != null) {
    return new typedArray([fromOrR[0], fromOrR[1], fromOrR[2], (_ref = fromOrR[3]) != null ? _ref : 1]);
  }
  return new typedArray(Color.black);
};

Color.white = Color(255, 255, 255);

Color.black = Color(0, 0, 0);

Color.gray = Color(128, 128, 128);

Color.cache = [Color(), Color(), Color(), Color()];

Color.set = function(result, r, g, b, a) {
  result[0] = r || 0;
  result[1] = g || 0;
  result[2] = b || 0;
  result[3] = a || 0;
  return result;
};

Color.copy = function(result, b) {
  result[0] = b[0];
  result[1] = b[1];
  result[2] = b[2];
  result[3] = b[3];
  return result;
};

Color.lerp = function(a, b, t, alpha, result) {
  result || (result = a);
  result[0] = (1 - t) * a[0] + t * b[0];
  result[1] = (1 - t) * a[1] + t * b[1];
  result[2] = (1 - t) * a[2] + t * b[2];
  if (alpha > 0.05) {
    result[3] = (1 - t) * a[3] + t * b[3];
  } else {
    result[3] = a[3];
  }
  return result;
};

Color.lerpList = function(result, list, t) {
  var last, start, sub;
  last = list.length - 1;
  t = Math.clamp(t * last, 0, last);
  start = t | 0;
  sub = t - start;
  if (sub < 0.02) {
    return Color.copy(result, list[start]);
  }
  if (sub > 0.98) {
    return Color.copy(result, list[start + 1]);
  }
  return Color.lerp(list[start], list[start + 1], sub, null, result);
};

Color.variant = function(a, t, result) {
  t = Math.rand(-t, t);
  return Color.lerp(a, (t > 0 ? Color.white : Color.black), t, false, result);
};

Color.rgba = function(a, alpha) {
  alpha || (alpha = a[3]);
  if (alpha > 0.98) {
    return "rgb(" + (a[0] | 0) + ", " + (a[1] | 0) + ", " + (a[2] | 0) + ")";
  } else {
    return "rgba(" + (a[0] | 0) + ", " + (a[1] | 0) + ", " + (a[2] | 0) + ", " + alpha + ")";
  }
};

module.exports = Color;

},{"./math":2}],10:[function(require,module,exports){// Generated by CoffeeScript 1.6.1
var Component, Mat2, Pool, Transform, Vec2, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

_ref = require('./math'), Vec2 = _ref.Vec2, Mat2 = _ref.Mat2;

Transform = (function(_super) {

  __extends(Transform, _super);

  Transform.prototype.tag = 'transform';

  Transform.prototype.attributes = {
    pos: Vec2(),
    angle: 0,
    alpha: 1
  };

  function Transform() {
    this.pos = Vec2();
    this.matrix = Mat2();
  }

  Transform.prototype.instantiate = function(attributes) {
    this.angle = attributes.angle, this.alpha = attributes.alpha;
    Vec2.copy(this.pos, attributes.pos);
    return this;
  };

  Transform.prototype.setTransform = function(pos, angle, silent) {
    if (pos != null) {
      Vec2.copy(this.pos, pos);
    }
    if (angle != null) {
      this.angle = angle;
    }
    this.dirty = true;
    if (!silent) {
      this.entity.pub('onTransform', this.pos, this.angle);
    }
    return this;
  };

  Transform.prototype.applyMatrix = function(ctx) {
    ctx.translate(this.pos[0] | 0, this.pos[1] | 0);
    if (this.angle) {
      ctx.rotate(this.angle);
    }
    return this;
  };

  return Transform;

})(Component);

new Pool(Transform);

module.exports = Transform;

},{"./component":6,"./pool":7,"./math":2}],11:[function(require,module,exports){// Generated by CoffeeScript 1.6.1
var Bounds, BoundsDebug, Color, Component, Pool, Vec2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Color = require('./color');

Vec2 = require('./math').Vec2;

Bounds = (function(_super) {

  __extends(Bounds, _super);

  Bounds.prototype.tag = 'bounds';

  Bounds.prototype.attributes = {
    shape: 'rect',
    radius: 0,
    size: Vec2()
  };

  function Bounds() {
    this.size = Vec2();
  }

  Bounds.prototype.instantiate = function(attributes) {
    Vec2.copy(this.size, attributes.size);
    this.shape = attributes.shape;
    this.radius = attributes.radius;
    return this;
  };

  Bounds.prototype.getTop = function() {
    if (this.shape === 'circle') {
      return this.transform.pos[1] - this.radius;
    }
    return this.transform.pos[1];
  };

  Bounds.prototype.getBottom = function() {
    if (this.shape === 'circle') {
      return this.transform.pos[1] + this.radius;
    }
    return this.transform.pos[1] + this.size[1];
  };

  Bounds.prototype.intersectLine = function(p1, p2) {
    return null;
  };

  Bounds.prototype.intersect = function(bound) {
    return null;
  };

  Bounds.prototype.contains = function(point) {
    var pos;
    pos = this.transform.pos;
    switch (this.shape) {
      case 'circle':
        return Bounds.circPoint(pos, this.radius, point);
      case 'rect':
        return Bounds.rectPoint(pos, this.size, point);
    }
    return false;
  };

  Bounds.prototype.withinRect = function(pos, size) {
    var mypos;
    mypos = this.transform.pos;
    switch (this.shape) {
      case 'circle':
        return Bounds.rectCirc(pos, size, mypos, this.radius);
      case 'rect':
        return Bounds.rectRect(pos, size, mypos, this.size);
    }
    return false;
  };

  return Bounds;

})(Component);

Bounds.circPoint = function(center, radius, point) {
  return Vec2.distSq(point, center) <= radius * radius;
};

Bounds.rectPoint = function(pos, size, point) {
  return pos[0] - size[0] < point[0] && pos[1] < point[1] && pos[0] + size[0] > point[0] && pos[1] + size[1] > point[1];
};

Bounds.rectCirc = function(topLeft, size, center, radius) {
  var circleDistanceX, circleDistanceY, cornerDistance;
  circleDistanceX = Math.abs(center[0] - topLeft[0] - size[0] / 2);
  circleDistanceY = Math.abs(center[1] - topLeft[1] - size[1] / 2);
  if (circleDistanceX > (size[0] / 2 + radius) || circleDistanceY > (size[1] / 2 + radius)) {
    return false;
  }
  if (circleDistanceX <= size[0] / 2 || circleDistanceY <= size[1] / 2) {
    return true;
  }
  cornerDistance = Math.pow(circleDistanceX - size[0] / 2, 2) + Math.pow(circleDistanceY - size[1] / 2, 2);
  return cornerDistance <= Math.pow(radius, 2);
};

Bounds.rectRect = function(pos, size, pos2, size2) {
  return !(pos[0] > pos2[0] + size2[0] || pos[0] + size[0] < pos2[0] || pos[1] > pos2[1] + size2[1] || pos[1] + size[1] < pos2[1]);
};

Bounds.lineRect = function(point1, point2, topLeft, size) {
  var botOverlap, bottomIntersection, bottomPoint, c, m, topIntersection, topOverlap, topPoint, _ref, _ref1;
  this.topLeft = topLeft;
  this.size = size;
  m = (y2 - y1) / (x2 - x1);
  c = y1(-(m * x1));
  if (m > 0) {
    topIntersection = m * rx + c;
    bottomIntersection = m * (rx + rw) + c;
  } else {
    topIntersection = m * (rx + rw) + c;
    bottomIntersection = m * rx + c;
  }
  if (y1 < y2) {
    topPoint = y1;
    bottomPoint = y2;
  } else {
    topPoint = y2;
    bottomPoint = y1;
  }
  topOverlap = (_ref = topIntersection > topPoint) != null ? _ref : {
    topIntersection: topPoint
  };
  botOverlap = (_ref1 = bottomIntersection < bottomPoint) != null ? _ref1 : {
    bottomIntersection: bottomPoint
  };
  return (topOverlap < botOverlap) && (!((botOverlap < ry) || (topOverlap > ry + rh)));
};

Bounds.lineCirc = function(point1, point2, center, radius) {
  var a, b, bb4ac, c, dx, dy, ix1, ix2, iy1, iy2, mu, testX, testY;
  dx = x2 - x1;
  dy = y2 - y1;
  a = dx * dx + dy * dy;
  b = 2 * (dx * (x1 - cx) + dy * (y1 - cy));
  c = cx * cx + cy * cy;
  c += x1 * x1 + y1 * y1;
  c -= 2 * (cx * x1 + cy * y1);
  c -= cr * cr;
  bb4ac = b * b - 4 * a * c;
  if (bb4ac < 0) {
    return false;
  }
  mu = (-b + sqrt(b * b - 4 * a * c)) / (2 * a);
  ix1 = x1 + mu * dx;
  iy1 = y1 + mu * dy;
  mu = (-b - sqrt(b * b - 4 * a * c)) / (2 * a);
  ix2 = x1 + mu * dx;
  iy2 = y1 + mu * dy;
  if (dist(x1, y1, cx, cy) < dist(x2, y2, cx, cy)) {
    testX = x2;
    testY = y2;
  } else {
    testX = x1;
    testY = y1;
  }
  if (dist(testX, testY, ix1, iy1) < dist(x1, y1, x2, y2) || dist(testX, testY, ix2, iy2) < dist(x1, y1, x2, y2)) {
    return true;
  }
  return false;
};

new Pool(Bounds);

BoundsDebug = (function(_super) {

  __extends(BoundsDebug, _super);

  BoundsDebug.prototype.tag = 'boundsDebug';

  BoundsDebug.prototype.attributes = {
    color: Color.gray,
    opacity: 0.5,
    fill: false
  };

  function BoundsDebug() {
    this.color = Vec2();
  }

  BoundsDebug.prototype.instantiate = function(attributes) {
    this.opacity = attributes.opacity, this.fill = attributes.fill;
    Vec2.copy(this.color, attributes.color);
    return this;
  };

  BoundsDebug.prototype.render = function(ctx) {
    var bounds, size;
    bounds = this.bounds;
    ctx.save();
    if (this.fill) {
      ctx.fillStyle = Color.rgba(this.color, this.opacity * 0.5);
    }
    ctx.strokeStyle = Color.rgba(this.color, this.opacity);
    ctx.lineWidth = 1;
    this.transform.applyMatrix(ctx);
    if (bounds.shape === 'circle') {
      ctx.beginPath();
      ctx.lineTo(0, bounds.radius);
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, bounds.radius | 0, 0, Math.TAU);
      if (this.fill) {
        ctx.fill();
      }
      ctx.stroke();
    } else {
      size = bounds.size;
      ctx.strokeRect(-size[0] / 2 | 0, -size[1] / 2 | 0, size[0] | 0, size[1] | 0);
      if (this.fill) {
        ctx.fillRect(-size[0] / 2 | 0, -size[1] / 2 | 0, size[0] | 0, size[1] | 0);
      }
    }
    ctx.restore();
    return this;
  };

  return BoundsDebug;

})(Component);

new Pool(BoundsDebug);

Bounds.Debug = BoundsDebug;

module.exports = Bounds;

},{"./component":6,"./pool":7,"./color":8,"./math":2}],12:[function(require,module,exports){// Generated by CoffeeScript 1.6.1
var Border, Component, Engine, Pool, Vec2, pos,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

Engine = require('./engine');

Border = (function(_super) {

  __extends(Border, _super);

  function Border() {
    return Border.__super__.constructor.apply(this, arguments);
  }

  Border.prototype.tag = 'border';

  Border.prototype.attributes = {
    mode: 'bounce',
    restitution: 1
  };

  Border.prototype.instantiate = function(attributes) {
    this.mode = attributes.mode, this.restitution = attributes.restitution;
    return this;
  };

  return Border;

})(Component);

pos = Vec2();

Border.simulate = function(dt) {
  var border, bounce, diff, entity, hit, horizontal, kinetic, mirror, mode, radius, restitution, size, vel, vertical, viewport, _i, _len, _ref;
  size = Engine.renderer.content;
  viewport = Engine.renderer.pos;
  horizontal = Vec2.set(Vec2.cache[0], viewport[0], viewport[0] + size[0]);
  vertical = Vec2.set(Vec2.cache[1], viewport[1], viewport[1] + size[1]);
  _ref = this.register;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    border = _ref[_i];
    if (!border.enabled) {
      continue;
    }
    entity = border.entity, restitution = border.restitution, mode = border.mode, kinetic = border.kinetic;
    vel = null;
    if (kinetic) {
      if (!kinetic.enabled || kinetic.sleeping) {
        continue;
      }
      vel = kinetic.velocity;
    }
    mirror = mode === 'mirror';
    bounce = mode === 'bounce' && vel;
    Vec2.copy(pos, entity.transform.pos);
    radius = entity.bounds.radius;
    if (mirror) {
      radius *= -1;
    }
    hit = 0;
    if ((diff = pos[0] - radius - horizontal[0]) < 0) {
      if (mirror) {
        pos[0] = horizontal[1] - radius;
      } else {
        pos[0] -= diff;
        if (bounce) {
          vel[0] *= -restitution;
        }
      }
      hit = -1;
    } else {
      diff = pos[0] + radius - horizontal[1];
      if (diff > 0) {
        if (mirror) {
          pos[0] = radius;
        } else {
          pos[0] -= diff;
          if (bounce) {
            vel[0] *= -restitution;
          }
        }
        hit = -1;
      }
    }
    if ((diff = pos[1] - radius - vertical[0]) < 0) {
      if (mirror) {
        pos[1] = vertical[1] - radius;
      } else {
        pos[1] -= diff;
        if (bounce) {
          vel[1] *= -restitution;
        }
      }
      hit = 1;
    } else {
      diff = pos[1] + radius - vertical[1];
      if (diff > 0) {
        if (mirror) {
          pos[1] = radius;
        } else {
          pos[1] -= diff;
          if (bounce) {
            vel[1] *= -restitution;
          }
        }
        hit = 1;
      }
    }
    if (hit) {
      entity.transform.setTransform(pos);
      entity.pub('onBorder', hit);
      if (border.mode === 'kill') {
        entity.destroy();
      }
    }
  }
  return this;
};

new Pool(Border);

module.exports = Border;

},{"./component":6,"./pool":7,"./math":2,"./engine":3}],13:[function(require,module,exports){// Generated by CoffeeScript 1.6.1
var Color, Component, Engine, Entity, Kinetic, Particle, Pool, Sprite, Transform, Vec2, crop, cropOffset, offset,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Entity = require('./entity');

Component = require('./component');

Pool = require('./pool');

Engine = require('./engine');

Vec2 = require('./math').Vec2;

Color = require('./color');

Transform = require('./transform');

Kinetic = require('./kinetic');

Sprite = require('./sprite').Asset;

Particle = (function(_super) {

  __extends(Particle, _super);

  Particle.prototype.tag = 'particle';

  Particle.layer = 10;

  Particle.prototype.attributes = {
    color: Color.black,
    colorVariant: 0,
    lifetime: 1,
    radius: 1,
    radiusVariant: 0,
    alpha: 1,
    alphaVariant: 0,
    composite: null,
    sprite: null,
    shrink: Math.quintIn,
    fade: Math.quintIn
  };

  function Particle() {
    this.color = Color();
  }

  Particle.prototype.instantiate = function(attributes) {
    var variant;
    this.lifetime = attributes.lifetime, this.radius = attributes.radius, this.alpha = attributes.alpha, this.composite = attributes.composite, this.sprite = attributes.sprite, this.shrink = attributes.shrink, this.fade = attributes.fade;
    Color.copy(this.color, attributes.color);
    if ((variant = attributes.colorVariant)) {
      Color.variant(this.color, variant);
    }
    if ((variant = attributes.radiusVariant)) {
      this.radius += Math.rand(-variant, variant);
    }
    if ((variant = attributes.alphaVariant)) {
      this.alpha = Math.clamp(this.alpha + Math.rand(-variant, variant), 0, 1);
    }
    this.age = 0;
    return this;
  };

  Particle.prototype.update = function(dt) {
    if ((this.age += dt) > this.lifetime) {
      this.entity.destroy();
    } else if (this.shrink && (this.radius *= 1 - this.shrink(this.age / this.lifetime)) < 1) {
      this.entity.destroy();
    } else if (this.fade && (this.alpha *= 1 - this.fade(this.age / this.lifetime)) <= 0.02) {
      this.entity.destroy();
    }
    return this;
  };

  return Particle;

})(Component);

Particle.defaultEntity = null;

crop = Vec2();

cropOffset = Vec2();

offset = Vec2();

Particle.render = function(ctx) {
  var alpha, alphaPrev, composite, compositePrev, defaultComposite, entityPrev, fill, fillPrev, particle, pos, radius, _i, _len, _ref;
  ctx.save();
  Vec2.set(crop, 50, 50);
  Vec2.set(cropOffset, -25, -25);
  alphaPrev = 1;
  entityPrev = null;
  fillPrev = null;
  defaultComposite = Particle.defaultComposite;
  _ref = this.register;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    particle = _ref[_i];
    if (!particle.enabled) {
      continue;
    }
    radius = particle.radius;
    pos = particle.transform.pos;
    alpha = particle.alpha;
    composite = particle.composite || defaultComposite;
    if (composite !== compositePrev) {
      ctx.globalCompositeOperation = compositePrev = composite;
    }
    if (particle.sprite) {
      Vec2.set(offset, 0, 50 * (radius - 1 | 0));
      if (alpha !== alphaPrev) {
        ctx.globalAlpha = alphaPrev = alpha;
      }
      particle.sprite.draw(ctx, pos, Vec2.center, crop, offset);
    } else {
      particle.color[3] = alpha;
      fill = Color.rgba(particle.color);
      if (fill !== fillPrev) {
        ctx.fillStyle = fillPrev = fill;
      }
      ctx.fillRect(pos[0] - radius / 2 | 0, pos[1] - radius / 2 | 0, radius | 0, radius | 0);
    }
  }
  ctx.restore();
  return this;
};

Particle.generateSprite = function(color, alpha, max) {
  var size;
  if (color == null) {
    color = Color.white;
  }
  if (alpha == null) {
    alpha = 1;
  }
  if (max == null) {
    max = 25;
  }
  color = Color(color);
  size = max * 2;
  return new Sprite(function(ctx) {
    var grad, radius, top, _i;
    for (radius = _i = 1; _i <= max; radius = _i += 1) {
      top = max + size * (radius - 1);
      grad = ctx.createRadialGradient(max, top, 0, max, top, radius);
      color[3] = alpha;
      grad.addColorStop(0, Color.rgba(color));
      color[3] = 0;
      grad.addColorStop(1, Color.rgba(color));
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(max, top, radius, 0, Math.TAU, true);
      ctx.closePath();
      ctx.fill();
    }
    return this;
  }, Vec2(size, size * max));
};

Particle.sprite = Particle.generateSprite();

Particle.Prefab = new Entity.Prefab({
  transform: null,
  kinetic: {
    mass: 0
  },
  particle: null
});

new Pool(Particle);

module.exports = Particle;

},{"./entity":5,"./component":6,"./pool":7,"./engine":3,"./math":2,"./color":8,"./transform":10,"./kinetic":15,"./sprite":9}],14:[function(require,module,exports){// Generated by CoffeeScript 1.6.1
var Collider, Component, Engine, Pool, Vec2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

Engine = require('./engine');

Collider = (function(_super) {

  __extends(Collider, _super);

  function Collider() {
    return Collider.__super__.constructor.apply(this, arguments);
  }

  Collider.prototype.tag = 'collider';

  Collider.prototype.attributes = {
    trigger: false,
    include: null,
    exclude: null
  };

  Collider.prototype.instantiate = function(attributes) {
    this.trigger = attributes.trigger, this.include = attributes.include, this.exclude = attributes.exclude;
    return this;
  };

  return Collider;

})(Component);

Collider.simulate = function(dt) {
  var collider1, collider2, colliders, diff, diffSq, entity1, entity2, i, j, kinetic1, kinetic2, mass1, mass2, n, p, pos1, pos2, radius1, radius2, radiusSum, vel1, vel2, vn1, vn2, vp1, vp1After, vp2, vp2After;
  colliders = this.register;
  i = colliders.length;
  while (i--) {
    collider1 = colliders[i];
    if (!collider1.enabled) {
      continue;
    }
    j = i;
    while (j-- && collider1.enabled) {
      collider2 = colliders[j];
      kinetic1 = collider1.kinetic;
      kinetic2 = collider2.kinetic;
      entity1 = collider1.entity;
      entity2 = collider2.entity;
      if (!collider2.enabled || (kinetic1.sleeping && kinetic2.sleeping) || (collider1.include && !collider2[collider1.include]) || (collider2.include && !collider1[collider2.include]) || (collider1.exclude && collider2[collider1.exclude]) || (collider2.exclude && collider1[collider2.exclude])) {
        continue;
      }
      radius1 = entity1.bounds.radius;
      radius2 = entity2.bounds.radius;
      pos1 = entity1.transform.pos;
      pos2 = entity2.transform.pos;
      radiusSum = radius1 + radius2;
      diffSq = Vec2.distSq(pos1, pos2);
      if (diffSq > radiusSum * radiusSum) {
        continue;
      }
      p = Vec2.norm(Vec2.sub(pos1, pos2, Vec2.cache[0]));
      diff = Math.sqrt(diffSq);
      if (collider1.trigger || collider2.trigger) {
        entity1.pub('onTrigger', entity2, p, diff);
        entity2.pub('onTrigger', entity1, p, diff);
        continue;
      }
      diff -= radiusSum;
      vel1 = kinetic1.velocity;
      vel2 = kinetic2.velocity;
      mass1 = kinetic1.mass || 1;
      mass2 = kinetic2.mass || 1;
      if (diff < 0) {
        Vec2.add(pos1, Vec2.scal(p, -diff * 2 * radius1 / radiusSum, Vec2.cache[1]));
        Vec2.add(pos2, Vec2.scal(p, diff * 2 * radius2 / radiusSum, Vec2.cache[1]));
      }
      n = Vec2.perp(p, Vec2.cache[1]);
      vp1 = Vec2.dot(vel1, p);
      vn1 = Vec2.dot(vel1, n);
      vp2 = Vec2.dot(vel2, p);
      vn2 = Vec2.dot(vel2, n);
      vp1After = (mass1 * vp1 + mass2 * (2 * vp2 - vp1)) / (mass1 + mass2);
      vp2After = (mass1 * (2 * vp1 - vp2) + mass2 * vp2) / (mass1 + mass2);
      Vec2.add(Vec2.scal(p, vp1After, Vec2.cache[2]), Vec2.scal(n, vn1, Vec2.cache[3]), vel1);
      Vec2.add(Vec2.scal(p, vp2After, Vec2.cache[2]), Vec2.scal(n, vn2, Vec2.cache[3]), vel2);
      entity1.pub('onCollide', entity2, n);
      entity2.pub('onCollide', entity1, n);
    }
  }
  return this;
};

new Pool(Collider);

module.exports = Collider;

},{"./component":6,"./pool":7,"./math":2,"./engine":3}],15:[function(require,module,exports){// Generated by CoffeeScript 1.6.1
var Component, Kinetic, Pool, Vec2, cache, copyVel,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

cache = Vec2();

copyVel = Vec2();

Kinetic = (function(_super) {

  __extends(Kinetic, _super);

  Kinetic.prototype.tag = 'kinetic';

  Kinetic.gravity = null;

  Kinetic.prototype.attributes = {
    mass: 1,
    drag: 0.999,
    friction: 15,
    fixed: false,
    maxVelocity: 75,
    maxForce: 2000,
    force: Vec2(),
    continuous: Vec2(),
    velocity: Vec2(),
    sleepVelocity: 0,
    fast: false
  };

  function Kinetic() {
    this.velocity = Vec2();
    this.force = Vec2();
    this.continuous = Vec2();
  }

  Kinetic.prototype.instantiate = function(attributes) {
    this.mass = attributes.mass, this.drag = attributes.drag, this.friction = attributes.friction, this.fixed = attributes.fixed, this.maxVelocity = attributes.maxVelocity, this.maxForce = attributes.maxForce, this.fast = attributes.fast, this.sleepVelocity = attributes.sleepVelocity;
    Vec2.copy(this.velocity, attributes.velocity);
    Vec2.copy(this.force, attributes.force);
    Vec2.copy(this.continuous, attributes.continuous);
    this.sleeping = false;
    return this;
  };

  Kinetic.prototype.applyImpulse = function(impulse) {
    Vec2.add(this.force, this.mass !== 1 ? Vec2.scal(impulse, 1 / (this.mass || 1), cache) : impulse);
    return this;
  };

  Kinetic.prototype.applyForce = function(force) {
    Vec2.add(this.continuous, force);
    return this;
  };

  return Kinetic;

})(Component);

Kinetic.simulate = function(dt) {
  var epsilon, force, gravity, kinetic, sleepVelocity, velocity, _i, _len, _ref;
  epsilon = Math.epsilon;
  _ref = this.register;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    kinetic = _ref[_i];
    if (!(kinetic.enabled && !kinetic.fixed)) {
      continue;
    }
    velocity = kinetic.velocity;
    force = Vec2.add(kinetic.force, kinetic.continuous);
    if (kinetic.fast) {
      if (kinetic.maxForce) {
        Vec2.limit(force, kinetic.maxForce);
      }
      Vec2.add(velocity, Vec2.scal(force, dt));
      Vec2.set(force);
      if (kinetic.maxVelocity) {
        Vec2.limit(velocity, kinetic.maxVelocity);
      }
      Vec2.add(kinetic.transform.pos, Vec2.scal(velocity, dt, cache));
      continue;
    }
    if ((gravity = kinetic.root.gravity) && kinetic.mass > epsilon) {
      Vec2.add(force, kinetic.mass !== 1 ? Vec2.scal(gravity, 1 / kinetic.mass, cache) : gravity);
    }
    if (kinetic.friction) {
      Vec2.add(force, Vec2.scal(Vec2.norm(velocity, cache), -kinetic.friction));
    }
    if (kinetic.maxForce) {
      Vec2.limit(force, kinetic.maxForce);
    }
    Vec2.copy(copyVel, velocity);
    Vec2.add(velocity, Vec2.scal(force, dt));
    if (kinetic.maxVelocity) {
      Vec2.limit(velocity, kinetic.maxVelocity);
    }
    Vec2.scal(Vec2.add(copyVel, velocity), dt / 2);
    Vec2.add(kinetic.transform.pos, copyVel);
    Vec2.add(velocity, force);
    if (kinetic.drag < 1) {
      Vec2.scal(velocity, kinetic.drag);
    }
    if ((sleepVelocity = kinetic.sleepVelocity)) {
      if (Vec2.lenSq(velocity) <= sleepVelocity * sleepVelocity) {
        if (!kinetic.sleeping) {
          Vec2.set(velocity);
          kinetic.sleeping = true;
          kinetic.entity.pubUp('onKineticSleep', kinetic);
        }
      } else {
        if (kinetic.sleeping) {
          kinetic.sleeping = false;
          kinetic.entity.pubUp('onKineticWake', kinetic);
        }
      }
    }
    Vec2.set(force);
  }
  return this;
};

new Pool(Kinetic);

module.exports = Kinetic;

},{"./component":6,"./pool":7,"./math":2}],16:[function(require,module,exports){// Generated by CoffeeScript 1.6.1
var Component, Console, Engine, Pool, Vec2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

Engine = require('./engine');

Console = (function(_super) {

  __extends(Console, _super);

  Console.prototype.tag = 'console';

  function Console() {
    this.colors = ['#ddd', '#fff', '#ffc', '#fcc'];
    this.sections = ['#f9f684', '#f9ad84', '#b778e2', '#78dbe2'];
  }

  Console.prototype.attributes = {
    css: '',
    container: null,
    width: 100,
    height: 56,
    cap: 50,
    resolution: 0.25
  };

  Console.prototype.instantiate = function(attributes) {
    var bar, barCss, color, i, panel, panelCss, ruler, rulerCss, section, sectionCss, spanCss, wrap, _i, _len, _ref;
    this.css = attributes.css, this.container = attributes.container, this.width = attributes.width, this.height = attributes.height, this.cap = attributes.cap, this.resolution = attributes.resolution;
    this.wrap = wrap = document.createElement('div');
    wrap.id = 'console';
    wrap.style.cssText = ("			position: absolute;			left: 0;			top: 0;			user-select: none;			overflow: hidden;			padding: 0;			width: " + this.width + "px;			color: #ccc;			background-color: rgba(0, 0, 0, 0.75);			outline: 1px solid rgba(128, 128, 128, 0.5);			font: 400 9px/20px Helvetica,Arial,sans-serif;			transform: translateZ(0);			text-align: right;			text-shadow: 1px 1px 0 rgba(0, 0, 0, 1), 0 0 1px rgba(0, 0, 0, 1);			cursor: ns-resize;") + this.css;
    this.graphSpan = document.createElement('div');
    this.graphSpan.style.cssText = "			height: " + this.height + "px;			z-index: 1;";
    this.graphSpan.title = 'Fixed Update + Update + Render + Lag';
    barCss = "			width: 1px;			float: left;			margin-top: 0px;";
    sectionCss = "			display: block;			height: 0px;";
    i = this.width;
    while (i--) {
      bar = document.createElement('span');
      bar.className = 'console-bar';
      bar.style.cssText = barCss;
      _ref = this.sections;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        color = _ref[_i];
        section = document.createElement('span');
        section.className = 'console-section';
        section.style.cssText = sectionCss + ("background-color: " + color);
        bar.appendChild(section);
      }
      this.graphSpan.appendChild(bar);
    }
    spanCss = "			font-weight: bold;			font-size: 12px;			float: left;";
    this.fpsSpan = document.createElement('span');
    this.fpsSpan.style.cssText = spanCss;
    this.fpsSpan.title = 'FPS';
    this.fpsSpan2 = document.createElement('span');
    this.tickSpan = document.createElement('span');
    this.tickSpan.style.cssText = spanCss;
    this.tickSpan.title = 'MS per tick';
    this.tickSpan2 = document.createElement('span');
    this.fpsSpan2.title = this.tickSpan2.title = ' standard deviation';
    panelCss = "			width: 50%;			padding: 0 5px;			overflow: hidden;			position: absolute;			top: 0;			left: 0;			-moz-box-sizing: border-box;			-webkit-box-sizing: border-box;			z-index: 2;";
    panel = document.createElement('span');
    panel.style.cssText = panelCss;
    panel.appendChild(this.fpsSpan);
    panel.appendChild(this.fpsSpan2);
    wrap.appendChild(panel);
    panel = document.createElement('span');
    panel.style.cssText = panelCss + "left: 50%;";
    panel.appendChild(this.tickSpan);
    panel.appendChild(this.tickSpan2);
    wrap.appendChild(panel);
    rulerCss = "			position: absolute;			left: 0;			width: 100%;			height: 1px;			background-color: rgba(128, 128, 128, 0.5);";
    ruler = document.createElement('span');
    ruler.style.cssText = rulerCss + ("bottom: " + (this.height * 0.66) + "px;");
    wrap.appendChild(ruler);
    ruler = document.createElement('span');
    ruler.style.cssText = rulerCss + ("bottom: " + (this.height * 0.33) + "px;");
    wrap.appendChild(ruler);
    wrap.appendChild(this.graphSpan);
    (this.container || document.body).appendChild(wrap);
    this.nullify();
    wrap.addEventListener('click', this);
    this.toggle();
    return this;
  };

  Console.prototype.handleEvent = function(evt) {
    this.toggle();
    return false;
  };

  Console.prototype.toggle = function() {
    var margin, opacity;
    margin = 0;
    opacity = 0.8;
    if ((this.minimized = !this.minimized)) {
      opacity = 0.5;
      margin = -this.height + 20;
    }
    this.graphSpan.style.marginTop = "" + margin + "px";
    this.graphSpan.style.opacity = opacity;
    return this;
  };

  Console.prototype.free = function() {
    (this.container || document.body).removeChild(this.wrap);
    wrap.removEventListener('click', this);
    this.wrap = null;
    this.container = null;
    return Console.__super__.free.call(this);
  };

  Console.prototype.onTimeEnd = function(samples) {
    var bar, color, colors, dt, fps, fpsMean, fpsSD, lag, mag, overall, tick, tickMean, tickSD;
    this.dtSum += (dt = samples.dt);
    if (!dt) {
      return;
    }
    this.fpsSum += (fps = 1 / dt);
    this.fpsSq += fps * fps;
    this.lagSum += (lag = samples.lag);
    this.lagSq += lag * lag;
    this.tickSum += (tick = samples.tick);
    this.tickSq += tick * tick;
    this.updateSum += samples.update;
    this.fixedUpdateSum += samples.fixedUpdate;
    this.renderSum += samples.render;
    this.frames++;
    if (this.dtSum < this.resolution) {
      return;
    }
    colors = this.colors;
    tickMean = this.tickSum / this.frames;
    tickSD = Math.sqrt((this.tickSq - (this.tickSum * this.tickSum / this.frames)) / (this.frames - 1));
    if (tickMean > 33) {
      color = colors[3];
    } else if (tickMean > 16) {
      color = colors[2];
    } else if (tickMean > 5) {
      color = colors[1];
    } else {
      color = colors[0];
    }
    this.tickSpan.textContent = tickMean < 10 ? Math.round(tickMean * 10) / 10 : Math.round(tickMean);
    this.tickSpan.style.color = color;
    this.tickSpan2.textContent = tickSD < 10 ? Math.round(tickSD * 10) / 10 : Math.round(tickSD);
    bar = this.graphSpan.appendChild(this.graphSpan.firstChild);
    overall = 0;
    mag = Math.round(this.height * this.lagSum / this.frames / this.cap);
    bar.children[0].style.height = "" + mag + "px";
    overall += mag;
    mag = this.height * this.renderSum / this.frames / this.cap;
    bar.children[1].style.height = "" + mag + "px";
    overall += mag;
    mag = Math.round(this.height * this.updateSum / this.frames / this.cap);
    bar.children[2].style.height = "" + mag + "px";
    overall += mag;
    mag = Math.round(this.height * this.fixedUpdateSum / this.frames / this.cap);
    bar.children[3].style.height = "" + mag + "px";
    overall += mag;
    bar.style.marginTop = "" + (this.height - overall) + "px";
    fpsMean = this.fpsSum / this.frames;
    fpsSD = Math.sqrt((this.fpsSq - (this.fpsSum * this.fpsSum / this.frames)) / (this.frames - 1));
    if (fpsMean < 30) {
      color = colors[3];
    } else if (fpsMean < 40) {
      color = colors[2];
    } else if (fpsMean < 55) {
      color = colors[1];
    } else {
      color = colors[0];
    }
    this.fpsSpan.textContent = Math.round(fpsMean || 0);
    this.fpsSpan.style.color = color;
    this.fpsSpan2.textContent = Math.round(fpsSD || 0);
    this.nullify();
    return this;
  };

  Console.prototype.nullify = function() {
    this.dtSum = 0;
    this.fpsSum = this.fpsSq = 0;
    this.tickSum = this.tickSq = 0;
    this.lagSum = this.lagSq = 0;
    this.fixedUpdateSum = 0;
    this.updateSum = 0;
    this.renderSum = 0;
    this.frames = 0;
    return this;
  };

  return Console;

})(Component);

new Pool(Console);

module.exports = Console;

},{"./component":6,"./pool":7,"./math":2,"./engine":3}],17:[function(require,module,exports){// Generated by CoffeeScript 1.6.1
var Component, Engine, Input, Pool, Vec2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

Engine = require('./engine');

Input = (function(_super) {

  __extends(Input, _super);

  Input.prototype.tag = 'input';

  Input.prototype.support = {
    touch: 'ontouchstart' in window,
    orientation: 'ondeviceorientation' in window
  };

  function Input() {
    var code, key, type, _ref;
    this.queue = [];
    this.locks = {};
    this.pos = Vec2();
    this.prevPos = Vec2();
    this.touchState = null;
    this.axis = Vec2();
    this.mouseAxis = Vec2();
    this.orientation = Vec2();
    this.prevOrientation = Vec2();
    this.baseOrientation = Vec2();
    this.map = {
      32: 'space',
      192: 'debug',
      38: 'up',
      87: 'up',
      39: 'right',
      68: 'right',
      40: 'bottom',
      83: 'bottom',
      37: 'left',
      65: 'left',
      219: 'squareLeft',
      221: 'squareRight'
    };
    this.axisMap = {
      left: Vec2(0, -1),
      right: Vec2(0, 1),
      up: Vec2(1, -1),
      bottom: Vec2(1, 1)
    };
    this.keyNames = [];
    this.keys = {};
    _ref = this.map;
    for (code in _ref) {
      key = _ref[code];
      if (!~this.keyNames.indexOf(key)) {
        this.keyNames.push(key);
        this.keys[key] = null;
      }
    }
    this.throttled = {
      mousemove: true,
      deviceorientation: true
    };
    this.lastEvent = null;
    this.events = this.support.touch ? {
      touchstart: 'startTouch',
      touchmove: 'moveTouch',
      touchend: 'endTouch',
      touchcancel: 'endTouch'
    } : {
      mousedown: 'startTouch',
      mousemove: 'moveTouch',
      mouseup: 'endTouch',
      keydown: 'keyStart',
      keyup: 'keyEnd'
    };
    this.events.blur = 'blur';
    for (type in this.events) {
      window.addEventListener(type, this, false);
    }
  }

  Input.prototype.handleEvent = function(event) {
    var type;
    if (event.metaKey) {
      return;
    }
    event.preventDefault();
    type = event.type;
    if (this.throttled[type] && this.lastEvent === type) {
      this.queue[this.queue.length - 1] = event;
    } else {
      this.lastEvent = type;
      this.queue.push(event);
    }
    return this;
  };

  Input.prototype.keyStart = function(event) {
    var key;
    if ((key = this.map[event.keyCode]) && !this.keys[key]) {
      if (!this.lock('key-' + key)) {
        return false;
      }
      this.keys[key] = 'began';
      this.updateAxis(key);
      Engine.pub('onKeyBegan', key);
    }
    return this;
  };

  Input.prototype.keyEnd = function(event) {
    var key;
    if (key = this.map[event.keyCode]) {
      if (!this.lock('key-' + key)) {
        return false;
      }
      this.keys[key] = 'ended';
      this.updateAxis(key, true);
      Engine.pub('onKeyEnded', key);
    }
    return this;
  };

  Input.prototype.startTouch = function(event) {
    if (!this.lock('touch')) {
      return false;
    }
    this.resolve(event);
    if (!this.touchState && !event.metaKey) {
      this.touchState = 'began';
      Engine.pub('onTouchBegan');
    }
    return this;
  };

  Input.prototype.moveTouch = function(event) {
    var state;
    state = this.touchState;
    if ((state === 'began' || state === 'ended') && !this.lock('touch')) {
      return false;
    }
    this.resolve(event);
    if (state && state !== 'ended' && state !== 'moved') {
      this.touchState = 'moved';
    }
    return this;
  };

  Input.prototype.endTouch = function(event) {
    if (!this.lock('touch')) {
      return false;
    }
    this.resolve(event);
    if (this.touchState && (!this.support.touch || !event.targetTouches.length)) {
      Engine.pub('onTouchEnded');
      this.touchState = 'ended';
    }
    return this;
  };

  Input.prototype.updateAxis = function(key, ended) {
    var axis;
    if ((axis = this.axisMap[key])) {
      if (ended) {
        this.axis[axis[0]] -= axis[1];
      } else {
        this.axis[axis[0]] += axis[1];
      }
    }
    return this;
  };

  Input.prototype.blur = function() {
    var key, keys, _i, _len, _ref;
    if (this.touchState && this.touchState !== 'ended') {
      this.touchState = 'ended';
    }
    keys = this.keys;
    _ref = this.keyNames;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      if (keys[key] && keys[key] !== 'ended') {
        keys[key] = 'ended';
        this.updateAxis(key, true);
      }
    }
    return this;
  };

  Input.prototype.calibrateOrientation = function() {
    this.baseOrientationTime = this.orientationTime;
    Vec2.copy(this.baseOrientation, this.orientation);
    Vec2.set(this.orientation);
    return this;
  };

  Input.prototype.deviceOrientation = function(event) {
    Vec2.copy(this.prevOrientation, this.orientation);
    Vec2.sub(Vec2.set(this.orientation, event.gamma | 0, event.beta | 0), this.baseOrientation);
    this.orientationTime = event.timeStamp / 1000;
    if (!this.baseOrientationTime) {
      this.calibrateOrientation();
    }
    return this;
  };

  Input.prototype.resolve = function(event) {
    var coords, renderer;
    coords = this.support.touch ? event.targetTouches[0] : event;
    if (coords) {
      this.prevTime = this.time;
      this.time = event.timeStamp / 1000;
      Vec2.copy(this.prevPos, this.pos);
      renderer = Engine.renderer;
      Vec2.set(this.pos, (coords.pageX - renderer.margin[0]) / renderer.scale | 0, (coords.pageY - renderer.margin[1]) / renderer.scale | 0);
    }
    return this;
  };

  Input.prototype.lock = function(key) {
    if (this.locks[key] === this.frame) {
      return false;
    }
    this.locks[key] = this.frame;
    return true;
  };

  Input.prototype.postUpdate = function() {
    var event, key, keys, queue, type, _i, _len, _ref;
    switch (this.touchState) {
      case 'began':
        this.touchState = 'stationary';
        break;
      case 'ended':
        this.touchState = null;
        break;
    }
    keys = this.keys;
    _ref = this.keyNames;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      switch (keys[key]) {
        case 'began':
          keys[key] = 'pressed';
          break;
        case 'ended':
          keys[key] = null;
          break;
      }
    }
    this.frame = Engine.frame;
    queue = this.queue;
    while ((event = queue[0])) {
      type = event.type;
      if (!this[this.events[type] || type](event)) {
        break;
      }
      queue.shift();
    }
    if (!queue.length) {
      this.lastEvent = null;
    }
    return this;
  };

  return Input;

})(Component);

new Pool(Input);

module.exports = Input;

},{"./component":6,"./pool":7,"./math":2,"./engine":3}]},{},[1]);