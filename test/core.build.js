(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process','global'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/lib/core/collider.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.5.0\nvar Collider, Component, Engine, Pool, Vec2,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComponent = require('./component');\n\nPool = require('./pool');\n\nVec2 = require('./math').Vec2;\n\nEngine = require('./engine');\n\nCollider = (function(_super) {\n\n  __extends(Collider, _super);\n\n  function Collider() {\n    Collider.__super__.constructor.apply(this, arguments);\n  }\n\n  Collider.prototype.type = 'collider';\n\n  Collider.prototype.presets = {\n    trigger: false\n  };\n\n  Collider.prototype.reset = function(presets) {\n    this.trigger = presets.trigger;\n    return this;\n  };\n\n  return Collider;\n\n})(Component);\n\nCollider.simulate = function(dt) {\n  var collider1, collider2, colliders, diff, diffSq, i, j, kinetic1, kinetic2, mass1, mass2, n, p, parent1, parent2, pos1, pos2, radius1, radius2, radiusSum, vel1, vel2, vn1, vn2, vp1, vp1After, vp2, vp2After;\n  colliders = this.roster;\n  i = colliders.length;\n  while (i--) {\n    collider1 = colliders[i];\n    if (!collider1.enabled) {\n      continue;\n    }\n    j = i;\n    while (j--) {\n      collider2 = colliders[j];\n      kinetic1 = collider1.kinetic;\n      kinetic2 = collider2.kinetic;\n      if (!collider2.enabled || (kinetic1.sleeping && kinetic2.sleeping)) {\n        continue;\n      }\n      parent1 = collider1.parent;\n      parent2 = collider2.parent;\n      radius1 = parent1.radius || parent1.bounds.radius;\n      radius2 = parent2.radius || parent2.bounds.radius;\n      pos1 = parent1.transform.pos;\n      pos2 = parent2.transform.pos;\n      radiusSum = radius1 + radius2;\n      diffSq = Vec2.distSq(pos1, pos2);\n      if (diffSq > radiusSum * radiusSum) {\n        continue;\n      }\n      p = Vec2.norm(Vec2.sub(pos1, pos2, Vec2.cache[0]));\n      diff = Math.sqrt(diffSq);\n      if (collider1.trigger || collider2.trigger) {\n        parent1.pub('onTrigger', parent2, p, diff);\n        parent2.pub('onTrigger', parent1, p, diff);\n        continue;\n      }\n      diff -= radiusSum;\n      vel1 = kinetic1.vel;\n      vel2 = kinetic2.vel;\n      mass1 = kinetic1.mass || 1;\n      mass2 = kinetic2.mass || 1;\n      if (diff < 0) {\n        Vec2.add(pos1, Vec2.scal(p, -diff * 2 * radius1 / radiusSum, Vec2.cache[1]));\n        Vec2.add(pos2, Vec2.scal(p, diff * 2 * radius2 / radiusSum, Vec2.cache[1]));\n      }\n      n = Vec2.perp(p, Vec2.cache[1]);\n      vp1 = Vec2.dot(vel1, p);\n      vn1 = Vec2.dot(vel1, n);\n      vp2 = Vec2.dot(vel2, p);\n      vn2 = Vec2.dot(vel2, n);\n      vp1After = (mass1 * vp1 + mass2 * (2 * vp2 - vp1)) / (mass1 + mass2);\n      vp2After = (mass1 * (2 * vp1 - vp2) + mass2 * vp2) / (mass1 + mass2);\n      Vec2.add(Vec2.scal(p, vp1After, Vec2.cache[2]), Vec2.scal(n, vn1, Vec2.cache[3]), vel1);\n      Vec2.add(Vec2.scal(p, vp2After, Vec2.cache[2]), Vec2.scal(n, vn2, Vec2.cache[3]), vel2);\n      parent1.pub('onCollide', parent2, n);\n      parent2.pub('onCollide', parent1, n);\n    }\n  }\n  return this;\n};\n\nnew Pool(Collider);\n\nmodule.exports = Collider;\n\n//@ sourceURL=/lib/core/collider.js"
));

require.define("/lib/core/component.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.5.0\nvar Component;\n\nrequire('./math');\n\nComponent = (function() {\n\n  function Component() {}\n\n  Component.prototype.type = 'component';\n\n  Component.prototype.toString = function() {\n    return \"Component \" + this.type + \"#\" + this.uid + \" [\" + this.parent + \"]\";\n  };\n\n  Component.prototype.alloc = function(presets) {\n    var component, components, type;\n    this.parent.components[this.type] = this;\n    this.parent[this.type] = this;\n    components = this.parent.components;\n    for (type in components) {\n      if (!(type !== this.type)) {\n        continue;\n      }\n      this[type] = component = components[type];\n      component[this.type] = this;\n    }\n    if (this.reset) {\n      this.reset(presets);\n    }\n    return this;\n  };\n\n  Component.prototype.free = function() {\n    var components, type;\n    delete this.parent.components[this.type];\n    this.parent[this.type] = null;\n    components = this.parent.components;\n    for (type in components) {\n      if (!(type !== this.type)) {\n        continue;\n      }\n      this[components[type].type] = null;\n      components[type][this.type] = null;\n    }\n    this.pool.free(this);\n    return this;\n  };\n\n  Component.prototype.enable = function(state) {\n    this.enabled = state != null ? state : state = !this.state;\n    this.parent.pub('onComponent' + (state ? 'Enable' : 'Disable'), this);\n    return this;\n  };\n\n  Component.prototype.sub = function(scope, topic, method) {\n    if (scope == null) {\n      scope = this;\n    }\n    this.parent.sub(scope, topic, method);\n    return this;\n  };\n\n  return Component;\n\n})();\n\nmodule.exports = Component;\n\n//@ sourceURL=/lib/core/component.js"
));

require.define("/lib/core/composite.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.5.0\nvar Composite, Pool;\n\nPool = require('./pool');\n\nComposite = (function() {\n\n  function Composite() {\n    this.children = {};\n    this.components = {};\n  }\n\n  Composite.prototype.toString = function() {\n    return \"Composite \" + (this.name || this.type) + \"#\" + this.uid;\n  };\n\n  Composite.prototype.alloc = function(presets) {\n    var child, pool, preset, type, _i, _len;\n    if (this.parent) {\n      this.parent.children[this.uid] = this;\n    }\n    if (presets) {\n      for (type in presets) {\n        preset = presets[type];\n        switch (type) {\n          case 'children':\n            for (_i = 0, _len = preset.length; _i < _len; _i++) {\n              child = preset[_i];\n              Composite.alloc(this, child);\n            }\n            break;\n          case 'name':\n            this.name = presets[type];\n            break;\n          default:\n            if ((pool = Pool.types[type])) {\n              pool.alloc(this, preset);\n            } else {\n              throw new Error(\"Unknown preset \" + type + \", expected component. \" + this);\n            }\n        }\n      }\n    }\n    return this;\n  };\n\n  Composite.prototype.free = function() {\n    var key, ref, refSubs, _i, _len;\n    if (refSubs = this.refSubs) {\n      for (_i = 0, _len = refSubs.length; _i < _len; _i++) {\n        ref = refSubs[_i];\n        ref.unsub(this);\n      }\n    }\n    this.refSubs = this.subs = null;\n    for (key in this.components) {\n      this.components[key].free();\n    }\n    for (key in this.children) {\n      this.children[key].free();\n    }\n    if (this.parent) {\n      delete this.parent.children[this.uid];\n    }\n    this.pool.free(this);\n    return this;\n  };\n\n  Composite.prototype.enable = function(state, deep) {\n    var key;\n    this.enabled = state != null ? state : state = !this.state;\n    this.parent.pub('on' + (state ? 'Enable' : 'Disable'), this);\n    for (key in this.components) {\n      this.components[key].enable(state);\n    }\n    if (deep) {\n      for (key in this.children) {\n        this.children[key].enable(state, true);\n      }\n    }\n    return this;\n  };\n\n  Composite.prototype.sub = function(scope, topic, method) {\n    var items, refs, subs;\n    if (scope == null) {\n      scope = this;\n    }\n    subs = this.subs || (this.subs = {});\n    items = subs[topic] || (subs[topic] = []);\n    items.push(scope, method);\n    if (scope !== this) {\n      refs = scope.refSubs || (scope.refSubs = []);\n      if (!~refs.indexOf(this)) {\n        refs.push(this);\n      }\n    }\n    return this;\n  };\n\n  Composite.prototype.pub = function(topic, a0, a1, a2, a3) {\n    var i, items, scope;\n    if (this.subs && (items = this.subs[topic]) && (i = items.length)) {\n      while (scope = items[i -= 2]) {\n        scope[items[i + 1] || topic](a0, a1, a2, a3);\n      }\n    }\n    return this;\n  };\n\n  Composite.prototype.pubUp = function(topic, a0, a1, a2, a3) {\n    var comp;\n    comp = this;\n    while (comp) {\n      if (comp.pub(topic, a0, a1, a2, a3) === false) {\n        break;\n      }\n      comp = comp.parent;\n    }\n    return this;\n  };\n\n  Composite.prototype.pubAll = function(topic, a0, a1, a2, a3) {\n    return Pool.call(topic, a0, a1, a2, a3);\n  };\n\n  Composite.prototype.unsub = function(unscope, untopic) {\n    var i, items, length, scope, subs, topic;\n    if (subs = this.subs) {\n      for (topic in subs) {\n        items = subs[topic];\n        if (!((i = items.length) && (!untopic || untopic === topic))) {\n          continue;\n        }\n        length = i / 2;\n        while ((i -= 2) >= 0) {\n          if (scope = items[i]) {\n            if (unscope && scope !== unscope) {\n              continue;\n            } else {\n              items[i] = null;\n            }\n            length--;\n          }\n        }\n        if (!length) {\n          items.length = 0;\n        }\n      }\n    }\n    return this;\n  };\n\n  return Composite;\n\n})();\n\nnew Pool(Composite);\n\nComposite.Prefab = (function() {\n\n  function Prefab(presets) {\n    var key;\n    this.presets = presets;\n    for (key in presets) {\n      presets[key] = this.presets[key] || {};\n    }\n  }\n\n  Prefab.prototype.alloc = function(parent, presets) {\n    var defaults, key, subKey, subPresets, value;\n    if ((defaults = this.presets) && presets) {\n      for (key in defaults) {\n        value = defaults[key];\n        if (!(key in presets)) {\n          presets[key] = value;\n        } else {\n          subPresets = presets[key];\n          if (key === 'children') {\n            subPresets.unshift.apply(subPresets, value);\n          } else if (typeof value === 'object') {\n            for (subKey in value) {\n              if (!(subKey in subPresets)) {\n                subPresets[subKey] = value[subKey];\n              }\n            }\n          }\n          delete presets[key];\n          presets[key] = subPresets;\n        }\n      }\n    }\n    return Composite.alloc(parent, presets || defaults);\n  };\n\n  return Prefab;\n\n})();\n\nmodule.exports = Composite;\n\n//@ sourceURL=/lib/core/composite.js"
));

require.define("/lib/core/pool.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.5.0\nvar Pool, fn, _i, _len, _ref;\n\nrequire('./math');\n\nPool = (function() {\n\n  Pool.typedHooks = ['fixedUpdate', 'simulate', 'update', 'lateUpdate', 'render'];\n\n  Pool.regxHook = /^on[A-Z]/;\n\n  Pool.regxGetter = /^get[A-Z]/;\n\n  Pool.hooks = {};\n\n  Pool.types = {};\n\n  Pool.defaults = {};\n\n  Pool.order = {\n    render: false\n  };\n\n  Pool.prototype.toString = function() {\n    return \"Pool {@type} [\" + this.roster.length + \"]\";\n  };\n\n  function Pool(cls) {\n    var fn, key, keys, proto, types, _i, _j, _len, _len1,\n      _this = this;\n    this.cls = cls;\n    proto = cls.prototype;\n    this.type = proto.type;\n    this.isComponent = this.type && this.type !== 'composite';\n    this.light = (!this.isComponent) || proto.light || false;\n    if (this.type) {\n      Pool.types[this.type] = this;\n    }\n    proto.pool = this;\n    cls.pool = this;\n    this.roster = [];\n    this.subs = [];\n    this.hooks = [];\n    this.enabled = false;\n    this.allocd = 0;\n    this.layer = proto.layer || cls.layer || 0;\n    if (this.isComponent) {\n      if (!this.light) {\n        types = Pool.typedHooks;\n        keys = Object.keys(proto).concat(Object.keys(cls));\n        for (_i = 0, _len = keys.length; _i < _len; _i++) {\n          fn = keys[_i];\n          if (Pool.regxHook.test(fn)) {\n            if (!~types.indexOf(fn)) {\n              types.push(fn);\n              Pool.hooks[fn] = [];\n            }\n            this.subs.push(fn);\n          } else if (Pool.regxGetter.test(fn)) {\n            key = fn.substr(3, 1).toLowerCase() + fn.substr(4);\n            Pool.defineGetter(proto, key, fn);\n          }\n        }\n        for (_j = 0, _len1 = types.length; _j < _len1; _j++) {\n          fn = types[_j];\n          if (fn in cls) {\n            this[fn] = cls[fn];\n            Pool.hooks[fn].push(this);\n          } else if (fn in proto) {\n            this.hooks.push(fn);\n          }\n        }\n      }\n    }\n    cls.alloc = function(parent, presets) {\n      return _this.alloc(parent, presets);\n    };\n  }\n\n  Pool.prototype.preinstantiate = function(i) {\n    while (i--) {\n      this.instantiate();\n    }\n    return this;\n  };\n\n  Pool.prototype.instantiate = function() {\n    var cls, hook, _i, _len, _ref;\n    cls = new this.cls();\n    this.roster.push(cls);\n    _ref = this.hooks;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      hook = _ref[_i];\n      Pool.hooks[hook].push(cls);\n    }\n    return cls;\n  };\n\n  Pool.prototype.alloc = function(parent, presets) {\n    var defaults, entity, hook, i, roster, topic, uid, _i, _j, _len, _len1, _ref, _ref1;\n    roster = this.roster;\n    i = roster.length;\n    while (i--) {\n      if (!roster[i].allocd) {\n        entity = roster[i];\n        break;\n      }\n    }\n    if (!entity) {\n      entity = this.instantiate();\n    }\n    this.allocd++;\n    this.enabled = true;\n    _ref = this.hooks;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      hook = _ref[_i];\n      if (hook in Pool.order) {\n        Pool.order[hook] = true;\n      }\n    }\n    entity.uid = uid = Math.uid();\n    entity.enabled = true;\n    entity.allocd = true;\n    entity.parent = parent || null;\n    entity.root = parent && parent.root || parent || entity;\n    entity.layer = (parent && parent.layer || 0) + this.layer + 2 - 1 / uid;\n    if (entity.root.descendants) {\n      entity.root.descendants[uid] = entity;\n    } else {\n      entity.descendants = {};\n    }\n    if (this.isComponent) {\n      if (defaults = entity.presets) {\n        if (presets && !presets._merged) {\n          presets.__proto__ = defaults;\n          presets._merged = true;\n        }\n      }\n      _ref1 = this.subs;\n      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n        topic = _ref1[_j];\n        parent.sub(entity, topic);\n      }\n    }\n    entity.alloc(presets || defaults || null);\n    return entity;\n  };\n\n  Pool.prototype.free = function(entity) {\n    if (entity.root === entity) {\n      entity.descendants = null;\n    } else if (entity.root.descendants) {\n      delete entity.root.descendants[entity.uid];\n    }\n    entity.enabled = false;\n    entity.allocd = false;\n    entity.uid = null;\n    entity.root = null;\n    entity.parent = null;\n    this.enabled = this.allocd-- > 1;\n    return this;\n  };\n\n  return Pool;\n\n})();\n\n_ref = Pool.typedHooks;\nfor (_i = 0, _len = _ref.length; _i < _len; _i++) {\n  fn = _ref[_i];\n  Pool.hooks[fn] = [];\n}\n\nPool.dump = function(free) {\n  var pool, type, _ref1;\n  _ref1 = Pool.types;\n  for (type in _ref1) {\n    pool = _ref1[type];\n    console.log(\"%s: %d/%d allocd\", type, pool.allocd, pool.roster.length);\n  }\n  if (free) {\n    Pool.free();\n  }\n  return null;\n};\n\nPool.defineGetter = function(proto, key, fn) {\n  Object.defineProperty(proto, key, {\n    get: proto[fn],\n    enumerable: true,\n    configurable: true\n  });\n  return proto;\n};\n\nPool.free = function() {\n  var freed, i, pool, roster, type, _ref1;\n  _ref1 = Pool.types;\n  for (type in _ref1) {\n    pool = _ref1[type];\n    roster = pool.roster;\n    i = roster.length;\n    freed = 0;\n    while (i--) {\n      if (!(!roster[i].allocd)) {\n        continue;\n      }\n      roster.splice(i, 1);\n      freed++;\n    }\n    console.log(\"%s: %d/%d freed\", type, freed, pool.roster.length);\n  }\n  return this;\n};\n\nPool.invoke = function(fn, a0, a1, a2, a3) {\n  var i, stack;\n  if ((stack = this.hooks[fn]) && (i = stack.length)) {\n    if (fn in Pool.order && Pool.order[fn]) {\n      stack.sort(Pool.orderFn);\n      Pool.order[fn] = false;\n    }\n    while (i--) {\n      if (stack[i].enabled) {\n        stack[i][fn](a0, a1, a2, a3);\n      }\n    }\n  }\n  return this;\n};\n\nPool.orderFn = function(a, b) {\n  return b.layer - a.layer;\n};\n\nmodule.exports = Pool;\n\n//@ sourceURL=/lib/core/pool.js"
));

require.define("/lib/core/transform.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.5.0\nvar Component, Pool, Transform, Vec2,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComponent = require('./component');\n\nPool = require('./pool');\n\nVec2 = require('./math').Vec2;\n\nTransform = (function(_super) {\n\n  __extends(Transform, _super);\n\n  Transform.prototype.type = 'transform';\n\n  Transform.prototype.presets = {\n    pos: Vec2(),\n    angle: 0\n  };\n\n  function Transform() {\n    this.pos = Vec2();\n  }\n\n  Transform.prototype.reset = function(presets) {\n    Vec2.copy(this.pos, presets.pos);\n    this.worldAngle = this.angle = presets.angle;\n    return this;\n  };\n\n  Transform.prototype.setTransform = function(pos, angle, silent) {\n    if (pos != null) {\n      Vec2.copy(this.pos, pos);\n    }\n    if (angle != null) {\n      this.angle = angle;\n    }\n    this.dirty = true;\n    if (!silent) {\n      this.parent.pub('onTransform', this.pos, this.angle);\n    }\n    return this;\n  };\n\n  Transform.prototype.toWorld = function() {\n    this.worldPos.copy(this.pos);\n    this.worldAngle = this.angle;\n    return this;\n  };\n\n  Transform.prototype.applyMatrix = function(ctx) {\n    ctx.translate(this.pos[0] | 0, this.pos[1] | 0);\n    if (this.angle) {\n      ctx.rotate(this.angle);\n    }\n    return this;\n  };\n\n  return Transform;\n\n})(Component);\n\nnew Pool(Transform);\n\nmodule.exports = Transform;\n\n//@ sourceURL=/lib/core/transform.js"
));

require.define("/lib/core/kinetic.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.5.0\nvar Component, Force, Kinetic, Pool, Vec2, cache, copyVel,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComponent = require('./component');\n\nPool = require('./pool');\n\nForce = require('./force');\n\nVec2 = require('./math').Vec2;\n\ncache = Vec2();\n\ncopyVel = Vec2();\n\nKinetic = (function(_super) {\n\n  __extends(Kinetic, _super);\n\n  Kinetic.prototype.type = 'kinetic';\n\n  Kinetic.gravity = null;\n\n  Kinetic.friction = 15;\n\n  Kinetic.drag = 0.999;\n\n  Kinetic.prototype.presets = {\n    mass: 0,\n    drag: Kinetic.drag,\n    friction: Kinetic.friction,\n    fixed: false,\n    maxVel: 75,\n    maxAcc: 2000,\n    acc: Vec2(),\n    vel: Vec2()\n  };\n\n  function Kinetic() {\n    this.vel = Vec2();\n    this.acc = Vec2();\n    this.sleepVelSq = 0.2;\n  }\n\n  Kinetic.prototype.reset = function(presets) {\n    this.mass = presets.mass, this.drag = presets.drag, this.friction = presets.friction, this.fixed = presets.fixed, this.maxVel = presets.maxVel, this.maxAcc = presets.maxAcc;\n    Vec2.copy(this.vel, presets.vel);\n    Vec2.copy(this.acc, presets.acc);\n    this.pos = this.transform.pos;\n    this.sleeping = false;\n    return this;\n  };\n\n  Kinetic.prototype.applyImpulse = function(acc) {\n    Vec2.add(this.acc, Vec2.scal(acc, 1 / (this.mass || 1), cache));\n    return this;\n  };\n\n  Kinetic.prototype.applyForce = function(acc) {\n    if (!this.force) {\n      Force.alloc(this);\n    }\n    this.force.add(acc);\n    return this;\n  };\n\n  return Kinetic;\n\n})(Component);\n\nKinetic.simulate = function(dt) {\n  var acc, epsilon, kinetic, vel, _i, _len, _ref;\n  epsilon = Math.epsilon;\n  _ref = this.roster;\n  for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n    kinetic = _ref[_i];\n    if (!(kinetic.enabled && !kinetic.fixed)) {\n      continue;\n    }\n    vel = kinetic.vel;\n    acc = kinetic.acc;\n    if (kinetic.root.gravity && kinetic.mass > epsilon) {\n      Vec2.add(acc, Vec2.scal(kinetic.root.gravity, 1 / kinetic.mass, cache));\n    }\n    if (kinetic.friction) {\n      Vec2.add(acc, Vec2.scal(Vec2.norm(vel, cache), -kinetic.friction));\n    }\n    if (kinetic.maxAcc) {\n      Vec2.limit(acc, kinetic.maxAcc);\n    }\n    Vec2.copy(copyVel, vel);\n    Vec2.add(vel, Vec2.scal(acc, dt, cache));\n    if (kinetic.maxVel) {\n      Vec2.limit(vel, kinetic.maxVel);\n    }\n    Vec2.scal(Vec2.add(copyVel, vel), dt / 2);\n    Vec2.add(kinetic.pos, copyVel);\n    Vec2.add(vel, Vec2.scal(acc, dt));\n    if (kinetic.drag < 1) {\n      Vec2.scal(vel, kinetic.drag);\n    }\n    if (kinetic.sleepVelSq) {\n      if (Vec2.lenSq(vel) <= kinetic.sleepVelSq) {\n        if (!kinetic.sleeping) {\n          Vec2.set(vel);\n          kinetic.sleeping = true;\n          kinetic.parent.pubUp('onKineticSleep', kinetic);\n        }\n      } else {\n        if (kinetic.sleeping) {\n          kinetic.sleeping = false;\n          kinetic.parent.pubUp('onKineticWake', kinetic);\n        }\n      }\n    }\n    Vec2.set(acc);\n  }\n  return this;\n};\n\nnew Pool(Kinetic);\n\nmodule.exports = Kinetic;\n\n//@ sourceURL=/lib/core/kinetic.js"
));

require.define("/lib/core/bounds.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.5.0\nvar Bounds, BoundsDebug, Color, Component, Pool, Vec2,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComponent = require('./component');\n\nPool = require('./pool');\n\nColor = require('./color');\n\nVec2 = require('./math').Vec2;\n\nBounds = (function(_super) {\n\n  __extends(Bounds, _super);\n\n  Bounds.prototype.type = 'bounds';\n\n  Bounds.prototype.presets = {\n    shape: 'rect',\n    radius: 0,\n    size: Vec2()\n  };\n\n  function Bounds() {\n    this.size = Vec2();\n  }\n\n  Bounds.prototype.reset = function(presets) {\n    Vec2.copy(this.size, presets.size);\n    this.shape = presets.shape;\n    this.radius = presets.radius;\n    return this;\n  };\n\n  Bounds.prototype.getTop = function() {\n    if (this.shape === 'circle') {\n      return this.transform.pos[1] - this.radius;\n    }\n    return this.transform.pos[1];\n  };\n\n  Bounds.prototype.getBottom = function() {\n    if (this.shape === 'circle') {\n      return this.transform.pos[1] + this.radius;\n    }\n    return this.transform.pos[1] + this.size[1];\n  };\n\n  Bounds.prototype.intersectLine = function(p1, p2) {\n    return null;\n  };\n\n  Bounds.prototype.intersect = function(bound) {\n    return null;\n  };\n\n  Bounds.prototype.contains = function(point) {\n    var pos;\n    pos = this.transform.pos;\n    switch (this.shape) {\n      case 'circle':\n        return Bounds.circPoint(pos, this.radius, point);\n      case 'rect':\n        return Bounds.rectPoint(pos, this.size, point);\n    }\n    return false;\n  };\n\n  Bounds.prototype.withinRect = function(pos, size) {\n    var mypos;\n    mypos = this.transform.pos;\n    switch (this.shape) {\n      case 'circle':\n        return Bounds.rectCirc(pos, size, mypos, this.radius);\n      case 'rect':\n        return Bounds.rectRect(pos, size, mypos, this.size);\n    }\n    return false;\n  };\n\n  return Bounds;\n\n})(Component);\n\nBounds.circPoint = function(center, radius, point) {\n  return Vec2.distSq(point, center) <= radius * radius;\n};\n\nBounds.rectPoint = function(pos, size, point) {\n  return pos[0] - size[0] < point[0] && pos[1] < point[1] && pos[0] + size[0] > point[0] && pos[1] + size[1] > point[1];\n};\n\nBounds.rectCirc = function(topLeft, size, center, radius) {\n  var circleDistanceX, circleDistanceY, cornerDistance;\n  circleDistanceX = Math.abs(center[0] - topLeft[0] - size[0] / 2);\n  circleDistanceY = Math.abs(center[1] - topLeft[1] - size[1] / 2);\n  if (circleDistanceX > (size[0] / 2 + radius) || circleDistanceY > (size[1] / 2 + radius)) {\n    return false;\n  }\n  if (circleDistanceX <= size[0] / 2 || circleDistanceY <= size[1] / 2) {\n    return true;\n  }\n  cornerDistance = Math.pow(circleDistanceX - size[0] / 2, 2) + Math.pow(circleDistanceY - size[1] / 2, 2);\n  return cornerDistance <= Math.pow(radius, 2);\n};\n\nBounds.rectRect = function(pos, size, pos2, size2) {\n  return !(pos[0] > pos2[0] + size2[0] || pos[0] + size[0] < pos2[0] || pos[1] > pos2[1] + size2[1] || pos[1] + size[1] < pos2[1]);\n};\n\nBounds.lineRect = function(point1, point2, topLeft, size) {\n  var botOverlap, bottomIntersection, bottomPoint, c, m, topIntersection, topOverlap, topPoint, _ref, _ref1;\n  this.topLeft = topLeft;\n  this.size = size;\n  m = (y2 - y1) / (x2 - x1);\n  c = y1(-(m * x1));\n  if (m > 0) {\n    topIntersection = m * rx + c;\n    bottomIntersection = m * (rx + rw) + c;\n  } else {\n    topIntersection = m * (rx + rw) + c;\n    bottomIntersection = m * rx + c;\n  }\n  if (y1 < y2) {\n    topPoint = y1;\n    bottomPoint = y2;\n  } else {\n    topPoint = y2;\n    bottomPoint = y1;\n  }\n  topOverlap = (_ref = topIntersection > topPoint) != null ? _ref : {\n    topIntersection: topPoint\n  };\n  botOverlap = (_ref1 = bottomIntersection < bottomPoint) != null ? _ref1 : {\n    bottomIntersection: bottomPoint\n  };\n  return (topOverlap < botOverlap) && (!((botOverlap < ry) || (topOverlap > ry + rh)));\n};\n\nBounds.lineCirc = function(point1, point2, center, radius) {\n  var a, b, bb4ac, c, dx, dy, ix1, ix2, iy1, iy2, mu, testX, testY;\n  dx = x2 - x1;\n  dy = y2 - y1;\n  a = dx * dx + dy * dy;\n  b = 2 * (dx * (x1 - cx) + dy * (y1 - cy));\n  c = cx * cx + cy * cy;\n  c += x1 * x1 + y1 * y1;\n  c -= 2 * (cx * x1 + cy * y1);\n  c -= cr * cr;\n  bb4ac = b * b - 4 * a * c;\n  if (bb4ac < 0) {\n    return false;\n  }\n  mu = (-b + sqrt(b * b - 4 * a * c)) / (2 * a);\n  ix1 = x1 + mu * dx;\n  iy1 = y1 + mu * dy;\n  mu = (-b - sqrt(b * b - 4 * a * c)) / (2 * a);\n  ix2 = x1 + mu * dx;\n  iy2 = y1 + mu * dy;\n  if (dist(x1, y1, cx, cy) < dist(x2, y2, cx, cy)) {\n    testX = x2;\n    testY = y2;\n  } else {\n    testX = x1;\n    testY = y1;\n  }\n  if (dist(testX, testY, ix1, iy1) < dist(x1, y1, x2, y2) || dist(testX, testY, ix2, iy2) < dist(x1, y1, x2, y2)) {\n    return true;\n  }\n  return false;\n};\n\nnew Pool(Bounds);\n\nBoundsDebug = (function(_super) {\n\n  __extends(BoundsDebug, _super);\n\n  BoundsDebug.prototype.type = 'boundsDebug';\n\n  BoundsDebug.prototype.presets = {\n    color: Color.white,\n    opacity: 0.5,\n    fill: false\n  };\n\n  function BoundsDebug() {\n    this.color = Vec2();\n  }\n\n  BoundsDebug.prototype.reset = function(presets) {\n    Vec2.copy(this.color, presets.color);\n    this.opacity = presets.opacity, this.fill = presets.fill;\n    return this;\n  };\n\n  BoundsDebug.prototype.render = function(ctx) {\n    var bounds, size;\n    bounds = this.bounds;\n    ctx.save();\n    if (this.fill) {\n      ctx.fillStyle = Color.rgba(this.color, this.opacity * 0.5);\n    }\n    ctx.strokeStyle = Color.rgba(this.color, this.opacity);\n    ctx.lineWidth = 1;\n    this.transform.applyMatrix(ctx);\n    if (bounds.shape === 'circle') {\n      ctx.beginPath();\n      ctx.lineTo(0, bounds.radius);\n      ctx.moveTo(0, 0);\n      ctx.arc(0, 0, bounds.radius | 0, 0, Math.TAU);\n      if (this.fill) {\n        ctx.fill();\n      }\n      ctx.stroke();\n    } else {\n      size = bounds.size;\n      ctx.strokeRect(-size[0] / 2 | 0, -size[1] / 2 | 0, size[0] | 0, size[1] | 0);\n      if (this.fill) {\n        ctx.fillRect(-size[0] / 2 | 0, -size[1] / 2 | 0, size[0] | 0, size[1] | 0);\n      }\n    }\n    ctx.restore();\n    return this;\n  };\n\n  return BoundsDebug;\n\n})(Component);\n\nnew Pool(BoundsDebug);\n\nBounds.Debug = BoundsDebug;\n\nmodule.exports = Bounds;\n\n//@ sourceURL=/lib/core/bounds.js"
));

require.define("/lib/core/force.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.5.0\nvar Component, Force, Pool, Vec2, cache,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComponent = require('./component');\n\nPool = require('./pool');\n\nVec2 = require('./math').Vec2;\n\ncache = Vec2();\n\nForce = (function(_super) {\n\n  __extends(Force, _super);\n\n  Force.prototype.type = 'force';\n\n  Force.prototype.presets = {\n    acc: Vec2(),\n    torque: 0\n  };\n\n  function Force() {\n    this.acc = Vec2();\n  }\n\n  Force.prototype.reset = function(presets) {\n    Vec2.copy(this.acc, presets.acc);\n    this.torque = presets.torque;\n    this.age = 0;\n    return this;\n  };\n\n  Force.prototype.add = function(acc) {\n    Vec2.add(this.acc, acc);\n    return this;\n  };\n\n  Force.prototype.simulate = function(dt) {\n    Vec2.add(this.kinetic.acc, this.acc);\n    return this;\n  };\n\n  return Force;\n\n})(Component);\n\nnew Pool(Force);\n\nmodule.exports = Force;\n\n//@ sourceURL=/lib/core/force.js"
));

require.define("/lib/core.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.5.0\n\nmodule.exports = {\n  Math: require('./core/math'),\n  Engine: require('./core/engine'),\n  Composite: require('./core/composite'),\n  Component: require('./core/component'),\n  Pool: require('./core/pool'),\n  Color: require('./core/color'),\n  Transform: require('./core/transform'),\n  Bounds: require('./core/bounds'),\n  Border: require('./core/border'),\n  Collider: require('./core/collider'),\n  Kinetic: require('./core/kinetic')\n};\n\n//@ sourceURL=/lib/core.js"
));

require.define("/test/client.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\n/**\n * Listen to `runner` events to populate a global\n * `.mochaResults` var which may be used by selenium\n * to report on results.\n *\n *    cloud(mocha.run());\n *\n * @param {Runner} runner\n * @api public\n */\n\nmodule.exports = function(runner){\n  var failed = [];\n\n  runner.on('fail', function(test, err){\n    failed.push({\n      title: test.title,\n      fullTitle: test.fullTitle(),\n      error: {\n        message: err.message,\n        stack: err.stack\n      }\n    });\n  });\n\n  runner.on('end', function(){\n    runner.stats.failed = failed;\n    global.mochaResults = runner.stats;\n  });\n};\n//@ sourceURL=/test/client.js"
));

require.define("/lib/core/input.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.5.0\nvar Component, Engine, Input, Pool, Vec2, pool,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComponent = require('./component');\n\nPool = require('./pool');\n\nVec2 = require('./math').Vec2;\n\nEngine = require('./engine');\n\nInput = (function(_super) {\n\n  __extends(Input, _super);\n\n  Input.prototype.type = 'input';\n\n  Input.prototype.support = {\n    touch: 'ontouchstart' in window,\n    orientation: 'ondeviceorientation' in window\n  };\n\n  function Input() {\n    var code, key, type, _ref;\n    this.queue = [];\n    this.locks = {};\n    this.pos = Vec2();\n    this.prevPos = Vec2();\n    this.touchState = null;\n    this.axis = Vec2();\n    this.mouseAxis = Vec2();\n    this.orientation = Vec2();\n    this.prevOrientation = Vec2();\n    this.baseOrientation = Vec2();\n    this.map = {\n      32: 'space',\n      192: 'debug',\n      38: 'up',\n      39: 'right',\n      40: 'bottom',\n      37: 'left'\n    };\n    this.axisMap = {\n      left: Vec2(0, -1),\n      right: Vec2(0, 1),\n      up: Vec2(1, -1),\n      bottom: Vec2(1, 1)\n    };\n    this.keyNames = [];\n    this.keys = {};\n    _ref = this.map;\n    for (code in _ref) {\n      key = _ref[code];\n      if (!~this.keyNames.indexOf(key)) {\n        this.keyNames.push(key);\n        this.keys[key] = null;\n      }\n    }\n    this.throttled = {\n      mousemove: true,\n      deviceorientation: true\n    };\n    this.lastEvent = null;\n    this.events = this.support.touch ? {\n      touchstart: 'startTouch',\n      touchmove: 'moveTouch',\n      touchend: 'endTouch',\n      touchcancel: 'endTouch'\n    } : {\n      mousedown: 'startTouch',\n      mousemove: 'moveTouch',\n      mouseup: 'endTouch',\n      keydown: 'keyStart',\n      keyup: 'keyEnd'\n    };\n    for (type in this.events) {\n      window.addEventListener(type, this, false);\n    }\n  }\n\n  Input.prototype.handleEvent = function(event) {\n    var type;\n    if (event.metaKey) {\n      return;\n    }\n    event.preventDefault();\n    type = event.type;\n    if (this.throttled[type] && this.lastEvent === type) {\n      this.queue[this.queue.length - 1] = event;\n    } else {\n      this.lastEvent = type;\n      this.queue.push(event);\n    }\n    return this;\n  };\n\n  Input.prototype.keyStart = function(event) {\n    var axis, key;\n    if ((key = this.map[event.keyCode]) && !this.keys[key]) {\n      if (!this.lock('key-' + key)) {\n        return false;\n      }\n      this.keys[key] = 'began';\n      if ((axis = this.axisMap[key])) {\n        this.axis[axis[0]] += axis[1];\n      }\n      Engine.pub('onKeyBegan', key);\n    }\n    return this;\n  };\n\n  Input.prototype.keyEnd = function(event) {\n    var axis, key;\n    if (key = this.map[event.keyCode]) {\n      if (!this.lock('key-' + key)) {\n        return false;\n      }\n      this.keys[key] = 'ended';\n      if ((axis = this.axisMap[key])) {\n        this.axis[axis[0]] -= axis[1];\n      }\n      Engine.pub('onKeyEnded', key);\n    }\n    return this;\n  };\n\n  Input.prototype.startTouch = function(event) {\n    if (!this.lock('touch')) {\n      return false;\n    }\n    this.resolve(event);\n    if (!this.touchState && !event.metaKey) {\n      this.touchState = 'began';\n      Engine.pub('onTouchBegan');\n    }\n    return this;\n  };\n\n  Input.prototype.moveTouch = function(event) {\n    var state;\n    state = this.touchState;\n    if ((state === 'began' || state === 'ended') && !this.lock('touch')) {\n      return false;\n    }\n    this.resolve(event);\n    if (state && state !== 'ended' && state !== 'moved') {\n      this.touchState = 'moved';\n    }\n    return this;\n  };\n\n  Input.prototype.endTouch = function(event) {\n    if (!this.lock('touch')) {\n      return false;\n    }\n    this.resolve(event);\n    if (this.touchState && (!this.support.touch || !event.targetTouches.length)) {\n      Engine.pub('onTouchEnded');\n      this.touchState = 'ended';\n    }\n    return this;\n  };\n\n  Input.prototype.calibrateOrientation = function() {\n    this.baseOrientationTime = this.orientationTime;\n    Vec2.copy(this.baseOrientation, this.orientation);\n    Vec2.set(this.orientation);\n    return this;\n  };\n\n  Input.prototype.deviceOrientation = function(event) {\n    Vec2.copy(this.prevOrientation, this.orientation);\n    Vec2.sub(Vec2.set(this.orientation, event.gamma | 0, event.beta | 0), this.baseOrientation);\n    this.orientationTime = event.timeStamp / 1000;\n    if (!this.baseOrientationTime) {\n      this.calibrateOrientation();\n    }\n    return this;\n  };\n\n  Input.prototype.resolve = function(event) {\n    var coords, renderer;\n    coords = this.support.touch ? event.targetTouches[0] : event;\n    if (coords) {\n      this.prevTime = this.time;\n      this.time = event.timeStamp / 1000;\n      Vec2.copy(this.prevPos, this.pos);\n      renderer = Engine.renderer;\n      Vec2.set(this.pos, (coords.pageX - renderer.margin[0]) / renderer.scale | 0, (coords.pageY - renderer.margin[1]) / renderer.scale | 0);\n    }\n    return this;\n  };\n\n  Input.prototype.lock = function(key) {\n    if (this.locks[key] === this.frame) {\n      console.log('LOCKED: ' + key);\n      return false;\n    }\n    this.locks[key] = this.frame;\n    return true;\n  };\n\n  Input.prototype.lateUpdate = function(dt, scene) {\n    var event, key, keys, queue, type, _i, _len, _ref;\n    switch (this.touchState) {\n      case 'began':\n        this.touchState = 'stationary';\n        break;\n      case 'ended':\n        this.touchState = null;\n        break;\n    }\n    keys = this.keys;\n    _ref = this.keyNames;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      key = _ref[_i];\n      switch (keys[key]) {\n        case 'began':\n          keys[key] = 'pressed';\n          break;\n        case 'ended':\n          keys[key] = null;\n          break;\n      }\n    }\n    this.frame = Engine.frame;\n    queue = this.queue;\n    while ((event = queue[0])) {\n      type = event.type;\n      if (!this[this.events[type]](event)) {\n        break;\n      }\n      queue.shift();\n    }\n    if (!queue.length) {\n      this.lastEvent = null;\n    }\n    return this;\n  };\n\n  return Input;\n\n})(Component);\n\npool = new Pool(Input);\n\nmodule.exports = Input;\n\n//@ sourceURL=/lib/core/input.js"
));

require.define("/lib/core/math.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.5.0\nvar Mat, Vec2, abs, epsilon, fn, i, objCache, objVecCache, pow, powIn, radCache, random, sqrt, toInOut, toOut, transition, typedArray, _i, _len, _ref;\n\nMat = Math;\n\nsqrt = Mat.sqrt, pow = Mat.pow, abs = Mat.abs, random = Mat.random;\n\nMat.epsilon = epsilon = 0.001;\n\nMat.TypedArray = typedArray = Float64Array || Float32Array || function(arr) {\n  return arr;\n};\n\nMat.Vec2 = Vec2 = function(fromOrX, y) {\n  if (y != null) {\n    return new typedArray([fromOrX, y]);\n  }\n  if (fromOrX != null) {\n    return new typedArray(fromOrX);\n  }\n  return new typedArray(Vec2.zero);\n};\n\nVec2.zero = Vec2.center = Vec2(0, 0);\n\nVec2.cache = [Vec2(), Vec2(), Vec2(), Vec2(), Vec2()];\n\nVec2.topLeft = Vec2(-1, -1);\n\nVec2.topCenter = Vec2(0, -1);\n\nVec2.topRight = Vec2(1, -1);\n\nVec2.centerLeft = Vec2(-1, 0);\n\nVec2.centerRight = Vec2(1, 0);\n\nVec2.bottomLeft = Vec2(-1, 1);\n\nVec2.bottomCenter = Vec2(0, 1);\n\nVec2.bottomRight = Vec2(1, 1);\n\nradCache = [Vec2(), Vec2()];\n\nobjCache = {\n  x: 0,\n  y: 0\n};\n\nobjVecCache = Vec2();\n\nVec2.set = function(result, x, y) {\n  result[0] = x || 0;\n  result[1] = y || 0;\n  return result;\n};\n\nVec2.copy = function(result, b) {\n  result[0] = b[0];\n  result[1] = b[1];\n  return result;\n};\n\nVec2.valid = function(a) {\n  return !(isNaN(a[0]) || isNaN(a[1]));\n};\n\nVec2.toString = function(a) {\n  return \"[\" + a[0] + \", \" + a[1] + \"]\";\n};\n\nVec2.fromObj = function(obj, a) {\n  a || (a = objVecCache);\n  a[0] = obj.x;\n  a[1] = obj.y;\n  return a;\n};\n\nVec2.toObj = function(a, obj) {\n  obj || (obj = objCache);\n  obj.x = a[0];\n  obj.y = a[1];\n  return obj;\n};\n\nVec2.eq = function(a, b) {\n  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;\n};\n\nVec2.add = function(a, b, result) {\n  result || (result = a);\n  result[0] = a[0] + b[0];\n  result[1] = a[1] + b[1];\n  return result;\n};\n\nVec2.sub = function(a, b, result) {\n  result || (result = a);\n  result[0] = a[0] - b[0];\n  result[1] = a[1] - b[1];\n  return result;\n};\n\nVec2.mul = function(a, b, result) {\n  result || (result = a);\n  result[0] = a[0] * b[0];\n  result[1] = a[1] * b[1];\n  return result;\n};\n\nVec2.scal = function(a, scalar, result) {\n  result || (result = a);\n  result[0] = a[0] * scalar;\n  result[1] = a[1] * scalar;\n  return result;\n};\n\nVec2.norm = function(a, result, scalar) {\n  var len, x, y;\n  if (scalar == null) {\n    scalar = 1;\n  }\n  result || (result = a);\n  x = a[0];\n  y = a[1];\n  len = scalar / (sqrt(x * x + y * y) || 1);\n  result[0] = x * len;\n  result[1] = y * len;\n  return result;\n};\n\nVec2.lenSq = function(a) {\n  return a[0] * a[0] + a[1] * a[1];\n};\n\nVec2.len = function(a) {\n  return sqrt(a[0] * a[0] + a[1] * a[1]);\n};\n\nVec2.dot = function(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n};\n\nVec2.cross = function(a, b) {\n  return a[0] * b[1] - a[1] * b[0];\n};\n\nVec2.lerp = function(a, b, scalar, result) {\n  result || (result = a);\n  result[0] = a[0] + scalar * (b[0] - a[0]);\n  result[1] = a[1] + scalar * (b[1] - a[1]);\n  return result;\n};\n\nVec2.max = function(a, b, axis) {\n  if (axis != null) {\n    if (a[axis] > b[axis]) {\n      return a;\n    } else {\n      return b;\n    }\n  }\n  if (Vec2.lenSq(a) > Vec2.lenSq(b)) {\n    return a;\n  } else {\n    return b;\n  }\n};\n\nVec2.perp = function(a, result) {\n  var x;\n  result || (result = a);\n  x = a[0];\n  result[0] = a[1];\n  result[1] = -x;\n  return result;\n};\n\nVec2.dist = function(a, b) {\n  var x, y;\n  x = b[0] - a[0];\n  y = b[1] - a[1];\n  return sqrt(x * x + y * y);\n};\n\nVec2.distSq = function(a, b) {\n  var x, y;\n  x = b[0] - a[0];\n  y = b[1] - a[1];\n  return x * x + y * y;\n};\n\nVec2.limit = function(a, max, result) {\n  var ratio, x, y;\n  result || (result = a);\n  x = a[0];\n  y = a[1];\n  if ((ratio = max / sqrt(x * x + y * y)) < 1) {\n    result[0] = x * ratio;\n    result[1] = y * ratio;\n  } else if (result !== a) {\n    result[0] = x;\n    result[1] = y;\n  }\n  return result;\n};\n\nVec2.rad = function(a, b) {\n  if (!b) {\n    return Mat.atan2(a[1], a[0]);\n  }\n  return Mat.acos(Vec2.dot(Vec2.norm(a, radCache[0]), Vec2.norm(b, radCache[1])));\n};\n\nVec2.rot = function(a, theta, result) {\n  var cosA, sinA, x, y;\n  result || (result = a);\n  sinA = Mat.sin(theta);\n  cosA = Mat.cos(theta);\n  x = a[0];\n  y = a[1];\n  result[0] = x * cosA - y * sinA;\n  result[1] = x * sinA + y * cosA;\n  return result;\n};\n\nVec2.rotAxis = function(a, b, theta, result) {\n  return Vec2.add(Vec2.rot(Vec2.sub(a, b, result || a), theta), b);\n};\n\nVec2.lookAt = function(a, b, result) {\n  var len;\n  len = Vec2.len(a);\n  return Vec2.norm(Vec2.rot(a, Mat.atan2(b[0] - a[0], b[1] - a[1]) - Mat.atan2(a[1], a[0]), result || a), null, len);\n};\n\nrandom = Mat.random, pow = Mat.pow;\n\nMat.TAU = Mat.PI * 2;\n\nMat.UID = 1;\n\nMat.uid = function() {\n  return Mat.UID++;\n};\n\nMat.clamp = function(a, low, high) {\n  if (a < low) {\n    return low;\n  }\n  if (a > high) {\n    return high;\n  } else {\n    return a;\n  }\n};\n\nMat.rand = function(low, high, ease) {\n  return (ease || Mat.linear)(random()) * (high - low) + low;\n};\n\nMat.randArray = function(array) {\n  return array[random() * array.length | 0];\n};\n\nMat.chance = function(chance) {\n  return random() <= chance;\n};\n\npowIn = function(strength) {\n  if (strength == null) {\n    strength = 2;\n  }\n  return function(t) {\n    return pow(t, strength);\n  };\n};\n\ntoOut = function(fn) {\n  return function(t) {\n    return 1 - fn(1 - t);\n  };\n};\n\ntoInOut = function(fn) {\n  return function(t) {\n    return (t < 0.5 ? fn(t * 2) : 2 - fn(2 * (1 - t))) / 2;\n  };\n};\n\nMat.linear = function(t) {\n  return t;\n};\n\n_ref = ['quad', 'cubic', 'quart', 'quint'];\nfor (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n  transition = _ref[i];\n  Mat[transition + 'In'] = fn = powIn(i + 2);\n  Mat[transition + 'Out'] = toOut(fn);\n  Mat[transition + 'InOut'] = toInOut(fn);\n}\n\nmodule.exports.Vec2 = Vec2;\n\n//@ sourceURL=/lib/core/math.js"
));

require.define("/lib/core/color.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.5.0\nvar Color, typedArray;\n\nrequire('./math');\n\ntypedArray = Math.TypedArray;\n\nColor = function(fromOrR, g, b, a) {\n  var _ref;\n  if (g != null) {\n    return new typedArray([fromOrR, g, b, a != null ? a : 1]);\n  }\n  if (fromOrR != null) {\n    return new typedArray([fromOrR[0], fromOrR[1], fromOrR[2], (_ref = fromOrR[3]) != null ? _ref : 1]);\n  }\n  return new typedArray(Color.black);\n};\n\nColor.white = Color(255, 255, 255);\n\nColor.black = Color(0, 0, 0);\n\nColor.cache = [Color(), Color(), Color(), Color()];\n\nColor.set = function(result, r, g, b, a) {\n  result[0] = r || 0;\n  result[1] = g || 0;\n  result[2] = b || 0;\n  result[3] = a || 0;\n  return result;\n};\n\nColor.copy = function(result, b) {\n  result[0] = b[0];\n  result[1] = b[1];\n  result[2] = b[2];\n  result[3] = b[3];\n  return result;\n};\n\nColor.lerp = function(a, b, t, alpha, result) {\n  result || (result = a);\n  result[0] = (1 - t) * a[0] + t * b[0];\n  result[1] = (1 - t) * a[1] + t * b[1];\n  result[2] = (1 - t) * a[2] + t * b[2];\n  if (alpha > 0.05) {\n    result[3] = (1 - t) * a[3] + t * b[3];\n  } else {\n    result[3] = a[3];\n  }\n  return result;\n};\n\nColor.variant = function(a, t, result) {\n  t = Math.rand(-t, t);\n  return Color.lerp(a, (t > 0 ? Color.white : Color.black), t, false, result);\n};\n\nColor.rgba = function(a, alpha) {\n  alpha || (alpha = a[3]);\n  if (alpha > 0.98) {\n    return \"rgb(\" + (a[0] | 0) + \", \" + (a[1] | 0) + \", \" + (a[2] | 0) + \")\";\n  } else {\n    return \"rgba(\" + (a[0] | 0) + \", \" + (a[1] | 0) + \", \" + (a[2] | 0) + \", \" + alpha + \")\";\n  }\n};\n\nmodule.exports = Color;\n\n//@ sourceURL=/lib/core/color.js"
));

require.define("/lib/core/border.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.5.0\nvar Border, Component, Engine, Pool, Vec2, pos,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComponent = require('./component');\n\nPool = require('./pool');\n\nVec2 = require('./math').Vec2;\n\nEngine = require('./engine');\n\nBorder = (function(_super) {\n\n  __extends(Border, _super);\n\n  function Border() {\n    Border.__super__.constructor.apply(this, arguments);\n  }\n\n  Border.prototype.type = 'border';\n\n  Border.prototype.presets = {\n    mode: 'bounce',\n    restitution: 1\n  };\n\n  Border.prototype.reset = function(presets) {\n    this.mode = presets.mode, this.restitution = presets.restitution;\n    return this;\n  };\n\n  return Border;\n\n})(Component);\n\npos = Vec2();\n\nBorder.simulate = function(dt) {\n  var border, bounce, diff, hit, horizontal, kinetic, mirror, mode, parent, radius, restitution, size, vel, vertical, viewport, _i, _len, _ref;\n  size = Engine.renderer.content;\n  viewport = Engine.renderer.pos;\n  horizontal = Vec2.set(Vec2.cache[0], viewport[0], viewport[0] + size[0]);\n  vertical = Vec2.set(Vec2.cache[1], viewport[1], viewport[1] + size[1]);\n  _ref = this.roster;\n  for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n    border = _ref[_i];\n    if (!border.enabled) {\n      continue;\n    }\n    parent = border.parent, restitution = border.restitution, mode = border.mode, kinetic = border.kinetic;\n    vel = null;\n    if (kinetic) {\n      if (!kinetic.enabled || kinetic.sleeping) {\n        continue;\n      }\n      vel = kinetic.vel;\n    }\n    mirror = mode === 'mirror';\n    bounce = mode === 'bounce' && vel;\n    Vec2.copy(pos, parent.transform.pos);\n    radius = parent.bounds.radius;\n    if (mirror) {\n      radius *= -1;\n    }\n    hit = 0;\n    if ((diff = pos[0] - radius - horizontal[0]) < 0) {\n      if (mirror) {\n        pos[0] = horizontal[1] - radius;\n      } else {\n        pos[0] -= diff;\n        if (bounce) {\n          vel[0] *= -restitution;\n        }\n      }\n      hit = -1;\n    } else {\n      diff = pos[0] + radius - horizontal[1];\n      if (diff > 0) {\n        if (mirror) {\n          pos[0] = radius;\n        } else {\n          pos[0] -= diff;\n          if (bounce) {\n            vel[0] *= -restitution;\n          }\n        }\n        hit = -1;\n      }\n    }\n    if ((diff = pos[1] - radius - vertical[0]) < 0) {\n      if (mirror) {\n        pos[1] = vertical[1] - radius;\n      } else {\n        pos[1] -= diff;\n        if (bounce) {\n          vel[1] *= -restitution;\n        }\n      }\n      hit = 1;\n    } else {\n      diff = pos[1] + radius - vertical[1];\n      if (diff > 0) {\n        if (mirror) {\n          pos[1] = radius;\n        } else {\n          pos[1] -= diff;\n          if (bounce) {\n            vel[1] *= -restitution;\n          }\n        }\n        hit = 1;\n      }\n    }\n    if (hit != null) {\n      parent.transform.setTransform(pos);\n      parent.pub('onBorder', hit);\n      if (border.mode === 'kill') {\n        parent.free();\n      }\n    }\n  }\n  return this;\n};\n\nnew Pool(Border);\n\nmodule.exports = Border;\n\n//@ sourceURL=/lib/core/border.js"
));

require.define("/lib/core/engine.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.5.0\nvar Composite, Engine, Pool, Vec2, engine, perf, requestAnimationFrame,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nComposite = require('./composite');\n\nPool = require('./pool');\n\nVec2 = require('./math').Vec2;\n\nrequestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {\n  return setTimeout(callback, 20);\n};\n\nperf = window.performance || {};\n\nperf.now = perf.now || perf.webkitNow || perf.msNow || perf.mozNow || Date.now;\n\nEngine = (function(_super) {\n\n  __extends(Engine, _super);\n\n  function Engine() {\n    Engine.__super__.constructor.apply(this, arguments);\n  }\n\n  Engine.prototype.type = 'engine';\n\n  Engine.prototype.init = function(element) {\n    var Input,\n      _this = this;\n    this.element = element;\n    this.time = 0.0;\n    this.frame = 0;\n    this.tail = 0.0;\n    this.debug = {\n      step: false,\n      fps: false,\n      fpsLength: 0,\n      fpsSum: 0,\n      mspf: true,\n      mspfLength: 0,\n      mspfSum: 0,\n      stats: false,\n      profile: 0\n    };\n    this.fdt = 1 / 60;\n    this.dtCap = 0.5;\n    this.fdtCap = this.fdt * 5;\n    this.scale = 1;\n    this.fps = 0;\n    this.mspf = 0;\n    Input = require('./input');\n    Input.alloc(this);\n    return this.tickBound = function(now) {\n      return _this.tick(now);\n    };\n  };\n\n  Engine.prototype.play = function(scene) {\n    this.scene = scene;\n    this.input.root = this.scene;\n    if (this.debug.stats) {\n      this.startStats();\n    }\n    if (!this.running) {\n      return this.start();\n    }\n  };\n\n  Engine.prototype.start = function() {\n    this.running = true;\n    requestAnimationFrame(this.tickBound);\n    return this;\n  };\n\n  Engine.prototype.tick = function(now) {\n    var debug, dt, mspfStart;\n    now = (now && now < 1e12 ? now : perf.now()) / 1000;\n    debug = this.debug;\n    if (this.lastTime) {\n      if ((dt = now - this.lastTime) > 0.5) {\n        dt = this.fdt;\n      } else if (dt > 0.01) {\n        if (debug.fpsSum > 0.333) {\n          this.fps = debug.fpsLength / debug.fpsSum;\n          debug.fpsLength = 0;\n          debug.fpsSum = 0;\n        }\n        debug.fpsSum += dt;\n        debug.fpsLength++;\n      }\n      this.dt = (dt *= this.scale);\n      this.time += dt;\n      this.frame++;\n      if (debug._stats) {\n        debug._stats.begin();\n      }\n      if (debug.mspf) {\n        mspfStart = perf.now();\n      }\n      if (debug.profile && !debug.profileFrom) {\n        debug.profileFrom = debug.profile;\n        console.profile(\"Frame \" + debug.profileFrom);\n      }\n      this.update(dt);\n      if (debug.profileFrom) {\n        if (!--debug.profile) {\n          console.profileEnd(\"Frame \" + debug.profileFrom);\n          debug.profileFrom = 0;\n        }\n      }\n      if (debug.step) {\n        debugger;\n      }\n      if (debug.mspf) {\n        if (debug.mspfSum > 100) {\n          this.mspf = debug.mspfSum / debug.mspfLength;\n          debug.mspfLength = 0;\n          debug.mspfSum = 0;\n        }\n        debug.mspfSum += perf.now() - mspfStart;\n        debug.mspfLength++;\n      }\n      if (debug._stats) {\n        debug._stats.end();\n      }\n    } else {\n      this.time = now;\n    }\n    this.lastTime = now;\n    if (this.running) {\n      requestAnimationFrame(this.tickBound);\n    }\n    return this;\n  };\n\n  Engine.prototype.update = function(dt) {\n    var ctx, fdt, fps, mspf, tail;\n    ctx = this.renderer.save();\n    tail = Math.min(this.tail + dt, this.fdtCap * this.scale);\n    fdt = this.fdt;\n    while (tail > fdt) {\n      tail -= fdt;\n      Pool.invoke('fixedUpdate', fdt);\n      Pool.invoke('simulate', fdt);\n    }\n    this.tail = tail;\n    Pool.invoke('update', dt);\n    Pool.invoke('lateUpdate', dt);\n    Pool.invoke('render', ctx, dt);\n    if (this.debug.fps && this.fps < 55) {\n      fps = Math.round(this.fps);\n      ctx.fillStyle = 'black';\n      ctx.strokeStyle = 'white';\n      ctx.lineWidth = 2;\n      ctx.strokeText(fps, 2, 11);\n      ctx.fillText(fps, 2, 11);\n    }\n    if (this.debug.mspf) {\n      mspf = Math.round(this.mspf);\n      ctx.fillStyle = 'black';\n      ctx.strokeStyle = 'white';\n      ctx.lineWidth = 2;\n      ctx.strokeText(mspf, 2, 11);\n      ctx.fillText(mspf, 2, 11);\n    }\n    return this.renderer.restore();\n  };\n\n  Engine.prototype.startStats = function() {\n    var el, stats;\n    if (this.debug._stats || !window.Stats) {\n      return;\n    }\n    this.debug._stats = stats = new Stats();\n    el = stats.domElement;\n    el.style.position = 'absolute';\n    el.style.left = 0;\n    el.style.top = 0;\n    document.body.appendChild(el);\n    return this;\n  };\n\n  return Engine;\n\n})(Composite);\n\nengine = new Engine();\n\nif ('console' in window) {\n  window.mgame = console.m = {\n    pool: Pool.dump,\n    profile: function(frames) {\n      if (frames == null) {\n        frames = 1;\n      }\n      engine.debug.profile = frames;\n      return null;\n    },\n    step: function() {\n      engine.debug.step = !engine.debug.step;\n      return null;\n    }\n  };\n}\n\nmodule.exports = engine;\n\n//@ sourceURL=/lib/core/engine.js"
));

require.define("/test/core.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Generated by CoffeeScript 1.5.0\nvar core, key;\n\ncore = require('../lib/core');\n\ncore.cloud = require('./client');\n\nfor (key in core) {\n  if (!window[key]) {\n    window[key] = core[key];\n  }\n  window['m' + key] = core[key];\n}\n\n//@ sourceURL=/test/core.js"
));
require("/test/core.js");
})();
