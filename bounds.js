// Generated by CoffeeScript 1.3.3
var Bounds, Component, Pool, Vec2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

Bounds = (function(_super) {

  __extends(Bounds, _super);

  Bounds.prototype.type = 'bounds';

  Bounds.prototype.presets = {
    shape: 'rect',
    radius: 0,
    size: Vec2()
  };

  function Bounds() {
    this.topLeft = Vec2();
    this.bottomRight = Vec2();
    this.size = Vec2();
  }

  Bounds.prototype.reset = function(presets) {
    Vec2.copy(this.size, presets.size);
    this.shape = presets.shape;
    this.radius = presets.radius;
    this.epsilion = 0;
    return this;
  };

  Bounds.prototype.intersectLine = function(p1, p2) {
    return null;
  };

  Bounds.prototype.intersect = function(bound) {
    return null;
  };

  Bounds.prototype.contains = function(point) {
    var e, transform;
    transform = this.parent.transform;
    e = this.epsilion;
    switch (this.shape) {
      case 'sphere':
        return Vec2.distSq(transform.pos, point) <= this.radius * this.radius;
      case 'rect':
        return transform.pos[0] < point[0] && transform.pos[1] < point[1] && transform.pos[0] + this.size[0] > point[0] && transform.pos[1] + this.size[1] > point[1];
    }
    return false;
  };

  return Bounds;

})(Component);

Bounds.rectCircle = function(topLeft, size, center, radius) {
  var circleDistanceX, circleDistanceY, cornerDistance;
  circleDistanceX = abs(cx - rx - rw / 2);
  circleDistanceY = abs(cy - ry - rh / 2);
  if (circleDistanceX > (rw / 2 + cr) || circleDistanceY > (rh / 2 + cr)) {
    return false;
  }
  if (circleDistanceX <= rw / 2 || circleDistanceY <= rh / 2) {
    return true;
  }
  cornerDistance = Math.pow(circleDistanceX - rw / 2, 2) + pow(circleDistanceY - rh / 2, 2);
  return cornerDistance <= pow(cr, 2);
};

Bounds.rectRect = function(topLeft, bottomRight, topLeft2, bottomRight2) {
  this.topLeft = topLeft;
  this.bottomRight = bottomRight;
  this.topLeft2 = topLeft2;
  this.bottomRight2 = bottomRight2;
  return left > otherRight || right < otherLeft || top > otherBottom || bottom < otherTop;
};

Bounds.lineRect = function(point1, point2, topLeft, size) {
  var botOverlap, bottomIntersection, bottomPoint, c, m, topIntersection, topOverlap, topPoint, _ref, _ref1;
  this.topLeft = topLeft;
  this.size = size;
  m = (y2 - y1) / (x2 - x1);
  c = y1(-(m * x1));
  if (m > 0) {
    topIntersection = m * rx + c;
    bottomIntersection = m * (rx + rw) + c;
  } else {
    topIntersection = m * (rx + rw) + c;
    bottomIntersection = m * rx + c;
  }
  if (y1 < y2) {
    topPoint = y1;
    bottomPoint = y2;
  } else {
    topPoint = y2;
    bottomPoint = y1;
  }
  topOverlap = (_ref = topIntersection > topPoint) != null ? _ref : {
    topIntersection: topPoint
  };
  botOverlap = (_ref1 = bottomIntersection < bottomPoint) != null ? _ref1 : {
    bottomIntersection: bottomPoint
  };
  return (topOverlap < botOverlap) && (!((botOverlap < ry) || (topOverlap > ry + rh)));
};

Bounds.lineCirc = function(point1, point2, center, radius) {
  var a, b, bb4ac, c, dx, dy, ix1, ix2, iy1, iy2, mu, testX, testY;
  dx = x2 - x1;
  dy = y2 - y1;
  a = dx * dx + dy * dy;
  b = 2 * (dx * (x1 - cx) + dy * (y1 - cy));
  c = cx * cx + cy * cy;
  c += x1 * x1 + y1 * y1;
  c -= 2 * (cx * x1 + cy * y1);
  c -= cr * cr;
  bb4ac = b * b - 4 * a * c;
  if (bb4ac < 0) {
    return false;
  }
  mu = (-b + sqrt(b * b - 4 * a * c)) / (2 * a);
  ix1 = x1 + mu * dx;
  iy1 = y1 + mu * dy;
  mu = (-b - sqrt(b * b - 4 * a * c)) / (2 * a);
  ix2 = x1 + mu * dx;
  iy2 = y1 + mu * dy;
  if (dist(x1, y1, cx, cy) < dist(x2, y2, cx, cy)) {
    testX = x2;
    testY = y2;
  } else {
    testX = x1;
    testY = y1;
  }
  if (dist(testX, testY, ix1, iy1) < dist(x1, y1, x2, y2) || dist(testX, testY, ix2, iy2) < dist(x1, y1, x2, y2)) {
    return true;
  }
  return false;
};

new Pool(Bounds);

module.exports = Bounds;
