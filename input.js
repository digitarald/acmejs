// Generated by CoffeeScript 1.3.3
var Component, Engine, Input, Pool, Vec2, pool,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require('./component');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

Engine = require('./engine');

Input = (function(_super) {

  __extends(Input, _super);

  Input.prototype.type = 'input';

  function Input() {
    var code, key, type, _ref;
    this.pos = Vec2();
    this.touchState = null;
    this.axis - Vec2();
    this.prevPos = Vec2();
    this.queue = [];
    this.map = {
      32: 'space',
      192: 'debug'
    };
    this.keyNames = [];
    this.keys = {};
    _ref = this.map;
    for (code in _ref) {
      key = _ref[code];
      if (!~this.keyNames.indexOf(key)) {
        this.keyNames.push(key);
        this.keys[key] = null;
      }
    }
    this.throttled = {
      mousemove: true,
      touchmove: true
    };
    this.hasTouch = 'ontouchstart' in window;
    this.events = this.hasTouch ? {
      touchstart: 'startTouch',
      touchmove: 'moveTouch',
      touchend: 'endTouch',
      touchcancel: 'endTouch'
    } : {
      mousedown: 'startTouch',
      mousemove: 'moveTouch',
      mouseup: 'endTouch',
      keydown: 'keyStart',
      keyup: 'keyEnd'
    };
    for (type in this.events) {
      document.addEventListener(type, this, false);
    }
  }

  Input.prototype.handleEvent = function(event) {
    var type;
    if (event.metaKey) {
      return;
    }
    event.preventDefault();
    type = event.type;
    if (this.throttled[type] && this.queued === type) {
      this.queue[this.queue.length - 1] = event;
    } else {
      this.queued = type;
      this.queue.push(event);
    }
    return true;
  };

  Input.prototype.keyStart = function(event) {
    var key;
    if ((key = this.map[event.keyCode]) && !this.keys[key]) {
      this.keys[key] = 'began';
      Engine.pub('onKeyBegan', key);
    }
    return this;
  };

  Input.prototype.keyEnd = function(event) {
    var key;
    if (key = this.map[event.keyCode]) {
      this.keys[key] = 'ended';
      Engine.pub('onKeyEnded', key);
    }
    return this;
  };

  Input.prototype.startTouch = function(event) {
    this.resolve(event);
    if (!this.touchState && !event.metaKey) {
      this.touchState = 'began';
    }
    return this;
  };

  Input.prototype.moveTouch = function(event) {
    var state;
    this.resolve(event);
    state = this.touchState;
    if (state && state !== 'ended' && state !== 'moved') {
      this.touchState = 'moved';
    }
    return this;
  };

  Input.prototype.endTouch = function(event) {
    this.resolve(event);
    if (this.touchState && (!this.hasTouch || !event.targetTouches.length)) {
      this.touchState = 'ended';
    }
    return this;
  };

  Input.prototype.resolve = function(event) {
    var coords, renderer;
    coords = this.hasTouch ? event.targetTouches[0] : event;
    if (coords) {
      this.prevTime = this.time;
      this.time = event.timeStamp / 1000;
      Vec2.copy(this.prevPos, this.pos);
      renderer = Engine.renderer;
      Vec2.set(this.pos, (coords.pageX - renderer.margin[0]) / renderer.scale | 0, (coords.pageY - renderer.margin[1]) / renderer.scale | 0);
    }
    return this;
  };

  Input.prototype.lateUpdate = function(dt, scene) {
    var event, key, keys, _i, _len, _ref;
    switch (this.touchState) {
      case 'began':
        this.touchState = 'stationary';
        break;
      case 'ended':
        this.touchState = null;
        break;
    }
    keys = this.keys;
    _ref = this.keyNames;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      switch (keys[key]) {
        case 'began':
          keys[key] = 'pressed';
          Engine.pub('onKeyPressed', key);
          break;
        case 'ended':
          keys[key] = null;
          break;
      }
    }
    event = this.queue.shift();
    if (event) {
      this[this.events[event.type]](event);
    }
    this.queued = null;
    return this;
  };

  return Input;

})(Component);

pool = new Pool(Input);

module.exports = Input;
