// Generated by CoffeeScript 1.3.3
var Input,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Input = (function(_super) {

  __extends(Input, _super);

  Input.prototype.name = 'input';

  function Input() {
    var name;
    this.pos = Vec2();
    this.prevPos = Vec2();
    this.queue = [];
    this.map = {
      32: 'space',
      192: 'debug'
    };
    this.throttled = {
      mousemove: true,
      touchmove: true
    };
    this.hasTouch = 'ontouchstart' in window;
    this.events = this.hasTouch ? {
      touchstart: 'startTouch',
      touchmove: 'moveTouch',
      touchend: 'endTouch',
      touchcancel: 'endTouch'
    } : {
      mousedown: 'startTouch',
      mousemove: 'moveTouch',
      mouseup: 'endTouch',
      keydown: 'keyStart',
      keyup: 'keyEnd'
    };
    for (name in this.events) {
      document.addEventListener(name, this, false);
    }
  }

  Input.prototype.handleEvent = function(event) {
    var type;
    type = event.type;
    if (type in this.throttled && this.queued === type) {
      return this.queue[this.queue.length - 1] = event;
    } else {
      this.queued = type;
      return this.queue.push(event);
    }
  };

  Input.prototype.keyStart = function(event) {
    var code;
    if (!event.metaKey) {
      code = event.keyCode;
      if (!this.keyState && code in this.map) {
        this.keyState = 'began';
        this.key = this.map[code];
      }
      return false;
    }
    return this;
  };

  Input.prototype.keyEnd = function(event) {
    if (this.keyState) {
      this.keyState = 'ended';
    }
    return this;
  };

  Input.prototype.startTouch = function(event) {
    this.resolve(event);
    if (!this.touchState && !event.metaKey) {
      this.touchState = 'began';
      return false;
    }
    return this;
  };

  Input.prototype.moveTouch = function(event) {
    var state;
    this.resolve(event);
    state = this.touchState;
    if (state && state !== 'ended' && state !== 'moved') {
      this.touchState = 'moved';
    }
    return this;
  };

  Input.prototype.endTouch = function(event) {
    if (this.touchState && (!this.hasTouch || !event.targetTouches.length)) {
      this.touchState = 'ended';
    }
    return this;
  };

  Input.prototype.resolve = function(event) {
    var coords;
    this.prevTime = this.time;
    this.time = event.timeStamp / 1000;
    coords = this.hasTouch ? event.targetTouches[0] : event;
    if (coords) {
      Vec2.copy(this.prevPos, this.pos);
      Vec2.set(this.pos, coords.pageX - Engine.renderer.margin[0], coords.pageY - Engine.renderer.margin[1]);
    }
    return this;
  };

  Input.prototype.lateUpdate = function(dt, scene) {
    var event;
    switch (this.touchState) {
      case 'began':
        this.touchState = 'stationary';
        break;
      case 'ended':
        this.touchState = null;
        break;
    }
    switch (this.keyState) {
      case 'began':
        this.keyState = 'pressed';
        break;
      case 'ended':
        this.keyState = null;
        break;
    }
    event = this.queue.shift();
    if (event) {
      this[this.events[event.type]](event);
    }
    this.queued = null;
    return this;
  };

  return Input;

})(Component);

new Pool(Input);
