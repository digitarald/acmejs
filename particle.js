// Generated by CoffeeScript 1.3.3
var Particle,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Particle = (function() {

  function Particle() {
    this.pos = Vec2();
    this.vel = Vec2();
    this.acc = Vec2();
    this.colorStart = Color();
    this.color = Color();
  }

  Particle.prototype.acquire = function(pos, dir, lifetime, radius, mass) {
    this.lifetime = lifetime != null ? lifetime : 1000;
    this.radius = radius != null ? radius : 1;
    this.mass = mass != null ? mass : this.radius;
    this.acquired = true;
    Vec2.copy(this.pos, pos);
    Vec2.copy(this.vel, dir);
    Vec2.set(this.acc);
    Color.copy(this.color, this.colorStart);
    this.massInv = 1 / this.mass;
    this.age = 0;
    Pubsub.pool.acquire(this);
    return this;
  };

  Particle.prototype.release = function() {
    this.acquired = false;
    this.pubsub.pub('release', this).release();
    return this;
  };

  return Particle;

})();

Pool.Particles = (function(_super) {

  __extends(Particles, _super);

  function Particles() {
    return Particles.__super__.constructor.apply(this, arguments);
  }

  Particles.prototype.allocate = function() {
    return new Particle();
  };

  Particles.prototype.update = function(delta, world) {
    var acc, age, cache, oldVel, particle, vel, _i, _len, _ref;
    oldVel = Vec2.cache[0];
    cache = Vec2.cache[1];
    _ref = this.buffer;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      particle = _ref[_i];
      if (!particle.acquired) {
        continue;
      }
      age = (particle.age += delta);
      if (age > particle.lifetime) {
        particle.release();
        continue;
      }
      particle.color[3] = 1 - Math.quadIn(age / particle.lifetime);
      vel = particle.vel;
      acc = Vec2.add(particle.acc, world.gravity);
      oldVel = Vec2.copy(oldVel, vel);
      Vec2.scal(acc, particle.massInv);
      if (world.friction) {
        Vec2.add(acc, Vec2.scal(Vec2.norm(Vec2.inv(vel, cache)), world.friction));
      }
      if (world.drag) {
        Vec2.scal(vel, world.drag);
      }
      Vec2.add(particle.vel, Vec2.scal(acc, delta / 1000, cache));
      Vec2.add(particle.pos, Vec2.scal(Vec2.add(oldVel, particle.vel), 0.5 * delta / 1000));
      Vec2.set(acc, 0, 0);
    }
    return this;
  };

  Particles.prototype.draw = function(context) {
    var TAU, color, particle, _i, _len, _ref;
    TAU = Math.TAU;
    context.save();
    _ref = this.buffer;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      particle = _ref[_i];
      if (!particle.acquired) {
        continue;
      }
      color = particle.color;
      context.fillStyle = Color.rgba(color);
      context.beginPath();
      context.arc(particle.pos[0] | 0, particle.pos[1] | 0, particle.radius, 0, TAU, true);
      context.closePath();
      context.fill();
    }
    context.restore();
    return this;
  };

  return Particles;

})(Pool);

Particle.pool = new Pool.Particles(256);
