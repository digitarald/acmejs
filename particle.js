// Generated by CoffeeScript 1.3.3
var Particle,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Particle = (function() {

  function Particle() {
    this.pos = Vec2();
    this.vel = Vec2();
    this.acc = Vec2();
    this.angle = Vec2();
  }

  Particle.prototype.alloc = function(pos, dir, lifetime, radius, mass) {
    this.lifetime = lifetime != null ? lifetime : 1000;
    this.radius = radius != null ? radius : 1;
    this.mass = mass != null ? mass : this.radius;
    Vec2.copy(this.pos, pos);
    Vec2.copy(this.vel, dir);
    Vec2.set(this.acc);
    this.massInv = 1 / this.mass;
    this.age = 0;
    this.maxVel = 120;
    Pubsub.pool.alloc(this);
    return this;
  };

  Particle.prototype.free = function() {
    this.allocd = false;
    this.pubsub.pub('free', this);
    this.pubsub.free();
    return this;
  };

  return Particle;

})();

Pool.Particles = (function(_super) {

  __extends(Particles, _super);

  function Particles() {
    return Particles.__super__.constructor.apply(this, arguments);
  }

  Particles.prototype.instantiate = function() {
    return new Particle();
  };

  Particles.prototype.update = function(dt, engine) {
    var acc, age, cache, oldVel, particle, vel, _i, _len, _ref;
    oldVel = Vec2.cache[0];
    cache = Vec2.cache[1];
    _ref = this.roster;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      particle = _ref[_i];
      if (!particle.allocd) {
        continue;
      }
      age = (particle.age += dt);
      if (age > particle.lifetime) {
        particle.free();
        continue;
      }
      vel = particle.vel;
      acc = Vec2.add(particle.acc, Vec2.scal(engine.gravity, particle.massInv, cache));
      oldVel = Vec2.copy(oldVel, vel);
      if (engine.friction) {
        Vec2.add(acc, Vec2.scal(Vec2.norm(Vec2.inv(vel, cache)), engine.friction));
      }
      if (engine.drag < 1) {
        Vec2.scal(vel, engine.drag);
      }
      Vec2.limit(Vec2.add(vel, Vec2.scal(acc, dt / 1000, cache)), particle.maxVel);
      Vec2.add(particle.pos, Vec2.scal(Vec2.add(oldVel, particle.vel), 0.5 * dt / 1000));
      Vec2.copy(particle.angle, acc);
      Vec2.set(acc, 0, 0);
    }
    return this;
  };

  Particles.prototype.draw = function(context) {
    var TAU, particle, _i, _len, _ref;
    TAU = Math.TAU;
    context.save();
    context.globalCompositeOperation = 'xor';
    _ref = this.roster;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      particle = _ref[_i];
      if (!particle.allocd) {
        continue;
      }
      context.fillStyle = Color.rgba(particle.color);
      context.beginPath();
      context.arc(particle.pos[0] | 0, particle.pos[1] | 0, particle.radius | 0, 0, TAU, true);
      context.closePath();
      context.fill();
    }
    context.restore();
    return this;
  };

  return Particles;

})(Pool);

Particle.pool = new Pool.Particles(128);
