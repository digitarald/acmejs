// Generated by CoffeeScript 1.3.3
var Composite, Engine, Pool, Vec2, requestAnimationFrame,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Composite = require('./composite');

Pool = require('./pool');

Vec2 = require('./math').Vec2;

Engine = (function(_super) {

  __extends(Engine, _super);

  function Engine() {
    return Engine.__super__.constructor.apply(this, arguments);
  }

  Engine.prototype.type = 'engine';

  Engine.prototype.init = function(element) {
    var Input,
      _this = this;
    this.element = element;
    this.time = 0.0;
    this.frame = 0;
    this.tail = 0.0;
    this.debug = false;
    this.fdt = 1 / 60;
    this.dtCap = 0.5;
    this.fdtCap = this.fdt * 5;
    this.scale = 1;
    this.fps = 1 / 60;
    Input = require('./input');
    Input.alloc(this);
    this.tickBound = function(now) {
      return _this.tick(now);
    };
    this.element.addEventListener('dblclick', function() {
      if ('webkitRequestFullScreen' in _this.element) {
        return _this.element.webkitRequestFullScreen();
      } else if ('mozRequestFullScreen' in _this.element) {
        return _this.element.mozRequestFullScreen();
      }
    }, false);
    return this;
  };

  Engine.prototype.play = function(scene) {
    this.scene = scene;
    this.input.root = this.scene;
    if (!this.running) {
      return this.start();
    }
  };

  Engine.prototype.start = function() {
    this.running = true;
    requestAnimationFrame(this.tickBound);
    return this;
  };

  Engine.prototype.tick = function(now) {
    var dt;
    now = (now && now > 1e12 ? now : Date.now()) / 1000;
    if (this.lastTime) {
      if ((dt = now - this.lastTime) > 0.5) {
        dt = this.fdt;
      } else if (dt) {
        this.fps = this.fps * 0.9 + 0.1 / dt;
      }
      this.dt = (dt *= this.scale);
      this.time += dt;
      this.frame++;
      this.update(dt);
      if (this.debug) {
        debugger;
      }
    } else {
      this.time = now;
    }
    this.lastTime = now;
    if (this.running) {
      requestAnimationFrame(this.tickBound);
    }
    return this;
  };

  Engine.prototype.update = function(dt) {
    var ctx, fdt, tail;
    ctx = this.renderer.save();
    tail = Math.min(this.tail + dt, this.fdtCap * this.scale);
    fdt = this.fdt;
    while (tail > fdt) {
      tail -= fdt;
      Pool.invoke('fixedUpdate', fdt);
      Pool.invoke('simulate', fdt);
    }
    this.tail = tail;
    Pool.invoke('update', dt);
    Pool.invoke('lateUpdate', dt);
    Pool.invoke('render', ctx, dt);
    ctx.fillStyle = 'black';
    ctx.strokeStyle = 'white';
    ctx.font = '11px sans-serif';
    ctx.lineWidth = 3;
    ctx.strokeText(this.fps | 0, 0, 11);
    ctx.fillText(this.fps | 0, 0, 11);
    return this.renderer.restore();
  };

  return Engine;

})(Composite);

requestAnimationFrame = (function() {
  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
    return setTimeout(callback, 20);
  };
})();

module.exports = new Engine();
